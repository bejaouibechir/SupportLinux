# Atelier 1 : image vs build dans Docker Compose

---

## 1. 🎯 Contexte & Objectif

Cet atelier a pour but de **comparer deux approches** dans un fichier `docker-compose.yml` :

- **Approche 1 : utilisation d’une image standard** (ex. `nginx:latest`)

- **Approche 2 : construction d’une image personnalisée** à partir d’un `Dockerfile`

L’objectif est de comprendre :

- Quand utiliser `image:` (image publique ou privée déjà prête)

- Quand utiliser `build:` (image à construire localement)

- Comment vérifier que le comportement diffère entre les deux

---

## 2. 🧰 Préparation de l’environnement

Exécuter sur une machine Linux ou VM Debian avec Docker et Docker Compose installés :

```bash
sudo apt update
sudo apt install -y docker.io docker-compose
sudo systemctl enable --now docker
```

Créer un répertoire de travail :

```bash
mkdir -p ~/atelier-compose-image-vs-build
cd ~/atelier-compose-image-vs-build
```

---

## 3. ⚙️ Étape 1 – Exemple avec image: (standard)

Créer le fichier **`docker-compose-image.yml`** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:latest   # Utilise l'image officielle depuis Docker Hub
    ports:
      - "8080:80"
    container_name: nginx_image_example
```

### 🔍 Explications :

- `image: nginx:latest` → Docker va **télécharger** l’image depuis Docker Hub.

- Aucun `Dockerfile` n’est nécessaire.

- Le conteneur expose le port 80 du conteneur sur le port 8080 de la machine hôte.

### ▶️ Démarrage :

```bash
docker compose -f docker-compose-image.yml up -d
```

### ✅ Vérification :

```bash
curl http://localhost:8080
```

Vous devez voir la **page par défaut de Nginx**.

---

## 4. ⚙️ Étape 2 – Exemple avec build: (Dockerfile personnalisé)

Créer le fichier **`Dockerfile`** :

```bash
# Créer le fichier Dockerfile
FROM nginx:latest
# Copier une page HTML personnalisée
COPY index.html /usr/share/nginx/html/index.html
```

Créer le fichier **`index.html`** :

```html
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Page personnalisée Dockerfile</title>
</head>
<body style="font-family: Arial; text-align: center;">
  <h1>Bonjour depuis une image construite avec Dockerfile !</h1>
</body>
</html>
```

Créer le fichier **`docker-compose-build.yml`** :

```yaml
version: "3.9"

services:
  web:
    build: .                 # Construit à partir du Dockerfile local
    ports:
      - "8081:80"
    container_name: nginx_build_example
```

### 🔍 Explications :

- `build: .` → Docker Compose **construit une nouvelle image** à partir du Dockerfile présent dans le dossier courant.

- Cette image aura un contenu différent : la page HTML personnalisée remplace celle de Nginx.

- Le service sera exposé sur le port **8081** pour ne pas entrer en conflit avec l’autre.

### ▶️ Démarrage :

```bash
docker compose -f docker-compose-build.yml up -d --build
```

### ✅ Vérification :

```bash
curl http://localhost:8081
```

Vous devez voir :

```
Bonjour depuis une image construite avec Dockerfile !
```

## 5. 🧹 Nettoyage / Rollback

Pour supprimer les conteneurs, images et réseaux créés :

```bash
docker compose -f docker-compose-image.yml down
docker compose -f docker-compose-build.yml down
docker image prune -f
```

---

## 7. 💡 Astuces & Pièges

- ⚠️ Si vous combinez `image:` et `build:` sur le **même service**, Compose construit l’image **puis la tague** avec le nom fourni dans `image:` — ce n’est **pas une erreur**, mais il faut savoir ce que vous faites.

- ✅ Bon réflexe : utilisez `image:` pour les services **externes et stables**, `build:` pour vos **applications personalisée**.

- 🚀 Pour forcer une reconstruction :
  
  ```bash
  docker compose build --no-cache
  ```

## 8. ⚙️Combiner build **et** image dans un même service

## 1) Contexte & objectif

- **Pourquoi** : personnaliser l’image via un `Dockerfile` **et** lui donner un **nom/version** cohérent (ex. `demo/nginx-custom:1.0`) pour publication ou CI/CD.

- **Ce qui se passe** : `docker compose` **construit** l’image (clé `build:`), puis **l’étiquette** avec `image:`. Ce n’est **pas interdit** et c’est une pratique courante.

## 2) Préparation

Assurez-vous d’avoir Docker et Compose prêts, et placez-vous dans votre dossier d’atelier (ex. `~/atelier-compose-image-vs-build`).

## 3) Création des fichiers

Créer le fichier **index.html** :

```bash
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Nginx personnalisé — build + image</title>
</head>
<body style="font-family: Arial; text-align: center;">
  <h1>Nginx personnalisé (build) avec un tag d'image (image: demo/nginx-custom:1.0)</h1>
  <p>Cette page provient d'une image construite localement puis étiquetée.</p>
</body>
</html>
```

Créer le fichier **Dockerfile** :

```bash
# Image de base officielle Nginx
FROM nginx:latest
# Copier une page HTML personnalisée dans le document root par défaut de Nginx
COPY index.html /usr/share/nginx/html/index.html
```

Créer le fichier **docker-compose.yml** :

```yaml
version: "3.9"

services:
  web:
    # 1) build = construction à partir du Dockerfile local
    build: .

    # 2) image = nom/étiquette (tag) final de l'image construite
    image: demo/nginx-custom:1.0

    # Publication du service en local
    ports:
      - "8082:80"

    # Nom explicite du conteneur (optionnel mais pratique)
    container_name: nginx_build_and_image_example

    # Variable d'environnement illustrative (optionnelle)
    environment:
      - NGINX_ENV=demo-build-image
```

## 4) Exécution & vérifications

Construire et démarrer :

```bash
docker compose up -d --build
```

Vérifier l’image construite et **taguée** :

```bash
docker images | grep -E 'demo/nginx-custom|REPOSITORY|TAG'
```

Résultat attendu (exemple) :

```
REPOSITORY            TAG       IMAGE ID       CREATED          SIZE
demo/nginx-custom     1.0       a1b2c3d4e5f6   <il y a  X sec>  187MB
```

Vérifier le conteneur :

```bash
docker compose ps
```

Vérifier la page servie :

```bash
curl -s http://localhost:8082 | head -n 5
```

Vous devez voir le HTML mentionnant **image: demo/nginx-custom:1.0**.

### Rebuild après modification (cache)

Modifiez le `<h1>` dans `index.html`, puis :

```bash
docker compose build
docker compose up -d
curl -s http://localhost:8082 | head -n 5
```

Vous constatez la **mise à jour**.

## 5) Nettoyage / rollback

```bash
docker compose down
docker rmi demo/nginx-custom:1.0 || true
```

## 6) Astuces & pièges

- `build` **+** `image` dans le **même service** = **valide** : Compose **construit** puis **tague** l’image.

- Pensez à `.dockerignore` pour accélérer les builds.

- Préférez des tags **versionnés** (évitez `latest`) pour la traçabilité.

- Contrôlez le **contexte** (`build: .`) : s’il est trop large, le build sera lent.

- Publication éventuelle : `docker login` puis `docker push demo/nginx-custom:1.0`.

---

# 🧑‍🏫 Atelier 2: Comprendre entrypoint et command dans Docker Compose

## 1. 🎯 Contexte & Objectif

L’objectif de cet atelier est de **comprendre la différence entre `entrypoint` et `command`** dans Docker Compose et d’expérimenter leur comportement sur un conteneur simple.

Nous allons :

- Créer une image à partir d’un `Dockerfile` qui définit un **ENTRYPOINT** et un **CMD**.

- Modifier ce comportement via `docker-compose.yml` à l’aide des clés `entrypoint` et `command`.

- Observer les effets sur l’exécution du conteneur.

---

## 2. 🧰 Préparation de l’environnement

Créer le répertoire de travail :

```bash
mkdir -p ~/atelier-entrypoint-command
cd ~/atelier-entrypoint-command
```

---

## 3. ⚙️ Étape 1 – Créer une image avec ENTRYPOINT et CMD

Créer le fichier **Dockerfile** :

```bash
FROM debian:stable-slim

# Installer un petit utilitaire (ping)
RUN apt update && apt install -y iputils-ping && apt clean

# Définir le point d'entrée et la commande par défaut
ENTRYPOINT ["ping"]
CMD ["127.0.0.1"]
```

### Explication :

- `ENTRYPOINT ["ping"]` → définit le programme **exécutable principal** du conteneur.

- `CMD ["127.0.0.1"]` → fournit **les arguments par défaut** à ce programme.  
  → donc par défaut, le conteneur exécutera :
  
  ```bash
  ping 127.0.0.1
  ```

Construire l’image :

```bash
docker build -t ping-demo .
```

Tester directement :

```bash
docker run --rm ping-demo -c 2
```

> ✅ Résultat attendu :  
> Deux requêtes ICMP vers `127.0.0.1` s’affichent.

---

## 4. ⚙️ Étape 2 – Utilisation de command: dans Docker Compose

Créer le fichier **docker-compose-command.yml** :

```yaml
version: "3.9"

services:
  ping_service:
    image: ping-demo
    command: ["-c", "3", "8.8.8.8"]   # Remplace uniquement CMD, pas ENTRYPOINT
```

### Explication :

- `command:` **remplace le CMD** défini dans le Dockerfile, **mais garde l’ENTRYPOINT**.

- Donc ici le conteneur exécutera :
  
  ```bash
  ping -c 3 8.8.8.8
  ```

Démarrage du service :

```bash
docker compose -f docker-compose-command.yml up
```

> ✅ Résultat attendu :  
> Le conteneur ping trois fois l’adresse `8.8.8.8` (Google DNS).

Arrêter le service :

```bash
docker compose -f docker-compose-command.yml down
```

---

## 5. ⚙️ Étape 3 – Utilisation de `entrypoint:` dans Docker Compose

Créer le fichier **docker-compose-entrypoint.yml** :

```yaml
version: "3.9"

services:
  ping_service:
    image: ping-demo
    entrypoint: ["echo", "Le point d'entrée a été modifié !"]
```

### Explication :

- `entrypoint:` **remplace complètement** l’ENTRYPOINT du Dockerfile.

- `command:` (ou le CMD d’origine) devient alors **les arguments passés** à cette nouvelle commande.

- Dans ce cas, Docker exécutera :
  
  ```bash
  echo Le point d'entrée a été modifié !
  ```

Démarrage :

```bash
docker compose -f docker-compose-entrypoint.yml up
```

> ✅ Résultat attendu :  
> Le conteneur affiche simplement :
> 
> ```
> Le point d'entrée a été modifié !
> ```
> 
> puis s’arrête.

---

## 6. ⚙️ Étape 4 – Combiner entrypoint: et command: dans Docker Compose

Créer le fichier **docker-compose-both.yml** :

```yaml
version: "3.9"

services:
  ping_service:
    image: ping-demo
    entrypoint: ["ping"]
    command: ["-c", "2", "1.1.1.1"]
```

### Explication :

- Ici, **les deux** sont redéfinis.

- `entrypoint:` → redéfinit le binaire à exécuter.

- `command:` → redéfinit ses arguments.

Résultat final exécuté :

```bash
ping -c 2 1.1.1.1
```

Démarrage :

```bash
docker compose -f docker-compose-both.yml up
```

> ✅ Résultat attendu :  
> Deux paquets ICMP envoyés vers `1.1.1.1`.

---

## 7. 🧹 Nettoyage / Rollback

Arrêter et supprimer tous les services et images :

```bash
docker compose -f docker-compose-command.yml down
docker compose -f docker-compose-entrypoint.yml down
docker compose -f docker-compose-both.yml down
docker rmi ping-demo
```

## 8. 💡 Astuces & Pièges

- ⚠️ `entrypoint` **remplace totalement** l’ENTRYPOINT du Dockerfile → il ne conserve pas l’ancien.

- ⚙️ `command` **remplace uniquement CMD** → il s’ajoute à l’ENTRYPOINT existant.

- 🧩 Si vous utilisez `entrypoint` dans Compose, vérifiez bien les arguments attendus : sinon le conteneur peut se bloquer ou quitter immédiatement.

- 🔎 Pour diagnostiquer le comportement réel :
  
  ```bash
  docker inspect <nom_du_conteneur> | grep -A 2 Cmd
  ```

# Atelier 3 : Utiliser entrypoint pour lancer un script de démarrage avant l’application (Docker Compose)

## 1) Contexte & objectif

Mettre en place un **hook de démarrage** via `entrypoint` qui exécute un **script Bash** (pré-checks, logs, génération d’artifacts) avant de lancer l’application. Comprendre :

- `entrypoint` = lance votre script, puis passe la main à l’app.

- `command` (Compose) = remplace le `CMD` (arguments/commande de l’app), **sans toucher** à l’`entrypoint`.

## 2) Préparation de l’environnement

Exécuter sur Debian/Ubuntu.

```bash
mkdir -p ~/atelier-entrypoint-startup && cd ~/atelier-entrypoint-startup
```

## 3) Création des fichiers (application Flask + script d’entrée)

Créer le fichier **Dockerfile** :

```bash
FROM python:3.12-slim
# Dossier de travail
WORKDIR /app
# Copier sources
COPY app.py /app/app.py
COPY entrypoint.sh /app/entrypoint.sh
# Dépendance minimale pour la démo
RUN pip install --no-cache-dir Flask
# Rendre exécutable l’entrypoint
RUN chmod +x /app/entrypoint.sh
# Définir ENTRYPOINT (hook) et CMD (commande par défaut de l’app)
ENTRYPOINT ["/app/entrypoint.sh"]
CMD ["python", "app.py"]
```

Créer le fichier **entrypoint.sh** :

```bash
#!/usr/bin/env bash
# Script d’entrée : prépare l’environnement puis lance l’app
set -euo pipefail  # exit on error, undefined var, and pipefail pour fiabilité

# 1) Journalisation de démarrage
echo "[ENTRYPOINT] Démarrage du conteneur à $(date '+%F %T')"

# 2) Lire variables d’environnement (avec valeurs par défaut)
APP_MESSAGE="${APP_MESSAGE:-Bonjour depuis Flask via ENTRYPOINT !}"
APP_HOST="${APP_HOST:-0.0.0.0}"
APP_PORT="${APP_PORT:-8000}"
echo "[ENTRYPOINT] Variables: APP_MESSAGE='${APP_MESSAGE}', APP_HOST='${APP_HOST}', APP_PORT='${APP_PORT}'"

# 3) Générer un petit artifact prouvant le passage du hook
BOOT_DIR="/app/boot-artifacts"
mkdir -p "${BOOT_DIR}"
echo "Boot OK à $(date '+%F %T')" > "${BOOT_DIR}/startup.ok"
echo "[ENTRYPOINT] Artifact généré: ${BOOT_DIR}/startup.ok"

# 4) (Optionnel) Attendre un service externe (DB, API…) – exemple désactivé
# sleep 0.5

# 5) Exporter pour l’app
export APP_MESSAGE APP_HOST APP_PORT

# 6) Lancer l’application (remplace le PID 1) en transmettant la commande/arguments
echo "[ENTRYPOINT] Lancement de l'application: $*"
exec "$@"
```

Créer le fichier **app.py** :

```bash
from flask import Flask
import os

app = Flask(__name__)

@app.get("/")
def hello():
    # Message injecté via variables d'environnement (setup par l'entrypoint)
    message = os.getenv("APP_MESSAGE", "Bonjour !")
    return f"<h1>{message}</h1>"

if __name__ == "__main__":
    host = os.getenv("APP_HOST", "0.0.0.0")
    port = int(os.getenv("APP_PORT", "8000"))
    app.run(host=host, port=port, debug=False)
```

## 4) Fichier Docker Compose (avec entrypoint + command)

Créer le fichier **docker-compose.yml** :

```bash
version: "3.9"

services:
  web:
    build: .
    # entrypoint déjà présent dans l'image -> on ne le redéfinit pas ici
    command: ["python", "app.py"]    # remplace le CMD du Dockerfile si désiré
    environment:
      - APP_MESSAGE=Salut depuis Compose (CMD par défaut)
      - APP_HOST=0.0.0.0
      - APP_PORT=8080
    ports:
      - "8080:8080"
    # volumes:
    #   - ./artifacts:/app/boot-artifacts  # décommentez pour observer startup.ok côté hôte
```

## 5) Exécution pas à pas

```bash
docker compose up -d --build   # construit l'image et démarre le service
docker compose logs -f web     # observe les logs : [ENTRYPOINT] puis Flask
```

Vérification HTTP :

```bash
curl -s http://localhost:8080
# Attendu : <h1>Salut depuis Compose (CMD par défaut)</h1>
```

## 6) Variation — remplacer uniquement la commande (ENTRYPOINT inchangé)

Sans toucher au fichier, lancez avec d’autres paramètres :

```bash
docker compose run --rm -p -d 8082:8081 \
  -e APP_MESSAGE="Message dynamique via run" \
  -e APP_PORT=8082 \
  web python app.py

curl -s http://localhost:8082
# Attendu : <h1>Message dynamique via run</h1>
```

## 7) Nettoyage / rollback

```bash
docker compose down -v
docker image prune -f
```

## 8) Astuces & pièges

- Utilisez **`exec "$@"`** dans l’entrypoint pour transmettre correctement les signaux au process app (PID 1).

- L’**entrypoint ne doit pas bloquer** : préparez, loggez, puis **remettez la main** à l’app.

- **`entrypoint` remplace l’ENTRYPOINT de l’image** si redéfini côté Compose ; **`command` remplace le CMD**.

- Diagnostic rapide :
  
  ```bash
  docker compose ps
  docker inspect $(docker compose ps -q web) | grep -A2 -E '"Entrypoint"|"Cmd"'
  ```
