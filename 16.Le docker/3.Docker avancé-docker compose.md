# Atelier 1 : image vs build dans Docker Compose

---

## 1. üéØ Contexte & Objectif

Cet atelier a pour but de **comparer deux approches** dans un fichier `docker-compose.yml` :

- **Approche 1 : utilisation d‚Äôune image standard** (ex. `nginx:latest`)

- **Approche 2 : construction d‚Äôune image personnalis√©e** √† partir d‚Äôun `Dockerfile`

L‚Äôobjectif est de comprendre :

- Quand utiliser `image:` (image publique ou priv√©e d√©j√† pr√™te)

- Quand utiliser `build:` (image √† construire localement)

- Comment v√©rifier que le comportement diff√®re entre les deux

---

## 2. üß∞ Pr√©paration de l‚Äôenvironnement

Ex√©cuter sur une machine Linux ou VM Debian avec Docker et Docker Compose install√©s :

```bash
sudo apt update
sudo apt install -y docker.io docker-compose
sudo systemctl enable --now docker
```

Cr√©er un r√©pertoire de travail :

```bash
mkdir -p ~/atelier-compose-image-vs-build
cd ~/atelier-compose-image-vs-build
```

---

## 3. ‚öôÔ∏è √âtape 1 ‚Äì Exemple avec image: (standard)

Cr√©er le fichier **`docker-compose-image.yml`** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:latest   # Utilise l'image officielle depuis Docker Hub
    ports:
      - "8080:80"
    container_name: nginx_image_example
```

### üîç Explications :

- `image: nginx:latest` ‚Üí Docker va **t√©l√©charger** l‚Äôimage depuis Docker Hub.

- Aucun `Dockerfile` n‚Äôest n√©cessaire.

- Le conteneur expose le port 80 du conteneur sur le port 8080 de la machine h√¥te.

### ‚ñ∂Ô∏è D√©marrage :

```bash
docker compose -f docker-compose-image.yml up -d
```

### ‚úÖ V√©rification :

```bash
curl http://localhost:8080
```

Vous devez voir la **page par d√©faut de Nginx**.

---

## 4. ‚öôÔ∏è √âtape 2 ‚Äì Exemple avec build: (Dockerfile personnalis√©)

Cr√©er le fichier **`Dockerfile`** :

```bash
# Cr√©er le fichier Dockerfile
FROM nginx:latest
# Copier une page HTML personnalis√©e
COPY index.html /usr/share/nginx/html/index.html
```

Cr√©er le fichier **`index.html`** :

```html
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Page personnalis√©e Dockerfile</title>
</head>
<body style="font-family: Arial; text-align: center;">
  <h1>Bonjour depuis une image construite avec Dockerfile !</h1>
</body>
</html>
```

Cr√©er le fichier **`docker-compose-build.yml`** :

```yaml
version: "3.9"

services:
  web:
    build: .                 # Construit √† partir du Dockerfile local
    ports:
      - "8081:80"
    container_name: nginx_build_example
```

### üîç Explications :

- `build: .` ‚Üí Docker Compose **construit une nouvelle image** √† partir du Dockerfile pr√©sent dans le dossier courant.

- Cette image aura un contenu diff√©rent : la page HTML personnalis√©e remplace celle de Nginx.

- Le service sera expos√© sur le port **8081** pour ne pas entrer en conflit avec l‚Äôautre.

### ‚ñ∂Ô∏è D√©marrage :

```bash
docker compose -f docker-compose-build.yml up -d --build
```

### ‚úÖ V√©rification :

```bash
curl http://localhost:8081
```

Vous devez voir :

```
Bonjour depuis une image construite avec Dockerfile !
```

## 5. üßπ Nettoyage / Rollback

Pour supprimer les conteneurs, images et r√©seaux cr√©√©s :

```bash
docker compose -f docker-compose-image.yml down
docker compose -f docker-compose-build.yml down
docker image prune -f
```

---

## 7. üí° Astuces & Pi√®ges

- ‚ö†Ô∏è Si vous combinez `image:` et `build:` sur le **m√™me service**, Compose construit l‚Äôimage **puis la tague** avec le nom fourni dans `image:` ‚Äî ce n‚Äôest **pas une erreur**, mais il faut savoir ce que vous faites.

- ‚úÖ Bon r√©flexe : utilisez `image:` pour les services **externes et stables**, `build:` pour vos **applications personalis√©e**.

- üöÄ Pour forcer une reconstruction :
  
  ```bash
  docker compose build --no-cache
  ```

## 8. ‚öôÔ∏èCombiner build **et** image dans un m√™me service

## 1) Contexte & objectif

- **Pourquoi** : personnaliser l‚Äôimage via un `Dockerfile` **et** lui donner un **nom/version** coh√©rent (ex. `demo/nginx-custom:1.0`) pour publication ou CI/CD.

- **Ce qui se passe** : `docker compose` **construit** l‚Äôimage (cl√© `build:`), puis **l‚Äô√©tiquette** avec `image:`. Ce n‚Äôest **pas interdit** et c‚Äôest une pratique courante.

## 2) Pr√©paration

Assurez-vous d‚Äôavoir Docker et Compose pr√™ts, et placez-vous dans votre dossier d‚Äôatelier (ex. `~/atelier-compose-image-vs-build`).

## 3) Cr√©ation des fichiers

Cr√©er le fichier **index.html** :

```bash
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Nginx personnalis√© ‚Äî build + image</title>
</head>
<body style="font-family: Arial; text-align: center;">
  <h1>Nginx personnalis√© (build) avec un tag d'image (image: demo/nginx-custom:1.0)</h1>
  <p>Cette page provient d'une image construite localement puis √©tiquet√©e.</p>
</body>
</html>
```

Cr√©er le fichier **Dockerfile** :

```bash
# Image de base officielle Nginx
FROM nginx:latest
# Copier une page HTML personnalis√©e dans le document root par d√©faut de Nginx
COPY index.html /usr/share/nginx/html/index.html
```

Cr√©er le fichier **docker-compose.yml** :

```yaml
version: "3.9"

services:
  web:
    # 1) build = construction √† partir du Dockerfile local
    build: .

    # 2) image = nom/√©tiquette (tag) final de l'image construite
    image: demo/nginx-custom:1.0

    # Publication du service en local
    ports:
      - "8082:80"

    # Nom explicite du conteneur (optionnel mais pratique)
    container_name: nginx_build_and_image_example

    # Variable d'environnement illustrative (optionnelle)
    environment:
      - NGINX_ENV=demo-build-image
```

## 4) Ex√©cution & v√©rifications

Construire et d√©marrer :

```bash
docker compose up -d --build
```

V√©rifier l‚Äôimage construite et **tagu√©e** :

```bash
docker images | grep -E 'demo/nginx-custom|REPOSITORY|TAG'
```

R√©sultat attendu (exemple) :

```
REPOSITORY            TAG       IMAGE ID       CREATED          SIZE
demo/nginx-custom     1.0       a1b2c3d4e5f6   <il y a  X sec>  187MB
```

V√©rifier le conteneur :

```bash
docker compose ps
```

V√©rifier la page servie :

```bash
curl -s http://localhost:8082 | head -n 5
```

Vous devez voir le HTML mentionnant **image: demo/nginx-custom:1.0**.

### Rebuild apr√®s modification (cache)

Modifiez le `<h1>` dans `index.html`, puis :

```bash
docker compose build
docker compose up -d
curl -s http://localhost:8082 | head -n 5
```

Vous constatez la **mise √† jour**.

## 5) Nettoyage / rollback

```bash
docker compose down
docker rmi demo/nginx-custom:1.0 || true
```

## 6) Astuces & pi√®ges

- `build` **+** `image` dans le **m√™me service** = **valide** : Compose **construit** puis **tague** l‚Äôimage.

- Pensez √† `.dockerignore` pour acc√©l√©rer les builds.

- Pr√©f√©rez des tags **versionn√©s** (√©vitez `latest`) pour la tra√ßabilit√©.

- Contr√¥lez le **contexte** (`build: .`) : s‚Äôil est trop large, le build sera lent.

- Publication √©ventuelle : `docker login` puis `docker push demo/nginx-custom:1.0`.

---

# üßë‚Äçüè´ Atelier 2: Comprendre entrypoint et command dans Docker Compose

## 1. üéØ Contexte & Objectif

L‚Äôobjectif de cet atelier est de **comprendre la diff√©rence entre `entrypoint` et `command`** dans Docker Compose et d‚Äôexp√©rimenter leur comportement sur un conteneur simple.

Nous allons :

- Cr√©er une image √† partir d‚Äôun `Dockerfile` qui d√©finit un **ENTRYPOINT** et un **CMD**.

- Modifier ce comportement via `docker-compose.yml` √† l‚Äôaide des cl√©s `entrypoint` et `command`.

- Observer les effets sur l‚Äôex√©cution du conteneur.

---

## 2. üß∞ Pr√©paration de l‚Äôenvironnement

Cr√©er le r√©pertoire de travail :

```bash
mkdir -p ~/atelier-entrypoint-command
cd ~/atelier-entrypoint-command
```

---

## 3. ‚öôÔ∏è √âtape 1 ‚Äì Cr√©er une image avec ENTRYPOINT et CMD

Cr√©er le fichier **Dockerfile** :

```bash
FROM debian:stable-slim

# Installer un petit utilitaire (ping)
RUN apt update && apt install -y iputils-ping && apt clean

# D√©finir le point d'entr√©e et la commande par d√©faut
ENTRYPOINT ["ping"]
CMD ["127.0.0.1"]
```

### Explication :

- `ENTRYPOINT ["ping"]` ‚Üí d√©finit le programme **ex√©cutable principal** du conteneur.

- `CMD ["127.0.0.1"]` ‚Üí fournit **les arguments par d√©faut** √† ce programme.  
  ‚Üí donc par d√©faut, le conteneur ex√©cutera :
  
  ```bash
  ping 127.0.0.1
  ```

Construire l‚Äôimage :

```bash
docker build -t ping-demo .
```

Tester directement :

```bash
docker run --rm ping-demo -c 2
```

> ‚úÖ R√©sultat attendu :  
> Deux requ√™tes ICMP vers `127.0.0.1` s‚Äôaffichent.

---

## 4. ‚öôÔ∏è √âtape 2 ‚Äì Utilisation de command: dans Docker Compose

Cr√©er le fichier **docker-compose-command.yml** :

```yaml
version: "3.9"

services:
  ping_service:
    image: ping-demo
    command: ["-c", "3", "8.8.8.8"]   # Remplace uniquement CMD, pas ENTRYPOINT
```

### Explication :

- `command:` **remplace le CMD** d√©fini dans le Dockerfile, **mais garde l‚ÄôENTRYPOINT**.

- Donc ici le conteneur ex√©cutera :
  
  ```bash
  ping -c 3 8.8.8.8
  ```

D√©marrage du service :

```bash
docker compose -f docker-compose-command.yml up
```

> ‚úÖ R√©sultat attendu :  
> Le conteneur ping trois fois l‚Äôadresse `8.8.8.8` (Google DNS).

Arr√™ter le service :

```bash
docker compose -f docker-compose-command.yml down
```

---

## 5. ‚öôÔ∏è √âtape 3 ‚Äì Utilisation de `entrypoint:` dans Docker Compose

Cr√©er le fichier **docker-compose-entrypoint.yml** :

```yaml
version: "3.9"

services:
  ping_service:
    image: ping-demo
    entrypoint: ["echo", "Le point d'entr√©e a √©t√© modifi√© !"]
```

### Explication :

- `entrypoint:` **remplace compl√®tement** l‚ÄôENTRYPOINT du Dockerfile.

- `command:` (ou le CMD d‚Äôorigine) devient alors **les arguments pass√©s** √† cette nouvelle commande.

- Dans ce cas, Docker ex√©cutera :
  
  ```bash
  echo Le point d'entr√©e a √©t√© modifi√© !
  ```

D√©marrage :

```bash
docker compose -f docker-compose-entrypoint.yml up
```

> ‚úÖ R√©sultat attendu :  
> Le conteneur affiche simplement :
> 
> ```
> Le point d'entr√©e a √©t√© modifi√© !
> ```
> 
> puis s‚Äôarr√™te.

---

## 6. ‚öôÔ∏è √âtape 4 ‚Äì Combiner entrypoint: et command: dans Docker Compose

Cr√©er le fichier **docker-compose-both.yml** :

```yaml
version: "3.9"

services:
  ping_service:
    image: ping-demo
    entrypoint: ["ping"]
    command: ["-c", "2", "1.1.1.1"]
```

### Explication :

- Ici, **les deux** sont red√©finis.

- `entrypoint:` ‚Üí red√©finit le binaire √† ex√©cuter.

- `command:` ‚Üí red√©finit ses arguments.

R√©sultat final ex√©cut√© :

```bash
ping -c 2 1.1.1.1
```

D√©marrage :

```bash
docker compose -f docker-compose-both.yml up
```

> ‚úÖ R√©sultat attendu :  
> Deux paquets ICMP envoy√©s vers `1.1.1.1`.

---

## 7. üßπ Nettoyage / Rollback

Arr√™ter et supprimer tous les services et images :

```bash
docker compose -f docker-compose-command.yml down
docker compose -f docker-compose-entrypoint.yml down
docker compose -f docker-compose-both.yml down
docker rmi ping-demo
```

## 8. üí° Astuces & Pi√®ges

- ‚ö†Ô∏è `entrypoint` **remplace totalement** l‚ÄôENTRYPOINT du Dockerfile ‚Üí il ne conserve pas l‚Äôancien.

- ‚öôÔ∏è `command` **remplace uniquement CMD** ‚Üí il s‚Äôajoute √† l‚ÄôENTRYPOINT existant.

- üß© Si vous utilisez `entrypoint` dans Compose, v√©rifiez bien les arguments attendus : sinon le conteneur peut se bloquer ou quitter imm√©diatement.

- üîé Pour diagnostiquer le comportement r√©el :
  
  ```bash
  docker inspect <nom_du_conteneur> | grep -A 2 Cmd
  ```

# Atelier 3 : Utiliser entrypoint pour lancer un script de d√©marrage avant l‚Äôapplication (Docker Compose)

## 1) Contexte & objectif

Mettre en place un **hook de d√©marrage** via `entrypoint` qui ex√©cute un **script Bash** (pr√©-checks, logs, g√©n√©ration d‚Äôartifacts) avant de lancer l‚Äôapplication. Comprendre :

- `entrypoint` = lance votre script, puis passe la main √† l‚Äôapp.

- `command` (Compose) = remplace le `CMD` (arguments/commande de l‚Äôapp), **sans toucher** √† l‚Äô`entrypoint`.

## 2) Pr√©paration de l‚Äôenvironnement

Ex√©cuter sur Debian/Ubuntu.

```bash
mkdir -p ~/atelier-entrypoint-startup && cd ~/atelier-entrypoint-startup
```

## 3) Cr√©ation des fichiers (application Flask + script d‚Äôentr√©e)

Cr√©er le fichier **Dockerfile** :

```bash
FROM python:3.12-slim
# Dossier de travail
WORKDIR /app
# Copier sources
COPY app.py /app/app.py
COPY entrypoint.sh /app/entrypoint.sh
# D√©pendance minimale pour la d√©mo
RUN pip install --no-cache-dir Flask
# Rendre ex√©cutable l‚Äôentrypoint
RUN chmod +x /app/entrypoint.sh
# D√©finir ENTRYPOINT (hook) et CMD (commande par d√©faut de l‚Äôapp)
ENTRYPOINT ["/app/entrypoint.sh"]
CMD ["python", "app.py"]
```

Cr√©er le fichier **entrypoint.sh** :

```bash
#!/usr/bin/env bash
# Script d‚Äôentr√©e : pr√©pare l‚Äôenvironnement puis lance l‚Äôapp
set -euo pipefail  # exit on error, undefined var, and pipefail pour fiabilit√©

# 1) Journalisation de d√©marrage
echo "[ENTRYPOINT] D√©marrage du conteneur √† $(date '+%F %T')"

# 2) Lire variables d‚Äôenvironnement (avec valeurs par d√©faut)
APP_MESSAGE="${APP_MESSAGE:-Bonjour depuis Flask via ENTRYPOINT !}"
APP_HOST="${APP_HOST:-0.0.0.0}"
APP_PORT="${APP_PORT:-8000}"
echo "[ENTRYPOINT] Variables: APP_MESSAGE='${APP_MESSAGE}', APP_HOST='${APP_HOST}', APP_PORT='${APP_PORT}'"

# 3) G√©n√©rer un petit artifact prouvant le passage du hook
BOOT_DIR="/app/boot-artifacts"
mkdir -p "${BOOT_DIR}"
echo "Boot OK √† $(date '+%F %T')" > "${BOOT_DIR}/startup.ok"
echo "[ENTRYPOINT] Artifact g√©n√©r√©: ${BOOT_DIR}/startup.ok"

# 4) (Optionnel) Attendre un service externe (DB, API‚Ä¶) ‚Äì exemple d√©sactiv√©
# sleep 0.5

# 5) Exporter pour l‚Äôapp
export APP_MESSAGE APP_HOST APP_PORT

# 6) Lancer l‚Äôapplication (remplace le PID 1) en transmettant la commande/arguments
echo "[ENTRYPOINT] Lancement de l'application: $*"
exec "$@"
```

Cr√©er le fichier **app.py** :

```bash
from flask import Flask
import os

app = Flask(__name__)

@app.get("/")
def hello():
    # Message inject√© via variables d'environnement (setup par l'entrypoint)
    message = os.getenv("APP_MESSAGE", "Bonjour !")
    return f"<h1>{message}</h1>"

if __name__ == "__main__":
    host = os.getenv("APP_HOST", "0.0.0.0")
    port = int(os.getenv("APP_PORT", "8000"))
    app.run(host=host, port=port, debug=False)
```

## 4) Fichier Docker Compose (avec entrypoint + command)

Cr√©er le fichier **docker-compose.yml** :

```bash
version: "3.9"

services:
  web:
    build: .
    # entrypoint d√©j√† pr√©sent dans l'image -> on ne le red√©finit pas ici
    command: ["python", "app.py"]    # remplace le CMD du Dockerfile si d√©sir√©
    environment:
      - APP_MESSAGE=Salut depuis Compose (CMD par d√©faut)
      - APP_HOST=0.0.0.0
      - APP_PORT=8080
    ports:
      - "8080:8080"
    # volumes:
    #   - ./artifacts:/app/boot-artifacts  # d√©commentez pour observer startup.ok c√¥t√© h√¥te
```

## 5) Ex√©cution pas √† pas

```bash
docker compose up -d --build   # construit l'image et d√©marre le service
docker compose logs -f web     # observe les logs : [ENTRYPOINT] puis Flask
```

V√©rification HTTP :

```bash
curl -s http://localhost:8080
# Attendu : <h1>Salut depuis Compose (CMD par d√©faut)</h1>
```

## 6) Variation ‚Äî remplacer uniquement la commande (ENTRYPOINT inchang√©)

Sans toucher au fichier, lancez avec d‚Äôautres param√®tres :

```bash
docker compose run --rm -p -d 8082:8081 \
  -e APP_MESSAGE="Message dynamique via run" \
  -e APP_PORT=8082 \
  web python app.py

curl -s http://localhost:8082
# Attendu : <h1>Message dynamique via run</h1>
```

## 7) Nettoyage / rollback

```bash
docker compose down -v
docker image prune -f
```

## 8) Astuces & pi√®ges

- Utilisez **`exec "$@"`** dans l‚Äôentrypoint pour transmettre correctement les signaux au process app (PID 1).

- L‚Äô**entrypoint ne doit pas bloquer** : pr√©parez, loggez, puis **remettez la main** √† l‚Äôapp.

- **`entrypoint` remplace l‚ÄôENTRYPOINT de l‚Äôimage** si red√©fini c√¥t√© Compose ; **`command` remplace le CMD**.

- Diagnostic rapide :
  
  ```bash
  docker compose ps
  docker inspect $(docker compose ps -q web) | grep -A2 -E '"Entrypoint"|"Cmd"'
  ```
