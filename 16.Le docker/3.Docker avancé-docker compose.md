excellent 👌 — on entre maintenant dans la **Partie III : Docker Compose**, cœur pratique de l’**Atelier 11 – Docker avancé**.  
cette section va montrer **deux cas concrets** :

- 🧱 **Cas 1 :** usage d’une **image standard** (Nginx officiel) ;

- 🧰 **Cas 2 :** usage d’une **image personnalisée construite via Dockerfile** (application Flask).

chaque cas est complet : création de fichiers, explications, test, et nettoyage.

---

## Déploiement multi-conteneurs automatisé

---

## 🎯 Objectif

Apprendre à :

- décrire un déploiement dans un fichier `compose.yaml`,

- lancer, arrêter et inspecter une stack complète avec `docker compose`,

- différencier les notions : *image standard* vs *image personnalisée (build)*.

---

## 🧰 Pré-requis

- Docker Engine ≥ 24

- Plugin **Docker Compose v2** (inclus nativement)

- Répertoires de travail distincts :
  
  - `~/compose_nginx/`
  
  - `~/compose_flask/`

---

## 🪜 Cas 1 : Image standard — Nginx officiel

### 1️⃣ Préparer l’arborescence

```bash
mkdir -p ~/compose_nginx/html && cd ~/compose_nginx
```

Créer le fichier **`html/index.html`** :

```html
<!DOCTYPE html>
<html lang="fr">
<head><meta charset="UTF-8"><title>Docker Compose Nginx</title></head>
<body>
  <h2>✅ Nginx standard déployé via Docker Compose</h2>
</body>
</html>
```

Créer le fichier **`compose.yaml`** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:latest
    container_name: web_nginx
    ports:
      - "8080:80"
    volumes:
      - ./html:/usr/share/nginx/html:ro
```

---

### 2️⃣ Lancer la stack

```bash
docker compose up -d
```

Vérifier :

```bash
docker ps
```

et tester dans le navigateur :

```
http://localhost:8080
```

Résultat attendu : la page *“✅ Nginx standard…”* s’affiche.

---

### 3️⃣ Analyse rapide

- `image:` → on utilise directement l’image `nginx:latest`.

- `ports:` → mappe 8080 (local) → 80 (conteneur).

- `volumes:` → monte le dossier `html` local dans Nginx.

---

### 4️⃣ Nettoyage du cas 1

```bash
docker compose down
docker volume prune -f
```

---

## 🪜 Cas 2 : Image personnalisée — Application Flask

### 1️⃣ Préparer le projet

```bash
mkdir -p ~/compose_flask && cd ~/compose_flask
```

Créer le fichier **`app.py`** :

```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
    return "<h2>🚀 Application Flask déployée via Docker Compose (image custom)</h2>"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

Créer le fichier **`requirements.txt`** :

```
flask==3.0.2
```

Créer le fichier **`Dockerfile`** :

```dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]
```

---

### 2️⃣ Créer le fichier **`compose.yaml`**

```yaml
version: "3.9"

services:
  flaskapp:
    build: .
    container_name: flask_compose
    ports:
      - "5000:5000"
    environment:
      - FLASK_ENV=production
```

---

### 3️⃣ Construire et exécuter

```bash
docker compose up -d --build
```

Vérifier :

```bash
docker ps
curl http://localhost:5000
```

Résultat attendu :

```
🚀 Application Flask déployée via Docker Compose (image custom)
```

---

### 4️⃣ Observation

- `build: .` → Compose construit l’image à partir du `Dockerfile` local.

- `environment:` → injecte les variables dans le conteneur.

- `ports:` → rend l’application accessible sur le port 5000.

- `depends_on:` (non utilisé ici) permettrait de gérer des dépendances (ex. DB).

---

### 5️⃣ Nettoyage du cas 2

```bash
docker compose down
docker image prune -f
```

---

## ✅ Résumé pédagogique

| Élément       | Cas 1 (Nginx)                | Cas 2 (Flask)                |
| ------------- | ---------------------------- | ---------------------------- |
| Type d’image  | Standard                     | Personnalisée (Dockerfile)   |
| Directive clé | `image:`                     | `build:`                     |
| Ports exposés | 8080 → 80                    | 5000 → 5000                  |
| Objectif      | Servir un contenu statique   | Exécuter une app Python      |
| Vérif         | `curl http://localhost:8080` | `curl http://localhost:5000` |

---

## bonnes pratiques Docker Compose



## 🎯 Objectif

À la fin de cette section, le participant saura :

- nettoyer proprement tous les conteneurs, images, volumes et réseaux créés par Compose,

- gérer les réseaux et volumes nommés pour des stacks persistantes,

- comprendre les mécanismes `depends_on`, `restart`, `environment`,

- suivre de bonnes pratiques de maintenance et de debug.

---

## 🪜 Étape 1 — Visualiser les stacks actives

Lister toutes les stacks Compose :

```bash
docker compose ls
```

Lister tous les conteneurs actifs :

```bash
docker ps -a
```

Lister les images locales :

```bash
docker images
```

Lister réseaux & volumes :

```bash
docker network ls
docker volume ls
```

> 🧠 *Astuce :* chaque projet Compose crée **son propre réseau isolé** nommé `<dossier>_default` et parfois des volumes nommés si spécifiés.

---

## 🪜 Étape 2 — Nettoyage standard d’un projet Compose

Depuis le dossier du projet (`~/compose_nginx` ou `~/compose_flask`) :

```bash
docker compose down
```

> Par défaut :
> 
> - supprime les conteneurs liés,
> 
> - mais garde les images et volumes.

Si tu veux tout supprimer (conteneurs + volumes + réseaux + images orphelines) :

```bash
docker compose down --volumes --rmi all
```

---

## 🪜 Étape 3 — Nettoyage global de l’environnement Docker

Pour un environnement propre avant un autre atelier :

```bash
docker container prune -f
docker image prune -a -f
docker volume prune -f
docker network prune -f
docker system prune -a -f
```

> ⚠️ `system prune -a` supprime *toutes* les images non utilisées par des conteneurs — idéal pour un environnement de formation mais à éviter en production.

---

## 🪜 Étape 4 — Bonnes pratiques `docker compose`

### 4.1 Structurer un projet Compose

```
myapp/
├── compose.yaml
├── Dockerfile
├── app/
│   └── ...
└── data/
```

> - Place toujours `compose.yaml` à la racine.
> 
> - Ne mets pas de fichiers secrets dans le dossier build.
> 
> - Utilise `.dockerignore` pour exclure ce qui n’est pas nécessaire.

---

### 4.2 Définir un réseau dédié (bon isolement)

Créer le fichier **`compose.yaml`** :

```yaml
version: "3.9"

networks:
  backend_net:

services:
  db:
    image: mariadb:11
    environment:
      - MYSQL_ROOT_PASSWORD=admin
    networks:
      - backend_net

  app:
    build: .
    depends_on:
      - db
    networks:
      - backend_net
```

> 🔹 `networks:` permet d’éviter les interférences avec d’autres stacks Compose.  
> 🔹 `depends_on:` garantit que `db` démarre avant `app`.

---

### 4.3 Utiliser des volumes nommés pour la persistance

Créer le fichier **`compose.yaml`** :

```yaml
version: "3.9"

volumes:
  db_data:

services:
  mariadb:
    image: mariadb:11
    environment:
      - MYSQL_ROOT_PASSWORD=admin
    volumes:
      - db_data:/var/lib/mysql
    ports:
      - "3306:3306"
```

> Le volume `db_data` conserve les données même après un `docker compose down`.

Vérifier :

```bash
docker volume inspect db_data
```

---

### 4.4 Ajouter une politique de redémarrage

```yaml
services:
  web:
    image: nginx
    restart: always
```

> Options disponibles :
> 
> - `no` (par défaut),
> 
> - `always`,
> 
> - `on-failure`,
> 
> - `unless-stopped`.

---

### 4.5 Gérer les variables d’environnement

Créer le fichier **`.env`** :

```
MYSQL_ROOT_PASSWORD=admin
MYSQL_DATABASE=labdb
```

Puis dans `compose.yaml` :

```yaml
services:
  mariadb:
    image: mariadb
    env_file:
      - .env
```

> Avantage : séparer la configuration sensible du code versionné.  
> `.env` n’est pas transmis dans le conteneur, mais injecté comme variables d’environnement au lancement.

---

## 🪜 Étape 5 — Débogage Compose

Afficher les logs de tous les services :

```bash
docker compose logs -f
```

Inspecter un service :

```bash
docker compose exec web bash
```

Lister les conteneurs gérés par Compose :

```bash
docker compose ps
```

> 🧠 Bon réflexe : utiliser `docker compose logs -f` pour suivre un service lors du développement.

---

## 🧹 Étape 6 — Nettoyage final de tous les ateliers Docker

```bash
docker compose down --volumes --rmi all
docker system prune -a -f
```

excellent 👌 — c’est une idée très pédagogique : montrer **plusieurs variantes concrètes de fichiers `docker-compose.yaml`**, chacune illustrant un mot-clé ou une configuration typique différente.

je te propose ci-dessous **6 exemples progressifs**, chacun axé sur un **concept clé** du format Compose (`build`, `image`, `depends_on`, `volumes`, `networks`, `env_file`, `restart`, etc.)  
— tous testables indépendamment et réutilisables dans ton atelier principal.

---



## Exemples de docker compose

# 

## 🧱 Exemple 1 – Déploiement d’une image simple (cas minimal)

**Concepts illustrés :** `image`, `ports`, `container_name`

Créer le fichier **`compose.yaml`** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:latest
    container_name: nginx_simple
    ports:
      - "8080:80"
```

📘 **Explications :**

- `image:` → utilise directement une image existante du Docker Hub.

- `ports:` → mappe le port 8080 (machine hôte) vers le port 80 (conteneur).

- `container_name:` → remplace le nom aléatoire par un nom explicite.

---

## 🧱 Exemple 2 – Build local d’une image personnalisée

**Concepts illustrés :** `build`, `context`, `dockerfile`

Créer le fichier **`compose.yaml`** :

```yaml
version: "3.9"

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    image: myflask:1.0
    ports:
      - "5000:5000"
```

📘 **Explications :**

- `build:` → indique à Compose de construire l’image depuis le dossier courant (`context: .`).

- `dockerfile:` → permet de préciser un fichier Dockerfile spécifique.

- `image:` → nom optionnel attribué à l’image générée.

---

## 🧱 Exemple 3 – Multi-services avec dépendance

**Concepts illustrés :** `depends_on`, `environment`, `restart`

Créer le fichier **`compose.yaml`** :

```yaml
version: "3.9"

services:
  db:
    image: mariadb:11
    environment:
      - MYSQL_ROOT_PASSWORD=admin
      - MYSQL_DATABASE=labdb
    restart: always

  web:
    build: .
    ports:
      - "5000:5000"
    depends_on:
      - db
```

📘 **Explications :**

- `depends_on:` → garantit que `db` démarre avant `web`.

- `environment:` → définit les variables d’environnement passées au conteneur.

- `restart: always` → redémarre automatiquement le conteneur en cas d’arrêt.

---

## 🧱 Exemple 4 – Gestion de volumes (persistance)

**Concepts illustrés :** `volumes`, `volumes:` (racine)

Créer le fichier **`compose.yaml`** :

```yaml
version: "3.9"

volumes:
  db_data:

services:
  mariadb:
    image: mariadb:11
    environment:
      - MYSQL_ROOT_PASSWORD=admin
    volumes:
      - db_data:/var/lib/mysql
```

📘 **Explications :**

- la clé `volumes:` à la racine définit un volume nommé (`db_data`).

- la section `volumes:` du service monte ce volume dans le conteneur.

- le volume persiste même après suppression du conteneur (`docker volume ls`).

---

## 🧱 Exemple 5 – Réseaux personnalisés

**Concepts illustrés :** `networks`, `driver`, `networks:` (service)

Créer le fichier **`compose.yaml`** :

```yaml
version: "3.9"

networks:
  backend_net:
    driver: bridge

services:
  redis:
    image: redis:alpine
    networks:
      - backend_net

  web:
    build: .
    networks:
      - backend_net
```

📘 **Explications :**

- la clé `networks:` crée un réseau personnalisé (`backend_net`).

- chaque service qui s’y connecte peut communiquer via le **nom du service** comme DNS (`redis:6379`).

- utile pour isoler des environnements (par ex. `frontend_net`, `backend_net`).

---

## 🧱 Exemple 6 – Variables d’environnement externes

**Concepts illustrés :** `.env`, `env_file`, substitution `${VAR}`

Créer le fichier **`.env`** :

```
MYSQL_ROOT_PASSWORD=admin
MYSQL_DATABASE=labdb
PORT=3306
```

Créer le fichier **`compose.yaml`** :

```yaml
version: "3.9"

services:
  mariadb:
    image: mariadb:11
    env_file:
      - .env
    ports:
      - "${PORT}:3306"
```

📘 **Explications :**

- `env_file:` → charge toutes les variables du fichier `.env`.

- `${VAR}` → permet de substituer des variables dans le YAML (ports, volumes, etc.).

- pratique pour **séparer la configuration du code**.

---

## 🧱 Exemple 7 – Stack complète Nginx + Flask + Redis

**Concepts illustrés :** composition multi-services, réseau partagé, dépendances, build + image.

Créer le fichier **`compose.yaml`** :

```yaml
version: "3.9"

networks:
  app_net:

services:
  redis:
    image: redis:alpine
    networks:
      - app_net

  flaskapp:
    build: ./flask_app
    ports:
      - "5000:5000"
    depends_on:
      - redis
    networks:
      - app_net

  nginx:
    image: nginx:latest
    ports:
      - "8080:80"
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
    depends_on:
      - flaskapp
    networks:
      - app_net
```

📘 **Explications :**

- `flaskapp` communique avec `redis` via le réseau `app_net`.

- `nginx` fait office de reverse proxy frontal vers `flaskapp`.

- chaque service est isolé mais relié logiquement au sein du même réseau virtuel.

---

## 🧹 Nettoyage de tous les exemples

```bash
docker compose down --volumes --rmi all
docker system prune -f
```

---

## ✅ Résumé synthétique

| Mot-clé                      | Rôle                                 | Exemple clé       |
| ---------------------------- | ------------------------------------ | ----------------- |
| `image:`                     | utilise une image existante          | Ex. 1             |
| `build:`                     | construit une image locale           | Ex. 2             |
| `depends_on:`                | contrôle l’ordre de démarrage        | Ex. 3             |
| `environment:` / `env_file:` | variables d’environnement            | Ex. 3 / 6         |
| `volumes:`                   | persistance de données               | Ex. 4             |
| `networks:`                  | communication interne entre services | Ex. 5 / 7         |
| `restart:`                   | politique de redémarrage             | Ex. 3             |
| `ports:`                     | publication de port                  | tous les exemples |
| `${VAR}`                     | substitution dynamique               | Ex. 6             |


