# ðŸ§± Docker avancÃ©

## Partie I : Exploration complÃ¨te des mots-clÃ©s Dockerfile

---

## ðŸŽ¯ Objectif

Comprendre et expÃ©rimenter **chaque instruction Dockerfile fondamentale**, Ã  travers de petits exemples immÃ©diatement testables.  
Ã€ la fin de cette section, tu sauras :

- construire une image Ã  partir dâ€™une base (`FROM`) ;

- ajouter des mÃ©tadonnÃ©es (`LABEL`) et des variables (`ARG`, `ENV`) ;

- manipuler des fichiers avec `COPY` et `ADD` ;

- exÃ©cuter des commandes avec `RUN`, `CMD`, `ENTRYPOINT` ;

- dÃ©finir le contexte dâ€™exÃ©cution (`WORKDIR`, `USER`, `EXPOSE`, `VOLUME`).

---

## ðŸªœ Ã‰tape 1 : `FROM` et `LABEL`

CrÃ©er le fichier **`Dockerfile`** :

```dockerfile
# Base minimale : Ubuntu
FROM ubuntu:latest

# MÃ©tadonnÃ©es pour identifier lâ€™image
LABEL maintainer="formateur@lab"
LABEL version="1.0"
LABEL description="Image Ubuntu de dÃ©monstration avec mÃ©tadonnÃ©es"
```

> ðŸ§  `LABEL` nâ€™affecte pas le comportement du conteneur ; il sert Ã  documenter ou automatiser (CI/CD, audit).

Construire et vÃ©rifier :

```bash
docker build -t demo-label .
docker inspect demo-label | grep -A3 Labels
```

---

## ðŸªœ Ã‰tape 2 : `ARG` et `ENV`

CrÃ©er le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest

# Variable utilisÃ©e seulement pendant le build
ARG APP_VERSION=1.0

# Variable disponible Ã  lâ€™exÃ©cution
ENV APP_NAME="DemoApp" \
    APP_VERSION=${APP_VERSION}

RUN echo "Building ${APP_NAME} v${APP_VERSION}"

CMD ["bash", "-c", "echo 'Running $APP_NAME version $APP_VERSION'"]
```

Construire et exÃ©cuter :

```bash
docker build --build-arg APP_VERSION=2.5 -t demo-env .
docker run demo-env
```

> ðŸ”¹ `ARG` : uniquement durant le *build*.  
> ðŸ”¹ `ENV` : persiste dans le conteneur.

---

## ðŸªœ Ã‰tape 3 : `WORKDIR` et `RUN`

CrÃ©er le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
WORKDIR /app
RUN echo "Fichier crÃ©Ã© depuis le Dockerfile" > fichier.txt
CMD ["ls", "-l"]
```

> `WORKDIR` crÃ©e le dossier sâ€™il nâ€™existe pas et y place le contexte de travail pour les instructions suivantes.

Tester :

```bash
docker build -t demo-workdir .
docker run demo-workdir
```

---

## ðŸªœ Ã‰tape 4 : `COPY` vs `ADD`

**But :** comprendre quand utiliser lâ€™un ou lâ€™autre.

### 4.1 Exemple : `COPY`

CrÃ©er le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
WORKDIR /data
COPY fichier_local.txt /data/
CMD ["cat", "/data/fichier_local.txt"]
```

CrÃ©er le fichier **`fichier_local.txt`** :

```bash
echo "Hello from COPY!" > fichier_local.txt
```

Build & run :

```bash
docker build -t demo-copy .
docker run demo-copy
```

### 4.2 Exemple : `ADD` avec archive compressÃ©e

CrÃ©er le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
WORKDIR /app
ADD archive.tar.gz /app/
CMD ["ls", "-l", "/app"]
```

CrÃ©er une petite archive pour test :

```bash
tar czf archive.tar.gz /etc/hostname
```

Build & run :

```bash
docker build -t demo-add .
docker run demo-add
```

> ðŸ’¡ `ADD` sait **dÃ©compresser automatiquement** les fichiers `.tar.gz` et **tÃ©lÃ©charger des URL distantes** ;  
> `COPY` est **plus sÃ»r** â†’ utiliser `ADD` seulement si tu veux la dÃ©compression ou le fetch HTTP.

---

## ðŸªœ Ã‰tape 5 : `EXPOSE`, `VOLUME`, `USER`

CrÃ©er le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest

RUN useradd -m customuser
USER customuser

WORKDIR /data
VOLUME /data
EXPOSE 8080

CMD ["bash", "-c", "echo 'Utilisateur actuel : $(whoami)'; sleep 10"]
```

Build & run :

```bash
docker build -t demo-user .
docker run -it demo-user
```

> ðŸ”¹ `USER` dÃ©finit lâ€™utilisateur dâ€™exÃ©cution.  
> ðŸ”¹ `VOLUME` dÃ©clare un point de persistance (montable).  
> ðŸ”¹ `EXPOSE` documente un port (nâ€™ouvre rien, câ€™est informatif).

---

## ðŸªœ Ã‰tape 6 : `RUN` vs `ENTRYPOINT`

CrÃ©er le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
RUN echo "ExÃ©cution pendant le build (image crÃ©Ã©e)"
ENTRYPOINT ["echo", "ExÃ©cution au lancement du conteneur â†’"]
```

Build & run :

```bash
docker build -t demo-run-entrypoint .
docker run demo-run-entrypoint
```

> ðŸ§© **RUN** : pendant la construction â†’ modifie lâ€™image.  
> **ENTRYPOINT** : pendant lâ€™exÃ©cution â†’ commande principale du conteneur.

---

## ðŸªœ Ã‰tape 7 : `ENTRYPOINT` vs `CMD`

### 7.1 Cas : combinaison

CrÃ©er le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
ENTRYPOINT ["echo", "Hello"]
CMD ["World"]
```

Tester :

```bash
docker build -t demo-entry-cmd .
docker run demo-entry-cmd
docker run demo-entry-cmd Bechir
```

RÃ©sultats :

```
Hello World
Hello Bechir
```

### 7.2 Cas : CMD seul

CrÃ©er le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
CMD ["echo", "Hello", "World"]
```

Tester :

```bash
docker build -t demo-cmd .
docker run demo-cmd
docker run demo-cmd Bechir
```

> Le second Ã©choue car `CMD` est **Ã©crasÃ© entiÃ¨rement**.  
> Avec `ENTRYPOINT`, on peut **ajouter des arguments** au lieu dâ€™Ã©craser.

ðŸ§  **RÃ©capitulatif rapide :**

| Directive  | ExÃ©cutÃ©e quand ?  | Peut Ãªtre Ã©crasÃ©e ?        | Usage typique                       |
| ---------- | ----------------- | -------------------------- | ----------------------------------- |
| RUN        | Ã€ la construction | Non                        | Installer packages, copier fichiers |
| CMD        | Au lancement      | Oui (remplaÃ§able)          | Commande par dÃ©faut                 |
| ENTRYPOINT | Au lancement      | Non (arguments ajoutables) | Comportement â€œfixeâ€ du conteneur    |

---

## ðŸ§¹ Nettoyage

```bash
docker image prune -f
docker container prune -f
docker volume prune -f
```

# docker init

---

## ðŸŽ¯ Objectif

DÃ©couvrir et utiliser la nouvelle commande **`docker init`** (introduite dans Docker 25.x),  
qui permet de **gÃ©nÃ©rer automatiquement un Dockerfile, un fichier `.dockerignore`, et un `compose.yaml`** Ã  partir dâ€™un projet existant.

Lâ€™atelier montre :

1. La prÃ©paration dâ€™une petite application web locale (Python/Flask).

2. Lâ€™exÃ©cution interactive de `docker init`.

3. Le test et la vÃ©rification de lâ€™image gÃ©nÃ©rÃ©e.

---

## ðŸ§° PrÃ©-requis

- Docker â‰¥ 25.0

- Python 3 installÃ© (pour lâ€™application exemple)

- AccÃ¨s sudo

---

## ðŸªœ Ã‰tape 1 â€” PrÃ©paration de lâ€™application

Nous allons crÃ©er une petite application **Flask** minimaliste.

CrÃ©er le dossier :

```bash
mkdir ~/demo_docker_init && cd ~/demo_docker_init
```

CrÃ©er le fichier **`app.py`** :

```python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def index():
    return "âœ… Hello from Docker Init!"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

CrÃ©er le fichier **`requirements.txt`** :

```
flask==3.0.2
```

Tester localement (optionnel) :

```bash
pip install -r requirements.txt
python app.py
# â†’ accÃ©der Ã  http://127.0.0.1:5000
```

---

## ðŸªœ Ã‰tape 2 â€” Lancer lâ€™assistant `docker init`

### 2.1 ExÃ©cution

Depuis le rÃ©pertoire de ton application :

```bash
docker init
```

### 2.2 Dialogue interactif typique

Lâ€™assistant va poser plusieurs questions :

```
? What application platform does your project use? 
> Python

? What version of Python do you want to use?
> 3.11

? What port does your application listen on?
> 5000

? What is the command to run your app?
> python app.py

? What do you want to name your service?
> flask-demo
```

Docker va gÃ©nÃ©rer automatiquement :

```
Dockerfile
.dockerignore
compose.yaml
```

---

## ðŸªœ Ã‰tape 3 â€” Analyse du Dockerfile gÃ©nÃ©rÃ©

Ouvre le fichier **`Dockerfile`** :

```bash
cat Dockerfile
```

Exemple gÃ©nÃ©rÃ© :

```dockerfile
# syntax=docker/dockerfile:1

FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt

COPY . .
EXPOSE 5000

CMD ["python", "app.py"]
```

> ðŸ§  Remarques :
> 
> - `COPY` et `RUN` sont gÃ©nÃ©rÃ©s dans le bon ordre (optimisation du cache).
> 
> - `EXPOSE` documente le port dâ€™Ã©coute.
> 
> - `CMD` dÃ©finit la commande par dÃ©faut.

---

## ðŸªœ Ã‰tape 4 â€” Construction et exÃ©cution du conteneur

Construire lâ€™image :

```bash
docker build -t demo-init:latest .
```

ExÃ©cuter :

```bash
docker run -d -p 5000:5000 --name flask-demo demo-init
```

Tester :

```bash
curl http://localhost:5000
```

RÃ©sultat attendu :

```
âœ… Hello from Docker Init!
```

---

## ðŸªœ Ã‰tape 5 â€” Utiliser le fichier `compose.yaml` gÃ©nÃ©rÃ©

Inspecte le fichier **`compose.yaml`** :

```bash
cat compose.yaml
```

Exemple typique :

```yaml
services:
  flask-demo:
    build: .
    ports:
      - 5000:5000
```

ExÃ©cution via Compose :

```bash
docker compose up -d
```

VÃ©rifie :

```bash
docker ps
curl http://localhost:5000
```

> ðŸ§© Avantage : `docker init` fournit directement une structure **multi-service prÃªte pour Compose**.

---

## ðŸªœ Ã‰tape 6 â€” VÃ©rification et exploration

Inspecter le conteneur :

```bash
docker inspect flask-demo
```

Voir les logs :

```bash
docker logs -f flask-demo
```

Ouvrir un shell Ã  lâ€™intÃ©rieur :

```bash
docker exec -it flask-demo bash
```

---

## ðŸ§¹ Ã‰tape 7 â€” Nettoyage du lab

```bash
docker compose down
docker rm -f flask-demo
docker rmi demo-init
docker system prune -f
```

---

## âœ… RÃ©sumÃ© pÃ©dagogique

| Ã‰lÃ©ment               | Fonction                                                       |
| --------------------- | -------------------------------------------------------------- |
| `docker init`         | GÃ©nÃ¨re automatiquement la configuration Docker pour ton projet |
| `Dockerfile`          | DÃ©finit le build de ton application                            |
| `.dockerignore`       | Exclut les fichiers inutiles du contexte                       |
| `compose.yaml`        | DÃ©crit le dÃ©ploiement multi-service                            |
| `docker compose up`   | Lance le stack complet                                         |
| `docker system prune` | Nettoie ton environnement                                      |
