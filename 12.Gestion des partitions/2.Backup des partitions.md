# Atlier 3: Backup des partitions

## 📚 Sommaire

1. Contexte & objectif

2. Préparation de l’environnement *(10 min)*

3. Exercices + solutions pas à pas *(40 min)*

4. Vérifications et résultats attendus *(5 min)*

5. Nettoyage / rollback *(5 min)*

6. Astuces & pièges *(5 min)*

7. Bonus : alternatives et tests avancés *(10 min)*

8. Schéma visuel

9. Références

---

## 1️⃣ Contexte & objectif

Un administrateur doit effectuer une **sauvegarde complète de la partition `/home`** avant une mise à jour système critique.  
L’objectif est d’obtenir une image fiable qu’il pourra **restaurer intégralement** en cas de problème.

> 🎯 À la fin de cet atelier, vous saurez :
> 
> - Sauvegarder une partition avec `dd` (méthode brute).
> 
> - Sauvegarder plus efficacement avec `partclone`.
> 
> - Sauvegarder la table de partitions (`sfdisk`).
> 
> - Restaurer et vérifier l’intégrité.
> 
> - Tester le backup dans un environnement isolé.

⚠️ **Sécurité absolue** :

> - Ne jamais exécuter ces commandes sur la partition système `/`.
> 
> - Travailler sur une **VM de test** ou un **disque clone**.
> 
> - Toujours vérifier la destination avant d’écrire avec `dd`.

---

## 2️⃣ Préparation de l’environnement (≈ 10 min)

### 💾 Étape 1 – Identifier la partition

```bash
lsblk -f
```

**Exemple :**

```
NAME   FSTYPE LABEL UUID                                 MOUNTPOINTS
sda
├─sda1 ext4         84d7-25f1                             /
├─sda2 ext4         a9f2-99b3                             /home
└─sda3 swap         5a4f-ef11                             [SWAP]
sdb
```

👉 Nous allons sauvegarder `/dev/sda2` vers `/dev/sdb`.

### 💡 Simulation (mode loop file)

Si vous ne disposez pas d’un second disque, créez un **fichier simulant une partition** :

```bash
dd if=/dev/zero of=/tmp/loop_test.img bs=1M count=1024
mkfs.ext4 /tmp/loop_test.img
sudo mkdir /mnt/loop_test
sudo mount -o loop /tmp/loop_test.img /mnt/loop_test
```

---

## 3️⃣ Exercices et solutions pas à pas (≈ 40 min)

---

### 🧩 Exercice 1 – Sauvegarder la table de partitions

> Sauvegardez la structure du disque `/dev/sda` pour pouvoir la restaurer en cas de corruption.

#### ✅ Solution

```bash
sudo sfdisk -d /dev/sda > /mnt/backup/sda_table_backup.sfdisk
ls -l /mnt/backup/sda_table_backup.sfdisk
```

💡 Restauration possible :

```bash
sudo sfdisk /dev/sda < /mnt/backup/sda_table_backup.sfdisk
```

---

### 🧩 Exercice 2 – Sauvegarde brute avec `dd`

> Créez une image complète bit-à-bit de la partition `/dev/sda2`.

#### ✅ Solution

```bash
sudo dd if=/dev/sda2 of=/mnt/backup/sda2_backup.img bs=4M status=progress conv=fsync
```

**Explications :**  
`if` = source, `of` = destination, `bs` = taille bloc, `fsync` = écrit sur disque avant fin.

**Sortie typique :**

```
2147483648 bytes (2.1 GB) copied, 35 s, 61 MB/s
```

---

### 🧩 Exercice 3 – Sauvegarde optimisée avec `partclone`

> Évitez de copier les blocs vides pour gagner temps et espace.

#### ✅ Solution

Installation :

```bash
sudo apt install -y partclone
```

Sauvegarde :

```bash
sudo partclone.ext4 -c -s /dev/sda2 -o /mnt/backup/sda2_partclone.img
```

**Sortie :**

```
Partclone v0.3.23  EXTFS
Reading block 0...100% (OK)
Completed: 100.00%
```

💡 **Comparatif :**  
`ls -lh /mnt/backup/sda2_*.img`  
→ `partclone` réduit souvent la taille de 60 % par rapport à `dd`.

---

### 🧩 Exercice 4 – Vérification d’intégrité

> Comparez la source et l’image sauvegardée.

#### ✅ Solution

```bash
sudo md5sum /dev/sda2 | cut -d' ' -f1
sudo md5sum /mnt/backup/sda2_backup.img | cut -d' ' -f1
```

Les deux hash doivent être identiques.  
💡 Autre méthode :

```bash
sudo cmp -n 1048576 /dev/sda2 /mnt/backup/sda2_backup.img
```

→ Aucune sortie = aucune différence détectée.

---

### 🧩 Exercice 5 – Monter une image sauvegardée pour inspection

> Montez l’image pour vérifier le contenu sans restauration.

#### ✅ Solution

```bash
sudo mkdir -p /mnt/test_img
sudo mount -o loop /mnt/backup/sda2_backup.img /mnt/test_img
ls /mnt/test_img
```

✅ Vous accédez au contenu sauvegardé.  
Démontez ensuite :

```bash
sudo umount /mnt/test_img
```

---

### 🧩 Exercice 6 – Restauration d’une partition (méthode 1 : `dd`)

> Simulez une panne et restaurez `/dev/sda2` depuis le backup.

#### ✅ Solution

```bash
sudo dd if=/mnt/backup/sda2_backup.img of=/dev/sda2 bs=4M status=progress conv=fsync
sudo sfdisk /dev/sda < /mnt/backup/sda_table_backup.sfdisk
sudo partprobe
```

⚠️ Écrase complètement la partition existante : ne jamais exécuter en production.

---

### 🧩 Exercice 7 – Restauration (méthode 2 : `partclone`)

> Restaurer plus rapidement la même partition.

#### ✅ Solution

```bash
sudo partclone.ext4 -r -s /mnt/backup/sda2_partclone.img -o /dev/sda2
```

`-r` = *restore mode*.  
Beaucoup plus rapide que `dd` et copie uniquement les blocs utiles.

---

### 🧩 Exercice 8 – Validation finale

> Montez la partition restaurée et vérifiez le contenu.

#### ✅ Solution

```bash
sudo mkdir -p /mnt/restore_test
sudo mount /dev/sda2 /mnt/restore_test
ls /mnt/restore_test
sudo umount /mnt/restore_test
```

✅ Les données d’origine sont restaurées intactes.

---

## 4️⃣ Vérifications et résultats attendus (≈ 5 min)

| Étape             | Commande                                | Résultat           |
| ----------------- | --------------------------------------- | ------------------ |
| Table sauvegardée | `ls /mnt/backup/*.sfdisk`               | Présente           |
| Image brute       | `ls -lh /mnt/backup/sda2_backup.img`    | Taille ≈ partition |
| Image optimisée   | `ls -lh /mnt/backup/sda2_partclone.img` | Taille réduite     |
| Intégrité         | `md5sum`                                | Hash identiques    |
| Restauration      | `mount /dev/sda2 /mnt/restore_test`     | Données retrouvées |

---

## 5️⃣ Nettoyage / rollback (≈ 5 min)

```bash
sudo umount /mnt/backup /mnt/restore_test 2>/dev/null || true
sudo rm -f /mnt/backup/sda2_backup.img /mnt/backup/sda2_partclone.img /mnt/backup/sda_table_backup.sfdisk
sudo rm -rf /mnt/test_img /mnt/restore_test
```

---

## 6️⃣ Astuces & pièges (≈ 5 min)

| Problème                  | Cause                    | Solution                                    |
| ------------------------- | ------------------------ | ------------------------------------------- |
| `dd` trop lent            | Petit `bs`               | Utiliser `bs=4M` ou `8M`                    |
| Image trop volumineuse    | Copie bloc à bloc        | Utiliser `partclone`                        |
| Partition montée          | Risque d’incohérence     | Lancer `sync` ou travailler depuis Live CD  |
| Espace disque insuffisant | Destination trop petite  | Vérifier avec `df -h`                       |
| Mauvais périphérique      | Erreur d’écriture fatale | Toujours confirmer avec `lsblk` avant `of=` |

---

## 7️⃣ Bonus : alternatives & tests avancés (≈ 10 min)

### 🔸 Sauvegarde logique (alternative)

```bash
sudo rsync -aAXv /home/ /mnt/backup/home_rsync/
```

Copie fichier par fichier (permissions, ACL, liens) — utile pour restauration sélective.

### 🔸 Backup d’une partition LUKS (avancé)

```bash
sudo cryptsetup luksOpen /dev/sda4 securedata
sudo partclone.ext4 -c -s /dev/mapper/securedata -o /mnt/backup/securedata.img
sudo cryptsetup luksClose securedata
```

### 🔸 Montage d’une image loop

```bash
sudo mount -o loop,ro /mnt/backup/sda2_backup.img /mnt/test_img
```

Permet de **naviguer dans le backup** sans altérer les données.

---

## 8️⃣ Schéma visuel du processus

```mermaid
graph TD
A[Partition source /dev/sda2]:::blue -->|Sauvegarde brute| B[sda2_backup.img]:::gray
A -->|Sauvegarde optimisée| C[sda2_partclone.img]:::green
B -->|Restauration dd| D[/dev/sda2 restaurée]:::green
C -->|Restauration partclone -r| D
E[sfdisk table]:::orange -->|Structure restaurée| D
classDef blue fill:#cce5ff,stroke:#004085;
classDef green fill:#d4edda,stroke:#155724;
classDef gray fill:#e2e3e5,stroke:#383d41;
classDef orange fill:#fff3cd,stroke:#856404;
```

**Flux** : Source → Image → Restauration.

---

## 9️⃣ Références

- `man dd`

- `man partclone`

- `man sfdisk`

- [Debian Wiki – BackupAndRecovery](https://wiki.debian.org/BackupAndRecovery)


