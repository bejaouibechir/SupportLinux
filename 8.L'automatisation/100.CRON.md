# D√©mo 1 ‚Äî Comprendre le mecanisme

## Objectif

Montrer concr√®tement que :

- le **d√©mon cron tourne en continu** et **se r√©veille chaque minute**,

- il lit les **crontabs** et d√©clenche la commande planifi√©e,

- on peut **observer l‚Äôex√©cution** via un log utilisateur et via les **journaux syst√®me**.

---

## Pr√©-requis (Debian/Ubuntu)

```bash
# V√©rifier que le service cron est actif
sudo systemctl status cron --no-pager
# Si besoin :
# sudo systemctl enable --now cron
```

---

## √âtape A ‚Äî Pr√©parer une action observable

Un mini-script qui √©crit la date et l‚ÄôUID dans un log dans /tmp (pas d‚Äôattente longue).

**/usr/local/bin/cron_probe.sh**

```bash
#!/usr/bin/env bash
set -eu
echo "$(date +'%F %T') | UID=$UID | whoami=$(whoami)" 



```

2. Le rendre ex√©cutable
   
   
   
   
   ```bash
   sudo chmod +x /usr/local/bin/cron_probe.sh
   ```
   
   

> Pourquoi /usr/local/bin ? Pour √©viter les probl√®mes de PATH dans cron et utiliser un **chemin absolu** (bonne pratique).

---

## √âtape B ‚Äî Ajouter une crontab utilisateur ¬´ chaque minute ¬ª

On veut un effet quasi-imm√©diat (‚â§60 s) et sans e-mails.

```bash
# Ouvrir la crontab de l'utilisateur courant
crontab -e
```

Ajoutez ces trois lignes tout en haut (pour √©viter les mails et fixer le PATH), puis la t√¢che :

```
MAILTO=""
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

* * * * * /usr/local/bin/cron_probe.sh >>/tmp/cron_probe.log 2>&1
```

Enregistrez / quittez.

> Principe : **cron** scrute les **crontabs** et **d√©clenche √† la minute** exacte les commandes planifi√©es. Les crontabs utilisateur sont stock√©es sous **/var/spool/cron/** (selon distro), et la syntaxe est ¬´ 5 champs de temps + commande ¬ª.

---

## √âtape C ‚Äî Observer l‚Äôex√©cution (retour visible en < 60 s)

### 1) Journal applicatif (notre log)

```bash
# Ouvrir un suivi temps r√©el
tail -f /tmp/cron_probe.log
```

Attendez la prochaine minute : vous verrez appara√Ætre une ligne du type :

```
2025-09-21 20:xx:00 | UID=1000 | whoami=bechir
```

### 2) Journal syst√®me (activit√© du d√©mon cron)

Dans un autre terminal :

```bash
# Debian/Ubuntu : journald
sudo journalctl -u cron -f
# ou parfois via syslog :
# sudo tail -f /var/log/syslog | grep -i CRON
```

Vous verrez des entr√©es indiquant l‚Äôex√©cution planifi√©e √† chaque minute par le d√©mon.

> Ce que l‚Äôon vient d‚Äôobserver illustre le **principe de fonctionnement** : le **d√©mon cron tourne en continu, se r√©veille chaque minute, lit les entr√©es de crontab et ex√©cute la commande au cr√©neau pr√©vu**.

---

## √âtape D ‚Äî (Option) V√©rifier la crontab charg√©e

```bash
crontab -l
```

---

## Nettoyage

```bash
crontab -r                    # supprime la crontab utilisateur
sudo rm -f /usr/local/bin/cron_probe.sh /tmp/cron_probe.log
```





## √âtape A ‚Äî Crontab utilisateur

On veut que **l‚Äôutilisateur courant** journalise automatiquement la taille de son r√©pertoire `~/Documents` chaque minute.

```bash
# 1) Cr√©er un script
mkdir -p ~/bin
tee ~/bin/check_docs_size.sh >/dev/null <<'SH'
#!/usr/bin/env bash
du -sh ~/Documents 2>/dev/null | awk '{print strftime("%F %T"), $0}' >> ~/Documents/docs_size.log
SH

chmod +x ~/bin/check_docs_size.sh
```

Ajouter la t√¢che √† la crontab utilisateur :

```bash
crontab -e
```

```
MAILTO=""
* * * * * ~/bin/check_docs_size.sh
```

V√©rification apr√®s une minute :

```bash
tail -f ~/Documents/docs_size.log
```

üëâ R√©sultat attendu : une ligne ajout√©e toutes les minutes avec date + taille du r√©pertoire.

---

## √âtape B ‚Äî Crontab syst√®me (/etc/crontab)

On veut que **root** surveille l‚Äôespace disque global du serveur (via `df -h`) et logge cela dans `/var/log/disk_check.log`.

```bash
# 1) √âditer le fichier crontab syst√®me
sudo nano /etc/crontab
```

Ajouter une ligne (7 champs ‚Üí inclut l‚Äôutilisateur) :

```
* * * * * root df -h / >> /var/log/disk_check.log 2>&1
```

> Ici on utilise `root` explicitement car c‚Äôest une crontab syst√®me.

V√©rification apr√®s une minute :

```bash
sudo tail -f /var/log/disk_check.log
```

üëâ R√©sultat attendu : une nouvelle ligne du `df` toutes les minutes.

---

## √âtape C ‚Äî Diff√©rences observ√©es

- **Crontab utilisateur** : pas besoin de pr√©ciser l‚Äôutilisateur, chaque crontab est stock√©e sous `/var/spool/cron/username`.

- **Crontab syst√®me** : champ suppl√©mentaire (utilisateur) obligatoire ; utilis√©e pour les t√¢ches globales du syst√®me (/etc/crontab, /etc/cron.d/).

- **Contexte d‚Äôex√©cution** : la crontab utilisateur h√©rite du `$HOME` de l‚Äôutilisateur, alors que la crontab syst√®me h√©rite souvent d‚Äôun environnement minimal.

- **Observation** : logs s√©par√©s (dans le r√©pertoire utilisateur vs dans `/var/log`).

---

## √âtape D ‚Äî Nettoyage

```bash
crontab -r
sudo sed -i '/df -h \//d' /etc/crontab
rm -f ~/bin/check_docs_size.sh ~/Documents/docs_size.log
sudo rm -f /var/log/disk_check.log
```

---

## Points p√©dagogiques cl√©s

- **Crontabs utilisateurs** : fichiers texte propres √† chaque utilisateur (via `crontab -e`), stock√©s dans `/var/spool/cron/`.

- **Crontabs syst√®me** : g√©r√©s uniquement par root dans `/etc/crontab` ou `/etc/cron.d/*`, n√©cessitent un champ utilisateur suppl√©mentaire.

- **Usage typique** :
  
  - **Utilisateur** ‚Üí t√¢ches personnelles (ex : backup de Documents).
  
  - **Syst√®me** ‚Üí surveillance globale ou maintenance serveur.

# 

## 

## √âtape A ‚Äî Crontab utilisateur

**But** : journaliser automatiquement la taille du r√©pertoire `~/Documents` chaque minute.

### 1) Cr√©er un script

bash:

```bash
mkdir -p ~/bin
```

Cr√©er le fichier `~/bin/check_docs_size.sh` :  
bash:

```bash
#!/usr/bin/env bash
du -sh ~/Documents 2>/dev/null | awk '{print strftime("%F %T"), $0}' >> ~/Documents/docs_size.log
```

### 2) Rendre le script ex√©cutable

bash:

```bash
chmod +x ~/bin/check_docs_size.sh
```

### 3) Ajouter une t√¢che cron utilisateur

√âditer la crontab de l‚Äôutilisateur :  
bash:

```bash
crontab -e
```

Ajouter la ligne suivante :

```
MAILTO=""
* * * * * ~/bin/check_docs_size.sh
```

### 4) V√©rification

Apr√®s une minute :  
bash:

```bash
tail -f ~/Documents/docs_size.log
```

---

## √âtape B ‚Äî Crontab syst√®me

**But** : root surveille l‚Äôespace disque global et consigne le r√©sultat dans `/var/log/disk_check.log`.

### 1) √âditer la crontab syst√®me

bash:

```bash
sudo nano /etc/crontab
```

Ajouter la ligne suivante :

```
* * * * * root df -h / >> /var/log/disk_check.log 2>&1
```

### 2) V√©rification

Apr√®s une minute :  
bash:

```bash
sudo tail -f /var/log/disk_check.log
```

---

## √âtape C ‚Äî Diff√©rences observ√©es

- **Crontab utilisateur** ‚Üí ne pr√©cise pas l‚Äôutilisateur, chaque t√¢che appartient √† un compte.

- **Crontab syst√®me** ‚Üí champ suppl√©mentaire obligatoire pour indiquer l‚Äôutilisateur.

- **Stockage** :
  
  - Utilisateur ‚Üí `/var/spool/cron/<username>`
  
  - Syst√®me ‚Üí `/etc/crontab`, `/etc/cron.d/*`

- **Contexte d‚Äôex√©cution** : environnement diff√©rent (HOME utilisateur vs contexte root).

---

## √âtape D ‚Äî Nettoyage

bash:

```bash
crontab -r
sudo sed -i '/df -h \//d' /etc/crontab
rm -f ~/bin/check_docs_size.sh ~/Documents/docs_size.log
sudo rm -f /var/log/disk_check.log
```

Parfait. Je reprends enti√®rement la d√©mo ‚ÄúCrontabs utilisateurs et syst√®me‚Äù en respectant **votre style** (√©tapes s√©par√©es, cr√©ation de fichiers explicite, scripts comment√©s, astuces pratiques), avec un sc√©nario **r√©el** et un effet **quasi-instantan√©** (t√¢ches √† la minute).

# D√©mo 2 ‚Äî Crontabs utilisateurs et syst√®me

## Objectif r√©el

- C√¥t√© **utilisateur** : d√©tecter les gros fichiers qui ‚Äúgonflent‚Äù le $HOME (veille de capacit√© personnelle).

- C√¥t√© **syst√®me (root)** : surveiller l‚Äôespace disque et **journaliser une alerte** si un seuil est d√©pass√©.

- Montrer concr√®tement la diff√©rence **crontab utilisateur** vs **crontab syst√®me** et comment v√©rifier ce que cron ex√©cute.

---

## Pr√©-requis (Debian/Ubuntu)

bash:

```bash
# V√©rifier que le d√©mon cron tourne (sinon l‚Äôactiver)
sudo systemctl status cron --no-pager
# sudo systemctl enable --now cron
```

---

## Partie A ‚Äî Crontab **utilisateur** : d√©tecter les gros fichiers du $HOME

### 1) Cr√©er un dossier pour les scripts perso

bash:

```bash
mkdir -p ~/bin
```

### 2) Cr√©er le fichier `~/bin/large_files_watch.sh` (script comment√©)

bash:

```bash
#!/usr/bin/env bash
# Objet : lister les 5 plus gros fichiers (>100 Mo) dans $HOME, avec horodatage
# Pi√®ges vis√©s : PATH minimal dans cron ‚Üí on utilisera des chemins absolus
# Sortie : journalisation append dans ~/cron.d/home_watch.log (stdout) et ~/cron.d/home_watch.err (stderr)

set -Eeuo pipefail

# Variables
THRESHOLD_SIZE="+100M"                      # Seuil de taille
LOG_DIR="${HOME}/cron.d"
OK_LOG="${LOG_DIR}/home_watch.log"
ERR_LOG="${LOG_DIR}/home_watch.err"

# Pr√©pare le dossier de logs
mkdir -p "${LOG_DIR}"

# whoami pour lever toute ambigu√Øt√© d‚Äôutilisateur ‚Üí utile en crontab utilisateur
EXEC_USER="$(/usr/bin/id -u -n)"
NOW="$(/usr/bin/date +'%F %T')"

# Commandes avec chemins absolus (cron a un PATH minimal):contentReference[oaicite:1]{index=1}
/usr/bin/find "${HOME}" -xdev -type f -size "${THRESHOLD_SIZE}" -printf '%s %p\n' \
  2>>"${ERR_LOG}" \
| /usr/bin/sort -nr \
| /usr/bin/head -n 5 \
| /usr/bin/awk -v now="${NOW}" -v user="${EXEC_USER}" '{
    size=$1; $1=""; sub(/^ /,"");
    printf "%s | user=%s | size=%s bytes | file=%s\n", now, user, size, $0
  }' >> "${OK_LOG}"
```

### 3) Rendre le script ex√©cutable

bash:

```bash
chmod +x ~/bin/large_files_watch.sh
```

### 4) Tester **avant** d‚Äôattendre 1 minute (bon r√©flexe)

bash:

```bash
bash ~/bin/large_files_watch.sh
tail -n 5 ~/cron.d/home_watch.log
```

### 5) Ajouter la t√¢che dans la **crontab utilisateur**

bash:

```bash
crontab -e
```

Ajoutez (tout en haut pour l‚Äôenvironnement), puis la ligne planifi√©e :

```
MAILTO=""
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

* * * * * /home/$USER/bin/large_files_watch.sh >> /home/$USER/cron.d/home_watch.log 2>> /home/$USER/cron.d/home_watch.err
```

> Rappels issus du document : crontab utilisateur = 5 champs + commande, ex√©cut√©e si la machine est allum√©e au cr√©neau ; `MAILTO` contr√¥le l‚Äôenvoi de mails ; d√©finir un `PATH` explicite √©vite les surprises.

### 6) V√©rifier l‚Äôex√©cution (‚â§ 60 s)

bash:

```bash
tail -f ~/cron.d/home_watch.log
```

---

## Partie B ‚Äî Crontab **syst√®me** : garde disque (alerte quand / d√©passe 80%)

### 1) Cr√©er le fichier `/usr/local/sbin/disk_guard.sh` (script comment√©)

bash:

```bash
sudo bash -c 'cat > /usr/local/sbin/disk_guard.sh' << "EOF"
#!/usr/bin/env bash
# Objet : alerter si la partition / d√©passe 80% d‚Äôutilisation
# Diff√©rences "syst√®me" : s‚Äôex√©cute en contexte root via /etc/crontab (7 champs, champ utilisateur requis):contentReference[oaicite:3]{index=3}

set -Eeuo pipefail
THRESHOLD=80
LOG=/var/log/disk_guard.log

NOW="$(/usr/bin/date +'%F %T')"
WHO="$((/usr/bin/id -u -n) 2>/dev/null || echo root)"

# Utiliser des chemins absolus (PATH minimal dans cron):contentReference[oaicite:4]{index=4}
USAGE="$(/bin/df -P / | /usr/bin/awk "NR==2 {gsub(/%/,\"\",\$5); print \$5}")"

if [ "${USAGE}" -ge "${THRESHOLD}" ]; then
  echo "${NOW} | user=${WHO} | ALERT: / usage=${USAGE}% (>=${THRESHOLD}%)" >> "${LOG}"
else
  echo "${NOW} | user=${WHO} | OK: / usage=${USAGE}%" >> "${LOG}"
fi
EOF
```

### 2) Rendre ex√©cutable

bash:

```bash
sudo chmod +x /usr/local/sbin/disk_guard.sh
```

### 3) Tester manuellement

bash:

```bash
sudo /usr/local/sbin/disk_guard.sh
sudo tail -n 5 /var/log/disk_guard.log
```

### 4) Ajouter la t√¢che dans **/etc/crontab** (crontab syst√®me)

bash:

```bash
sudo nano /etc/crontab
```

Ajoutez en haut (environnement), puis la ligne planifi√©e **avec le champ utilisateur `root`** :

```
MAILTO=""
SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

* * * * * root /usr/local/sbin/disk_guard.sh >> /var/log/disk_guard.log 2>&1
```

> Rappels issus du document : crontab syst√®me = **7 champs** (les 5 temps + **utilisateur** + commande). `/etc/crontab` et `/etc/cron.d/*` sont r√©serv√©s √† root.

### 5) V√©rifier l‚Äôex√©cution (‚â§ 60 s)

bash:

```bash
sudo tail -f /var/log/disk_guard.log
```

---

## Contr√¥les & diagnostics utiles (les bons r√©flexes)

bash:

```bash
# Ce que cron a r√©ellement charg√© pour VOUS (utilisateur)
crontab -l

# Ce que le syst√®me va ex√©cuter (crontab syst√®me)
sudo cat /etc/crontab

# Journaux du d√©mon cron (utile pour voir le d√©clenchement minute par minute)
sudo journalctl -u cron -f
# (sur certaines distros, on peut aussi voir via syslog : sudo tail -f /var/log/syslog | grep -i CRON)
```

> Le d√©mon cron tourne en continu et se r√©veille **chaque minute** pour lire les crontabs et ex√©cuter les commandes planifi√©es ; la sortie est envoy√©e par mail sauf si redirig√©e ou `MAILTO=""`.

---

## Astuces p√©dagogiques (applicables en prod)

- **Chemins absolus** : le `$PATH` de cron est minimal ‚Üí utilisez `/bin/df`, `/usr/bin/awk`, etc., ou d√©finissez `PATH` en t√™te de la crontab.

- **Qui ex√©cute ?** Ajoutez `$(whoami)` / `id -u -n` dans vos logs pour tracer le **contexte utilisateur**.

- **√âviter le spam d‚Äôemails** : `MAILTO=""` ou redirigez proprement `>> ok.log 2>> err.log`.

- **Tester avant d‚Äôattendre** : lancez le script **√† la main** (bash ‚Ä¶) puis attendez la minute pour valider l‚Äôint√©gration cron.

- **S√©parer stdout/stderr** : `>> ~/‚Ä¶/ok.log 2>> ~/‚Ä¶/error.log` pour acc√©l√©rer le diagnostic.

- **Crontab utilisateur vs syst√®me** : utilisateur = 5 champs ; syst√®me = 7 champs (**+ utilisateur**) et √©dit√© par root.

---

## Nettoyage

bash:

```bash
# Crontab utilisateur
crontab -r
rm -rf ~/cron.d
rm -f  ~/bin/large_files_watch.sh

# Crontab syst√®me
sudo sed -i '\|/usr/local/sbin/disk_guard.sh|d' /etc/crontab
sudo rm -f /usr/local/sbin/disk_guard.sh /var/log/disk_guard.log
```

---

## Ce que vous avez vraiment appris (valeur)

- Diff√©rencier **crontab utilisateur** et **crontab syst√®me**, avec preuves observables dans des logs distincts.

- Composer des **scripts robustes** pour cron (chemins absolus, logs s√©par√©s, `whoami`, `set -euo pipefail`).

- Savoir **diagnostiquer** (journal du d√©mon cron, inspection des crontabs charg√©es).

Souhaitez-vous que je passe au **point suivant du plan** (syntaxe des champs + op√©rateurs `* , - /` avec une d√©mo ‚Äúz√©ro attente‚Äù), ou pr√©f√©rez-vous que j‚Äôajoute une variante √† cette d√©mo (par ex. surveillance d‚Äôun **r√©pertoire applicatif** via **/etc/cron.d** au lieu de `/etc/crontab`) ?

---

# D√©mo 3 ‚Äî Ma√Ætriser la syntaxe des champs cron avec un cas concret

## üéØ Objectif

Mettre en pratique les **5 champs cron** (minute, heure, jour, mois, jour-semaine) pour planifier des t√¢ches vari√©es, en utilisant un cas **r√©el et simple** :

- **Surveillance d‚Äôun petit service web local** (un serveur Python minimal).

- Envoi p√©riodique d‚Äôune requ√™te avec `curl`, et journalisation dans un log.

Ainsi, chaque champ de cron aura un r√¥le concret visible.

---

## √âtape A ‚Äî Lancer un petit service web local (z√©ro d√©pendance externe)

1. Dans un terminal, lancez un mini serveur Python sur le port 8080 :

```bash
python3 -m http.server 8080 --bind 127.0.0.1
```

2. V√©rifiez dans un autre terminal :

```bash
curl http://127.0.0.1:8080/
```

Vous devez voir une page HTML listant les fichiers du r√©pertoire courant.

üëâ Ce serveur est **instantan√©, l√©ger, et ne d√©tourne pas du sujet principal**.

---

## √âtape B ‚Äî Pr√©parer le script de ¬´ health-check ¬ª

On veut une commande qui enregistre dans un log si le service r√©pond.

Cr√©er les fichier **/usr/local/bin/health_check.sh**

```bash
#!/usr/bin/env bash
URL="http://127.0.0.1:8080/"
STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
DATE=$(date +'%F %T')
if [ "$STATUS" = "200" ]; then
  echo "$DATE | $URL OK" 
else
  echo "$DATE | $URL DOWN (status=$STATUS)"
fi
```

Puis ajouter les premissions d'execution

```bash
sudo chmod +x /usr/local/bin/health_check.sh
```

## √âtape C ‚Äî Ajouter des entr√©es crontab avec diff√©rentes syntaxes

Ouvrez votre crontab utilisateur :

```bash
crontab -e
```

Ajoutez (en haut) les variables utiles :

```
MAILTO=""
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Puis ins√©rez les lignes suivantes (toutes redirigent vers `/tmp/health.log`) :

```
# Chaque minute ‚Üí v√©rification rapide
* * * * * /usr/local/bin/health_check.sh >>/tmp/health.log 2>&1

# Toutes les 5 minutes entre 09h et 17h (plage d'heures)
*/5 9-17 * * * /usr/local/bin/health_check.sh >>/tmp/health.log 2>&1

# Tous les lundis √† 08h30
30 8 * * 1 /usr/local/bin/health_check.sh >>/tmp/health.log 2>&1

# Le 1er de chaque mois √† minuit pile
0 0 1 * * /usr/local/bin/health_check.sh >>/tmp/health.log 2>&1
```

---

## √âtape D ‚Äî Observer les r√©sultats

1. Surveiller le log :

```bash
tail -f /tmp/health.log
```

Exemple attendu (visible quasi imm√©diatement gr√¢ce √† la premi√®re ligne `* * * * *`) :

```
2025-09-23 19:01:00 | http://127.0.0.1:8080/ OK
2025-09-23 19:02:00 | http://127.0.0.1:8080/ OK
```

2. D√©sactivez le serveur pour tester un cas d‚Äô√©chec :
   
   - Stoppez le serveur Python (Ctrl+C).
   
   - Attendez la prochaine minute ‚Üí vous verrez :

```
2025-09-23 19:03:00 | http://127.0.0.1:8080/ DOWN (status=000)
```

---

## √âtape E ‚Äî Nettoyage

```bash
crontab -r
sudo rm -f /usr/local/bin/health_check.sh /tmp/health.log
```

---

## üß© Points p√©dagogiques mis en avant

- **Minute** : `*` ou `*/5` pour des fr√©quences diff√©rentes.

- **Heure** : `9-17` pour limiter la plage horaire.

- **Jour du mois** : `1` pour cibler le 1er jour.

- **Mois** : (non utilis√© ici, mais on aurait pu mettre `1,6` pour janvier et juin).

- **Jour de la semaine** : `1` (lundi).

- **Commande** : toujours un chemin absolu (`/usr/local/bin/...`).

- Observation **imm√©diate** gr√¢ce √† l‚Äôentr√©e `* * * * *`.

# D√©mo 4 ‚Äî Op√©rateurs cron (* , - /) sur un cas r√©el ¬´ sonde de sant√© HTTP ¬ª

## Objectif

Mettre en place une **sonde de sant√©** d‚Äôun service web (intranet, API, site ¬´ status ¬ª) avec un planning **granulaire** exploitant tous les op√©rateurs :

- `*` (toutes les valeurs), `,` (liste), `-` (plage), `/` (pas) dans les 5 champs cron.  
  Rappel : les 5 champs sont minute, heure, jour du mois, mois, jour de semaine, suivis de la commande.

---

## Pr√©-requis (Debian/Ubuntu)

```bash
# 1) curl est requis pour sonder une URL
sudo apt-get update && sudo apt-get install -y curl

# 2) s'assurer que cron tourne
sudo systemctl enable --now cron
```

---

## √âtape A ‚Äî Pr√©parer le script (d√©pendances pr√©sent√©es et install√©es)

Ce script sonde une URL, **log uniquement les anomalies** (non-200) dans `/var/log/site_health.log`.

Cr√©er le fichier */usr/local/bin/site_health.sh:*

```bash
#!/usr/bin/env bash
set -euo pipefail

URL="${URL:-https://example.com}"     # surcharge possible via variable d'env
TS="$(date +'%F %T')"
CODE="$(curl -k -s -o /dev/null -w '%{http_code}' "$URL")"

# On ne log QUE si √ßa ne va pas (code != 200)
if [ "$CODE" != "200" ]; then
  echo "$TS | ALERT | url=$URL | http_code=$CODE | host=$(hostname)" 
fi
```

Executer les commandes:

```bash
# Droits et log
sudo chmod +x /usr/local/bin/site_health.sh
sudo touch /var/log/site_health.log
sudo chmod 666 /var/log/site_health.log   # pour voir le log sans sudo en d√©mo
```

> Bonnes pratiques cron : **chemins absolus**, environnement minimal.

---

## √âtape B ‚Äî MODE D√âMO (visible en <60 s)

On ex√©cute **chaque minute** pour observer imm√©diatement.

```bash
crontab -e
```

Ajoutez en haut :

```
MAILTO=""
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
URL=https://example.com
```

Puis la t√¢che d√©mo (une ligne) :

```
*/1 * * * * /usr/local/bin/site_health.sh >>/var/log/site_health.log 2>&1
```

Surveillance en temps r√©el :

```bash
tail -f /var/log/site_health.log
```

Optionnel (observer l‚Äôactivit√© du d√©mon cron) :

```bash
sudo journalctl -u cron -f
```

> Le d√©mon **cron** tourne en continu, **se r√©veille chaque minute** et ex√©cute selon les entr√©es de crontab.

---

## √âtape C ‚Äî MODE R√âEL (utilisation astucieuse des op√©rateurs)

Quand la d√©mo est valid√©e, remplacez la ligne pr√©c√©dente par **un planning fin** qui exploite `* , - /` :

```
*/5 9-18 * 1,6 1-5 /usr/local/bin/site_health.sh >>/var/log/site_health.log 2>&1
```

### Pourquoi cet exemple est ¬´ r√©el ¬ª et astucieux

- **`*/5` (op√©rateur `/`)** : sonde toutes les **5 minutes** (pas de 5) pendant les plages vis√©es.

- **`9-18` (op√©rateur `-`)** : **plage horaire** de bureau 09:00‚Üí18:59 (heures locales).

- **`*` (g√©n√©ralisation)** sur le jour du mois : tous les jours du mois.

- **`1,6` (op√©rateur `,`)** sur le mois : **janvier et juin** seulement (ex. p√©riode de haute charge ou audits semestriels).

- **`1-5` (op√©rateur `-`)** sur le jour de semaine : **lundi √† vendredi** (on √©pargne les week-ends).

R√©sultat : en **janvier** et **juin**, du **lundi au vendredi**, entre **09:00 et 18:59**, la sonde s‚Äôex√©cute **toutes les 5 minutes**. C‚Äôest typique d‚Äôune **fen√™tre de supervision renforc√©e** (p√©riode d‚Äôinventaire, campagne RH, cl√¥ture comptable‚Ä¶).

> R√©f√©rence rappel op√©rateurs et champs de temps dans la crontab utilisateur/syst√®me.

---

## Tests cibl√©s (provoquer une alerte sans attendre)

- Remplacez provisoirement la variable d‚Äôenvironnement dans la crontab par une URL invalide pour d√©clencher un log d‚Äôalerte :
  
  ```
  URL=https://invalid.local
  ```

- Ou lancez le script **√† la main** avec une URL en erreur :
  
  ```bash
  URL=https://invalid.local /usr/local/bin/site_health.sh | tee -a /var/log/site_health.log
  ```

---

## Pi√®ges & astuces utiles

- **√âvitez de combiner ‚Äújour du mois‚Äù et ‚Äújour de semaine‚Äù sans y r√©fl√©chir** : selon l‚Äôimpl√©mentation, la t√¢che peut se d√©clencher si **l‚Äôun OU l‚Äôautre** correspond. S√©parez les cas au besoin (deux lignes) pour un contr√¥le strict.

- **MAILTO** vide en d√©mo pour ne pas spammer ; en prod, envoyez-vous **uniquement les erreurs** (le script n‚Äô√©crit que si code ‚â† 200).

- **PATH explicite** et **chemins absolus** (cron a un environnement minimal).

- Si vous avez besoin d‚Äôun **contexte r√©seau/d√©pendances** (VPN, secrets), lancez via **crontab syst√®me** sous un **compte d√©di√©** avec droits limit√©s et variables charg√©es depuis un fichier s√©curis√©.

---

## Nettoyage

```bash
crontab -r
sudo rm -f /usr/local/bin/site_health.sh /var/log/site_health.log
```

Parfait. On reste strictement dans le plan.

# D√©mo 5 ‚Äî Raccourcis cron (@hourly, @daily, @weekly) appliqu√©s √† un cas r√©el

**Objectif :** mettre en place une maintenance ‚Äúintelligente‚Äù d‚Äôun dossier d‚Äôuploads d‚Äôapplication avec trois niveaux :

- **@hourly** : compresser les fichiers de plus d‚Äô1h pour √©conomiser de l‚Äôespace.

- **@daily** : d√©placer les archives du jour vers un r√©pertoire de backup et purger au-del√† de 7 jours.

- **@weekly** : produire un rapport synth√®se (taille, nombre de fichiers) pour contr√¥le.

> On utilise les **raccourcis cron** plut√¥t que les 5 champs classiques, tels que document√©s dans le cours (ex. `@hourly`, `@daily`, `@weekly`).

---

## Pr√©-requis (Debian/Ubuntu)

Aucune d√©pendance exotique. On n‚Äôutilise que des utilitaires standards (`bash`, `find`, `tar`, `du`, `date`).  
V√©rifier que cron tourne :

```bash
sudo systemctl enable --now cron
sudo systemctl status cron --no-pager
```

Les raccourcis (`@hourly`, `@daily`, `@weekly`, `@monthly`, `@annually`) font partie de la syntaxe cron pr√©vue par la doc.

---

## Pr√©paration de l‚Äôenvironnement (pas de ‚Äúsolution parachut√©e‚Äù)

Cr√©ez l‚Äôarborescence, un log d√©di√© et trois scripts **clairs** dans `/usr/local/bin` :

```bash
# Dossiers de travail
sudo mkdir -p /srv/app/uploads /var/backups/app
sudo touch /var/log/app_maintenance.log
sudo chmod 666 /var/log/app_maintenance.log
```

Cr√©er ke script de compression des fichiers de uploads de plus d'une heure ***/usr/local/bin/app_hourly_pack.sh:***

```bash
#!/usr/bin/env bash
set -euo pipefail
UPS="/srv/app/uploads"
TMP="/var/backups/app"
LOG="/var/log/app_maintenance.log"
stamp="$(date +'%F %T')"

# Trouve les fichiers modifi√©s il y a > 60 min et les colle dans une archive horodat√©e
mapfile -t files < <(find "$UPS" -type f -mmin +60 2>/dev/null)
if (( ${#files[@]} )); then
  out="$TMP/hourly_$(date +'%F_%H%M').tar.gz"
  tar -C "$UPS" -czf "$out" "${files[@]/#${UPS}\//}" 2>>"$LOG"
  printf "%s | HOURLY | %d fichiers compress√©s -> %s\n" "$stamp" "${#files[@]}" "$out" >>"$LOG"
  # Optionnel: supprimer les originaux apr√®s archive (d√©commentez si souhait√©)
  # rm -f "${files[@]}"
else
  printf "%s | HOURLY | rien √† compresser\n" "$stamp" >>"$LOG"
fi

sudo chmod +x /usr/local/bin/app_hourly_pack.sh

# 2) Script @daily : d√©placer les archives du jour en backups stables et purger > 7 jours
sudo tee /usr/local/bin/app_daily_rotate.sh >/dev/null <<'SH'
#!/usr/bin/env bash
set -euo pipefail
SRC="/var/backups/app"
DST="/var/backups/app/daily"
LOG="/var/log/app_maintenance.log"
stamp="$(date +'%F %T')"

mkdir -p "$DST"

# D√©placer les archives "hourly_*.tar.gz" de la veille vers le dossier daily
# (on prend tout ce qui existe pour simplifier la d√©mo)
shopt -s nullglob
moved=0
for f in "$SRC"/hourly_*.tar.gz; do
  mv "$f" "$DST"/
  ((moved++))
done

# Purge : supprimer les daily de plus de 7 jours
purged=$(find "$DST" -type f -mtime +7 -name '*.tar.gz' -print -delete | wc -l)

printf "%s | DAILY | d√©plac√©s=%d | purg√©s>7j=%d | dossier=%s\n" "$stamp" "$moved" "$purged" "$DST" >>"$LOG"
SH
sudo chmod +x /usr/local/bin/app_daily_rotate.sh

# 3) Script @weekly : rapport d'int√©grit√© (taille et nombre de fichiers)
sudo tee /usr/local/bin/app_weekly_report.sh >/dev/null <<'SH'
#!/usr/bin/env bash
set -euo pipefail
UPS="/srv/app/uploads"
DST="/var/backups/app/daily"
LOG="/var/log/app_maintenance.log"
stamp="$(date +'%F %T')"

# Taille en blocs et nombre de fichiers
size_uploads=$(du -sh "$UPS" 2>/dev/null | awk '{print $1}')
count_uploads=$(find "$UPS" -type f 2>/dev/null | wc -l)
size_daily=$(du -sh "$DST" 2>/dev/null | awk '{print $1}')
count_daily=$(find "$DST" -type f -name '*.tar.gz' 2>/dev/null | wc -l)

printf "%s | WEEKLY | uploads: %s (%s fichiers) | daily: %s (%s archives)\n" \
  "$stamp" "${size_uploads:-0}" "$count_uploads" "${size_daily:-0}" "$count_daily" >>"$LOG"
```

Puis executer la commande:

```bash
sudo chmod +x /usr/local/bin/app_weekly_report.sh
```

> Bonnes pratiques cron : **chemins absolus**, **SHELL/MAILTO/PATH** explicites dans la crontab, redirections g√©r√©es pour √©viter des mails intempestifs.

---

## Installation des t√¢ches avec les raccourcis cron

Ouvrez votre crontab utilisateur :

```bash
crontab -e
```

Ajoutez en haut :

```
MAILTO=""
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Puis ajoutez les trois t√¢ches avec **raccourcis** :

```
@hourly  /usr/local/bin/app_hourly_pack.sh    >>/var/log/app_maintenance.log 2>&1
@daily   /usr/local/bin/app_daily_rotate.sh   >>/var/log/app_maintenance.log 2>&1
@weekly  /usr/local/bin/app_weekly_report.sh  >>/var/log/app_maintenance.log 2>&1
```

> Ces formes `@hourly/@daily/@weekly` sont **√©quivalentes** √† des expressions classiques (ex. `0 * * * *` pour `@hourly`) mais **plus lisibles** et **moins sujettes √† erreur**.

---

## V√©rification & observation (quasi instantan√©)

1. **G√©n√©rez de la mati√®re** pour que l‚Äô@hourly ait quelque chose √† compresser :

```bash
# Simuler des uploads "anciens" (touch -d pour antidater √† > 60 min)
for i in {1..5}; do
  sudo dd if=/dev/urandom of="/srv/app/uploads/file_$i.bin" bs=1K count=128 status=none
  sudo touch -d "90 minutes ago" "/srv/app/uploads/file_$i.bin"
done
```

2. **Attendez le prochain top minute** (‚â§ 60 s). Surveillez le log d√©di√© :

```bash
tail -f /var/log/app_maintenance.log
```

Vous devriez voir passer une ligne **HOURLY** indiquant combien de fichiers ont √©t√© compress√©s et o√π se trouve l‚Äôarchive.

3. **Contr√¥le des artefacts** :

```bash
ls -lh /var/backups/app        # archives hourly_*.tar.gz
```

> Pour **@daily** et **@weekly**, vous n‚Äôavez rien √† attendre en d√©mo : lancez une **ex√©cution manuelle** ponctuelle pour valider la logique sans attendre minuit ou la fin de semaine :

```bash
/usr/local/bin/app_daily_rotate.sh   && tail -n1 /var/log/app_maintenance.log
/usr/local/bin/app_weekly_report.sh  && tail -n1 /var/log/app_maintenance.log
```

Astuce : c‚Äôest exactement le **m√™me code** que cron d√©clenchera aux cr√©neaux pr√©vus par les raccourcis.

---

## Ce que cette d√©mo prouve

- **Lisibilit√© & robustesse** : en prod, les raccourcis `@hourly/@daily/@weekly` **r√©duisent les erreurs** par rapport aux 5 champs et facilitent la revue.

- **Cas r√©el** : on traite un vrai besoin DevOps (optimiser espace, organiser backups, suivi chiffr√©).

- **Tra√ßabilit√©** : un **log unique** `/var/log/app_maintenance.log` raconte l‚Äôhistoire (compactions, rotations, rapports).

- **Sans d√©pendances exotiques** : utilisables sur n‚Äôimporte quelle Debian/Ubuntu standard.

- **Quasi instantan√©** : r√©sultat visible en < 60 s pour @hourly ; ex√©cution **manuelle** imm√©diate pour valider @daily/@weekly sans attendre.

---

## Nettoyage (si besoin)

```bash
crontab -r
sudo rm -rf /srv/app/uploads /var/backups/app /var/log/app_maintenance.log
sudo rm -f /usr/local/bin/app_hourly_pack.sh /usr/local/bin/app_daily_rotate.sh /usr/local/bin/app_weekly_report.sh
```

Parfait ‚Äî on encha√Æne strictement avec **D√©mo 5 ‚Äî Raccourcis cron (@hourly, @daily, @weekly, @monthly, @annually)**, en gardant le m√™me style : cas r√©el, quasi-instantan√© √† tester, d√©pendances pr√©par√©es, et **scripts pr√©sent√©s s√©par√©ment des commandes** (pas de `tee <<'SH'`).  
Je m‚Äôappuie sur la section ¬´ Sp√©cifications horaires particuli√®res ¬ª et variables crontab du document.

# D√©mo 5 ‚Äî Pipeline de maintenance de logs avec raccourcis cron

## Objectif

Mettre en place une **strat√©gie de maintenance de logs r√©aliste** (rotation, compression, purge, archivage) en s‚Äôappuyant sur les **raccourcis cron** (`@hourly`, `@daily`, `@weekly`, `@monthly`). 

## Pr√©-requis (Debian/Ubuntu)

```bash
# 1) S'assurer que cron tourne
sudo systemctl status cron --no-pager || sudo systemctl enable --now cron

# 2) Outils utiles (gzip, tar, tree)
sudo apt-get update
sudo apt-get install -y gzip tar tree
```

---

## Structure du cas r√©el

Commencer par cr√©er ces dossiers:

- Dossier source de logs applicatifs : `/opt/demo-logs/incoming`

- Dossier de logs compress√©s : `/opt/demo-logs/compressed`

- Dossier d‚Äôarchives mensuelles : `/opt/demo-logs/archive`

- Scripts d‚Äôorchestration : `/opt/demo-logs/scripts/`

Chaque raccourci cron lancera **le m√™me script** avec un **mode** diff√©rent :

- `@hourly` ‚Üí rotation ‚Äúdouce‚Äù des logs courants (renommage + ajout d‚Äôhorodatage).

- `@daily` ‚Üí **compression** des `.log` en `.gz`.

- `@weekly` ‚Üí **purge** des `.gz` de plus de 14 jours.

- `@monthly` ‚Üí **archivage** des `.gz` du mois pr√©c√©dent en un `.tar.gz`.

> Ces quatre fr√©quences correspondent exactement aux raccourcis d√©crits dans le document.

---

## √âtape A ‚Äî Pr√©parer l‚Äôaire de test (quasi imm√©diat)

```bash
sudo mkdir -p /opt/demo-logs/{incoming,compressed,archive,scripts}
sudo chown -R "$USER":"$USER" /opt/demo-logs

# G√©n√©rer quelques faux logs applicatifs pour la d√©mo
cd /opt/demo-logs/incoming
printf "INFO Start %s\n" "$(date)" > app.log
for i in {1..5}; do printf "INFO line %02d at %s\n" "$i" "$(date)"; done >> app.log
cp app.log access.log
```

V√©rifiez :

```bash
tree /opt/demo-logs
```

---

## √âtape B ‚Äî Cr√©er les scripts (contenu + droits)

### 1) Fichier `/opt/demo-logs/scripts/log_maintenance.sh`

> Cr√©ez ce fichier avec votre √©diteur (ex. `nano /opt/demo-logs/scripts/log_maintenance.sh`) puis **collez** le contenu ci-dessous.

```bash
#!/usr/bin/env bash
#-e ‚Üí le script s‚Äôarr√™te imm√©diatement si une commande √©choue 
#-u ‚Üí le script s‚Äôarr√™te si on utilise une variable non d√©finie 
#-o pipefail le script √©choue si n‚Äôimporte quelle commande du pipeline √©choue (pas seulement la derni√®re).
set -euo pipefail

BASE="/opt/demo-logs"
SRC="$BASE/incoming"
CMP="$BASE/compressed"
ARC="$BASE/archive"
# ${1:-}" la variable est vide ou non d√©finie, utilise la valeur par d√©faut (ici vide)
mode="${1:-}"
ts_now="$(date +'%Y%m%d-%H%M%S')"

case "$mode" in
  hourly)
    # Rotation douce: renomme les .log actifs avec timestamp pour figer un snapshot
    # (sans compression imm√©diate)
    find "$SRC" -maxdepth 1 -type f -name '*.log' | while read -r f; do
      mv -f "$f" "${f%.log}.$ts_now.log"
    done
    ;;

  daily)
    # Compression des .log en .gz vers compressed/
    mkdir -p "$CMP"
    find "$SRC" -maxdepth 1 -type f -name '*.log' | while read -r f; do
      gzip -c "$f" > "$CMP/$(basename "$f").$ts_now.gz"
      : > "$f"   # Troncature du log source (logrotate-like minimal)
    done
    ;;

  weekly)
    # Purge des .gz vieux de +14 jours
    find "$CMP" -type f -name '*.gz' -mtime +14 -print -delete
    ;;

  monthly)
    # Archivage des .gz du mois pr√©c√©dent ‚Üí archive/YYYY-MM.tar.gz
    mkdir -p "$ARC"
    prev_month="$(date -d "$(date +%Y-%m-15) -1 month" +%Y-%m)"
    tmp_list="$(mktemp)"
    find "$CMP" -type f -name '*.gz' -newermt "$prev_month-01" ! -newermt "$prev_month-31 23:59:59" -print > "$tmp_list"
    if [ -s "$tmp_list" ]; then
      tar -czf "$ARC/${prev_month}.tar.gz" -T "$tmp_list"
      xargs -a "$tmp_list" rm -f
    fi
    rm -f "$tmp_list"
    ;;

  *)
    echo "Usage: $0 {hourly|daily|weekly|monthly}" >&2
    exit 2
    ;;
esac
```

Puis :

```bash
chmod +x /opt/demo-logs/scripts/log_maintenance.sh
```

### 2)  Fichier `/opt/demo-logs/scripts/inspect.sh` (Optionel)

> Pour visualiser rapidement l‚Äô√©tat des dossiers.

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "=== incoming ===";  ls -lh /opt/demo-logs/incoming || true
echo "=== compressed ===";ls -lh /opt/demo-logs/compressed || true
echo "=== archive ===";  ls -lh /opt/demo-logs/archive   || true
```

Puis :

```bash
chmod +x /opt/demo-logs/scripts/inspect.sh
```

---

## √âtape C ‚Äî Tests **instantan√©s** (sans attendre cron)

> On ex√©cute **manuellement** chaque mode pour constater l‚Äôeffet imm√©diatement, avant de confier la cadence √† cron.

```bash
# 1) √âtat initial
/opt/demo-logs/scripts/inspect.sh

# 2) Simuler @hourly
/opt/demo-logs/scripts/log_maintenance.sh hourly
/opt/demo-logs/scripts/inspect.sh

# 3) Simuler @daily
/opt/demo-logs/scripts/log_maintenance.sh daily
/opt/demo-logs/scripts/inspect.sh

# 4) Simuler @weekly (purge >14j) ‚Äî cr√©ez vite un faux vieux .gz pour d√©monstration
touch -d "20 days ago" /opt/demo-logs/compressed/fake-old.gz
/opt/demo-logs/scripts/log_maintenance.sh weekly
/opt/demo-logs/scripts/inspect.sh

# 5) Simuler @monthly (archive le mois pr√©c√©dent)
# Pour la d√©mo, on fabrique un .gz dat√© du mois pr√©c√©dent :
prev_month=$(date -d "$(date +%Y-%m-15) -1 month" +%Y-%m)
touch -d "$prev_month-10" /opt/demo-logs/compressed/synthetic-$prev_month.gz
/opt/demo-logs/scripts/log_maintenance.sh monthly
/opt/demo-logs/scripts/inspect.sh
```

---

## √âtape D ‚Äî Programmer avec **raccourcis cron**

> On inscrit maintenant les **raccourcis** dans la crontab **utilisateur**. La syntaxe des raccourcis (`@hourly`, `@daily`, etc.) est conforme au document.

```bash
crontab -e
```

Ajoutez (tout en haut) ces variables recommand√©es, puis les lignes de planification :

```
MAILTO=""
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

@hourly  /opt/demo-logs/scripts/log_maintenance.sh hourly
@daily   /opt/demo-logs/scripts/log_maintenance.sh daily
@weekly  /opt/demo-logs/scripts/log_maintenance.sh weekly
@monthly /opt/demo-logs/scripts/log_maintenance.sh monthly
# @annually (exemple si besoin) :
# @annually /opt/demo-logs/scripts/yearly_report.sh
```

> Rappel : dans les crontabs **utilisateur**, on a 5 champs ‚Äútemps + commande‚Äù, mais les **raccourcis** remplacent ces 5 champs par un mot-cl√© lisible.

V√©rifiez :

```bash
crontab -l
```

---

## V√©rifications & observation

- **Ex√©cution r√©elle par cron** :
  
  - Attendez le prochain **d√©but d‚Äôheure** pour `@hourly` (ou laissez tourner).
  
  - Les autres suivront leur cadence.

- **Journaux syst√®me (activit√© du d√©mon cron)** :

```bash
sudo journalctl -u cron -f
# ou selon distro :
# sudo tail -f /var/log/syslog | grep -i CRON
```

> Le d√©mon cron fonctionne en continu et d√©clenche les t√¢ches aux cr√©neaux des raccourcis.

---

## Nettoyage (si n√©cessaire)

```bash
crontab -r
rm -rf /opt/demo-logs
```

---

## Points p√©dagogiques cl√©s

- Les **raccourcis cron** (`@hourly`, `@daily`, `@weekly`, `@monthly`, `@annually`) **remplacent les 5 colonnes temporelles** et lisent mieux en production.

- Cas r√©el mis en place : **pipeline de maintenance de logs** complet (rotation, compression, purge, archivage) ‚Äî pratique, r√©utilisable.

- **Quasi-instantan√©** : on **teste manuellement** chaque mode avec le m√™me script pour valider sans attendre le calendrier.

- Bonnes pratiques : **chemins absolus**, `MAILTO=""`, `SHELL=/bin/bash`, `PATH` explicite.

---

parfait‚Äîje reprends **toute la d√©mo ‚ÄúVariables de crontab (HOME, MAILTO, PATH, SHELL)‚Äù** en int√©grant tous les correctifs que vous avez valid√©s (fallback sur `USER`, cr√©ation du dossier, debug, MTA local, etc.).  
Je garde votre style : **commandes s√©par√©es** des **contenus de scripts**, d√©clenchement **toutes les minutes** (effet < 60 s), pas de splitview.  
Les points de doctrine (r√¥le de cron, variables crontab, e-mails, PATH/SHELL/HOME) proviennent du doc.

---

# D√©mo 6 (corrig√©e) ‚Äî Variables de crontab + mails locaux

## Objectif

Mettre en place un mini reporting lanc√© par cron, qui prouve concr√®tement l‚Äôeffet de :

- `SHELL` (shell utilis√© par cron ; par d√©faut `/bin/sh`, on force bash si besoin)

- `PATH` (acc√®s aux binaires hors chemins ‚Äúclassiques‚Äù, ex. `/usr/local/bin`)

- `HOME` (r√©pertoire de travail pour les chemins relatifs)

- `MAILTO` (o√π part la sortie/erreur ; cha√Æne vide = pas d‚Äôe-mail)

---

## 0) Pr√©parer un MTA local (le plus simple possible)

**Commandes**

```bash
sudo apt-get update
sudo apt-get install -y postfix mailutils
```

- √Ä l‚Äôassistant Postfix, choisissez **Local only** (local seulement).

- Laissez le hostname propos√©.

**V√©rification rapide**

```bash
systemctl status postfix --no-pager
echo "hello" | mail -s "test-local" "$USER"
mail   # (q pour quitter)
```

> Ainsi `MAILTO` pourra envoyer des mails **locaux** (bo√Æte `/var/mail/<user>`).

---

## 1) S‚Äôassurer que cron tourne

```bash
sudo systemctl enable --now cron
```

> Cron est un d√©mon qui se r√©veille **chaque minute** et ex√©cute les jobs selon les crontabs.

---

## 2) Arborescence de travail (dossier appli)

```bash
sudo mkdir -p /opt/app/out
sudo chown -R "$USER":"$USER" /opt/app
```

---

## 3) D√©pendance A ‚Äî utilitaire `slugify` (sert √† d√©montrer PATH)

### But & exemple

- Transforme une cha√Æne ‚Äúhumaine‚Äù en nom de fichier propre (minuscules, tirets, ASCII).

- Exemple :  
  Entr√©e ‚Üí `Rapport 2025-09-23 H√©bergement & R√©seau`  
  Sortie ‚Üí `rapport-2025-09-23-hebergement-reseau`

### Cr√©er le fichier

```bash
sudo nano /usr/local/bin/slugify
```

### Contenu de `/usr/local/bin/slugify`

```bash
#!/usr/bin/env bash
# Transforme une cha√Æne en "slug": minuscules, tirets, ASCII simple
set -euo pipefail
if [[ $# -lt 1 ]]; then
  echo "usage: slugify <texte>" >&2
  exit 2
fi
s="$*"
# accents -> ASCII, espaces/punct -> '-', trim des '-'
s="$(echo "$s" | iconv -f UTF-8 -t ASCII//TRANSLIT 2>/dev/null || echo "$s")"
s="$(echo "$s" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g; s/^-+|-+$//g')"
echo "$s"
```

### Rendre ex√©cutable + test rapide

```bash
sudo chmod +x /usr/local/bin/slugify
/usr/local/bin/slugify "Rapport test H√©bergement & R√©seau"
# -> rapport-test-hebergement-reseau
```

> Beaucoup d‚Äôenvironnements cron n‚Äôincluent pas `/usr/local/bin` dans `PATH` par d√©faut : on le d√©montrera puis on corrigera via la crontab.

---

## 4) D√©pendance B ‚Äî script `daily-report.sh` (robuste pour cron)

### Cr√©er le fichier

```bash
nano /opt/app/daily-report.sh
```

### Contenu de `/opt/app/daily-report.sh`

```bash
#!/usr/bin/env bash
# Script "bash-only" robuste pour cron
set -euo pipefail

# --- debug (redirige stdout+stderr vers un log d√©di√©) ---
exec >>/opt/app/out/debug.log 2>&1
echo "==== NEW RUN $(date) ===="
env

# --- environnement cron: USER peut manquer -> fallback LOGNAME/whoami ---
EUSER="${USER:-${LOGNAME:-$(whoami)}}"

# --- dossiers ---
mkdir -p ./out

# --- tra√ßage p√©dagogique des variables cron ---
echo "[$(date +'%F %T')] SHELL=${SHELL:-?} EUSER=$EUSER HOME=${HOME:-?} PATH=${PATH:-?}" >> ./out/env.log

# --- g√©n√©ration d'un nom de fichier propre ---
title="Rapport $(date +'%F') $(hostname)"
slug="$(slugify "$title")"   # n√©cessite PATH incluant /usr/local/bin

# --- contenu du rapport ---
report="./out/${slug}.txt"
{
  echo "=== Rapport syst√®me ==="
  echo "Date: $(date -Is)"
  echo "H√¥te: $(hostname)"
  echo "Utilisateur effectif: $EUSER"
  echo "Uptime: $(uptime -p)"
  echo "Disque racine: $(df -h / | awk 'NR==2{print $5\" used of \"$2}')"
} > "$report"

# --- message d'info (ira par mail si MAILTO non vide) ---
echo "INFO: Rapport √©crit -> $report" >&2
```

### Droits

```bash
chmod +x /opt/app/daily-report.sh
```

---

## 5) Crontab (variables **en t√™te** + job par minute)

### Ouvrir la crontab utilisateur

```bash
crontab -e
```

### Coller EXACTEMENT ceci

```
MAILTO="bechir"   # ou "" si vous ne voulez aucun mail
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOME=/opt/app

* * * * * /opt/app/daily-report.sh
```

- `SHELL` : force bash si le script utilise des features bash.

- `PATH` : inclut `/usr/local/bin` pour trouver `slugify`.

- `HOME` : garantit que `./out/...` pointe vers `/opt/app/out`.

- `MAILTO` : destinataire local de la sortie/erreur (ou ‚Äúvide‚Äù pour d√©sactiver).

---

## 6) Validation (‚â§ 60 s)

**Fichiers g√©n√©r√©s**

```bash
ls -l /opt/app/out/
tail -n 5 /opt/app/out/env.log
tail -n 20 /opt/app/out/debug.log
```

**Mails (si MAILTO non vide)**

```bash
mail
```

Vous devez voir :

- `env.log` avec `SHELL=/bin/bash`, `HOME=/opt/app`, `PATH=‚Ä¶`, `EUSER=bechir`.

- Un fichier rapport `rapport-<date>-<hostname>.txt`.

- Des mails ‚ÄúCron ‚Ä¶ /opt/app/daily-report.sh‚Äù contenant le message `INFO: Rapport √©crit -> ‚Ä¶` (ou rien si `MAILTO=""`).

---

## 7) Variante ‚Äúsans mails‚Äù (tout en fichiers)

Si vous pr√©f√©rez 0 e-mail :

```bash
crontab -e
```

Remplacez `MAILTO` par vide et logguez stdout/stderr vous-m√™me :

```
MAILTO=""
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOME=/opt/app

* * * * * /opt/app/daily-report.sh >>/opt/app/out/run.log 2>&1
```

> Le doc pr√©cise qu‚Äôun `MAILTO` vide d√©sactive l‚Äôenvoi d‚Äôe-mails ; sinon la sortie du job part au propri√©taire ou √† l‚Äôadresse indiqu√©e.

---

## 8) Tests ‚Äúcomme cron‚Äù (diagnostic express)

Pour reproduire l‚Äôenvironnement minimal de cron √† la main :

```bash
env -i HOME=/opt/app PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin SHELL=/bin/bash /opt/app/daily-report.sh
```

Puis :

```bash
ls -l /opt/app/out/
tail -n 20 /opt/app/out/debug.log
```

---

## 9) Nettoyage (optionnel)

```bash
crontab -r
rm -f /opt/app/out/* /opt/app/daily-report.sh
sudo rm -f /usr/local/bin/slugify
sudo rmdir /opt/app/out 2>/dev/null || true
sudo rmdir /opt/app 2>/dev/null || true
# (√©ventuel)
# sudo apt-get purge -y postfix mailutils
```

---

## Ce que vous avez prouv√© (raccroch√© au doc)

- **Cron** ex√©cute √† la minute selon les crontabs utilisateurs/syst√®me.

- **SHELL** impacte la compatibilit√© (bash vs sh).

- **PATH** doit inclure vos binaires (ex. `/usr/local/bin`) si vous les utilisez dans les jobs.

- **HOME** fixe le r√©pertoire courant pour les chemins relatifs.

- **MAILTO** contr√¥le l‚Äôacheminement de la sortie/erreur (adresse, liste, ou ‚Äúvide‚Äù pour rien).
  
  ---

# D√©mo 7 ‚Äî Restreindre qui a le droit de planifier avec `crontab`

## Objectif r√©aliste

Dans une VM Debian/Ubuntu multi-utilisateurs, on veut qu‚Äô**uniquement** le compte de service `report` puisse cr√©er/√©diter sa crontab, tandis que les d√©veloppeurs (`dev1`, `dev2`) n‚Äôy aient pas acc√®s. On validera le comportement imm√©diatement en lan√ßant `crontab -e` sous chaque compte.

> Rappel de la r√®gle officielle (r√©sum√©) :
> 
> - Si **`/etc/cron.allow` existe**, **seuls** les utilisateurs **list√©s dedans** ont le droit d‚Äôutiliser `crontab`.
> 
> - Sinon, si **`/etc/cron.deny` existe**, les utilisateurs **list√©s dedans** sont **interdits**; un `cron.deny` **vide** signifie ‚Äútout le monde autoris√©‚Äù.
> 
> - Si **aucun** des deux n‚Äôexiste, c‚Äôest **sp√©cifique √† la distribution**.
> 
> - Les deux fichiers contiennent des **noms d‚Äôutilisateurs, un par ligne**.

---

## Pr√©-requis (packages & service)

```bash
# Debian/Ubuntu : s'assurer que cron est install√© et actif
sudo apt-get update
sudo apt-get install -y cron
sudo systemctl enable --now cron
```

---

## √âtape 1 ‚Äî Cr√©er les comptes (d√©pendances humaines)

```bash
# Comptes d√©veloppeurs
sudo adduser --disabled-password --gecos "" dev1
sudo adduser --disabled-password --gecos "" dev2

# Compte de service autoris√© √† planifier
sudo adduser --system --shell /bin/bash --home /home/report report
# (Optionnel) lui donner un mot de passe si vous voulez vous connecter en session
sudo passwd report
```

---

## √âtape 2 ‚Äî √âtat initial (tout le monde peut tester `crontab -e` ?)

Testez rapidement (les 3 comptes) **avant** toute restriction :

```bash
# En tant que dev1
sudo -u dev1 -H bash -lc 'crontab -l || true; echo "---"; crontab -e <<<":q" 2>&1 | tail -n1'
# En tant que dev2
sudo -u dev2 -H bash -lc 'crontab -l || true; echo "---"; crontab -e <<<":q" 2>&1 | tail -n1'
# En tant que report
sudo -u report -H bash -lc 'crontab -l || true; echo "---"; crontab -e <<<":q" 2>&1 | tail -n1'
```

> But : constater que, par d√©faut, ils **peuvent** ouvrir `crontab -e` (selon la politique actuelle de votre distro).

---

## √âtape 3 ‚Äî Politique stricte avec `cron.allow` (liste blanche)

**Sc√©nario s√©curit√© ‚Äúproduction‚Äù** : on impose une **liste blanche**. Seul `report` pourra planifier.

```bash
# 3.1 Cr√©er/√©diter /etc/cron.allow
sudo nano /etc/cron.allow
```

**Contenu de `/etc/cron.allow` :**

```
report
```

> Explication : d√®s que `cron.allow` existe, **seuls** les utilisateurs list√©s (ici `report`) ont droit √† `crontab`. Les autres seront **refus√©s imm√©diatement**.

**Validation imm√©diate (z√©ro attente) :**

```bash
# dev1 : doit √™tre refus√©
sudo -u dev1 -H bash -lc 'crontab -e 2>&1 | tail -n1'

# dev2 : doit √™tre refus√©
sudo -u dev2 -H bash -lc 'crontab -e 2>&1 | tail -n1'

# report : doit √™tre accept√©
sudo -u report -H bash -lc 'crontab -e <<<":q"; echo "OK pour report"'
```

Vous verrez typiquement pour `dev1/dev2` un message du style ‚Äúyou are not allowed to use this program‚Äù.

---

## √âtape 4 ‚Äî Passage en ‚Äúliste noire‚Äù avec `cron.deny` (exercice astucieux)

**Cas r√©el** : vous lancez un **hackathon** interne o√π *tous les devs* sont autoris√©s √† utiliser `crontab` sauf un compte ‚Äúbruyant‚Äù `dev2` qui surcharge la machine.

1. **Basculer la strat√©gie :** on retire la liste blanche et on met une **liste noire**.

```bash
# 4.1 D√©sactiver la whitelist
sudo rm -f /etc/cron.allow

# 4.2 Cr√©er/√©diter /etc/cron.deny
sudo nano /etc/cron.deny
```

**Contenu de `/etc/cron.deny` :**

```
dev2
```

> R√©sultat attendu : **tous** les utilisateurs **sauf** `dev2` peuvent utiliser `crontab`. Un fichier `cron.deny` **vide** autoriserait **tout le monde**.

**Validation imm√©diate :**

```bash
# dev1 : doit √™tre autoris√©
sudo -u dev1 -H bash -lc 'crontab -e <<<":q"; echo "OK pour dev1"'

# dev2 : doit √™tre refus√©
sudo -u dev2 -H bash -lc 'crontab -e 2>&1 | tail -n1'

# report : doit √™tre autoris√©
sudo -u report -H bash -lc 'crontab -e <<<":q"; echo "OK pour report"'
```

---

## √âtape 5 ‚Äî Test d‚Äôaudit rapide (preuve de blocage/autorisation)

On va demander √† chacun **d‚Äôessayer de poser un job**. On ne va pas attendre 1‚Äì2 minutes : l‚Äôobjectif est juste de v√©rifier **droit d‚Äôacc√®s** √† `crontab`, pas d‚Äôex√©cuter un cron.

**Commande simple √† saisir (si autoris√©) :**

```
* * * * * date >>/tmp/cron_access_probe.log 2>&1
```

> Saisissez-la via `crontab -e` **uniquement** avec les comptes autoris√©s (ici `dev1`, `report` en mode deny; `report` seul en mode allow).  
> Le fichier `/tmp/cron_access_probe.log` se remplira ensuite, mais la **validation des droits** est **instantan√©e** : soit l‚Äô√©dition est possible, soit elle est refus√©e imm√©diatement.

---

## √âtape 6 ‚Äî Edge cases & bonnes pratiques

- **Root bypass** : `root` n‚Äôest pas concern√© par `cron.allow/deny` pour utiliser `crontab` (il g√®re aussi `/etc/crontab` et `/etc/cron.d/*`). C‚Äôest le comportement attendu d‚Äôadministration. (Rappel sur crontab syst√®me /etc/crontab & /etc/cron.d)

- **Format** : un **nom d‚Äôutilisateur par ligne** dans `cron.allow`/`cron.deny`. Pas d‚Äôespaces ni de commentaires exotiques.

- **Priorit√©** : si `cron.allow` existe, il **prime** sur `cron.deny`. Sinon, `cron.deny` s‚Äôapplique.

- **Journalisation** : en cas de doute, v√©rifiez le journal du service :
  
  ```bash
  sudo journalctl -u cron -n 50 --no-pager
  ```

---

## Nettoyage (optionnel)

```bash
sudo rm -f /etc/cron.allow /etc/cron.deny
sudo deluser --remove-home dev1
sudo deluser --remove-home dev2
sudo deluser --remove-home report 2>/dev/null || true
sudo rm -f /tmp/cron_access_probe.log
```

---

## R√©sultats attendus (checklist rapide)

- ‚úÖ En mode **liste blanche** (avec `/etc/cron.allow`), **seul `report`** peut ouvrir/√©diter sa crontab.

- ‚úÖ En mode **liste noire** (avec `/etc/cron.deny`), **tout le monde sauf `dev2`** peut utiliser `crontab`.

- ‚úÖ La **validation est instantan√©e** (aucune attente), car on **teste les droits d‚Äô√©dition** de crontab, pas l‚Äôex√©cution d‚Äôun job.

# D√©mo 8 ‚Äî Exploiter `/etc/cron.daily` et `/etc/cron.weekly` (live, sans attente)

## Objectif

Mettre en place un mini-cycle d‚Äôexploitation r√©el pour une appli :

1. **t√¢che quotidienne** qui **archive et compresse** le log de l‚Äôappli,

2. **t√¢che hebdomadaire** qui **purg e les archives** de plus de 4 semaines.  
   Puis d√©clencher ces t√¢ches **imm√©diatement** (sans attendre) via `run-parts` pour la d√©monstration.  
   Les r√©pertoires `/etc/cron.daily` et `/etc/cron.weekly` sont pr√©vus pour √ßa, selon la distro.

---

## Pr√©-requis (Debian/Ubuntu)

- √ätre sudoer

- Service cron actif :

```bash
sudo systemctl status cron --no-pager || sudo systemctl enable --now cron
```

---

## Mise en place des donn√©es de test (r√©aliste)

On simule une appli qui √©crit dans un log d√©di√©.

```bash
# 1) Cr√©er l‚Äôarborescence de logs et d‚Äôarchives
sudo mkdir -p /var/log/myapp/archive

# 2) G√©n√©rer un log courant de l‚Äôappli
echo "startup ok $(date)" | sudo tee -a /var/log/myapp/app.log
echo "processing item #1 $(date)" | sudo tee -a /var/log/myapp/app.log
```

---

## Partie A ‚Äî T√¢che **quotidienne** (archive + compression)

### 1) Cr√©er le script dans `/etc/cron.daily/backup_myapp_log`

> Utilisez votre √©diteur (ex. `sudo nano /etc/cron.daily/backup_myapp_log`) puis collez **exactement** le contenu ci-dessous.

#### Contenu du script (√† coller) :

```bash
#!/usr/bin/env bash
set -euo pipefail

LOG_DIR="/var/log/myapp"
ARCHIVE_DIR="$LOG_DIR/archive"
LOG_FILE="$LOG_DIR/app.log"

# 1) Rien √† faire si le log courant n'existe pas
[ -f "$LOG_FILE" ] || exit 0

# 2) Nom horodat√© (YYYYMMDD-HHMMSS) pour un archivage tra√ßable
STAMP="$(date +'%Y%m%d-%H%M%S')"
ARCHIVE_FILE="$ARCHIVE_DIR/app-$STAMP.log"

# 3) D√©placer le log courant vers l'archive, puis compresser
install -d -m 0755 "$ARCHIVE_DIR"
mv "$LOG_FILE" "$ARCHIVE_FILE"
gzip -9 "$ARCHIVE_FILE"

# 4) Recr√©er un log courant vide avec permissions safe
install -m 0640 -o root -g adm /dev/null "$LOG_FILE"

# 5) Journaliser dans syslog pour audit (visible via journalctl / syslog)
logger -t myapp.cron.daily "Archived $ARCHIVE_FILE.gz and rotated $LOG_FILE"
```

### 2) Rendre ex√©cutable

```bash
sudo chmod 0755 /etc/cron.daily/backup_myapp_log
```

### 3) **D√©clencher tout de suite** (live)

Certaines distros lancent `cron.daily` via `run-parts`. On va l‚Äôappeler **manuellement** :

```bash
# Voir ce qui serait ex√©cut√©
run-parts --test /etc/cron.daily

# Lancer r√©ellement (verbose pour voir l'ex√©cution)
sudo run-parts --verbose /etc/cron.daily
```

### 4) V√©rifications

```bash
# a) Archives cr√©√©es
ls -lh /var/log/myapp/archive/

# b) Log courant recr√©√© et vid√©
ls -l /var/log/myapp/app.log
sudo tail -n 5 /var/log/syslog | grep -i myapp.cron.daily || true
# (ou) sudo journalctl -e | grep -i myapp.cron.daily
```

> Ce flux illustre l‚Äôusage attendu de `/etc/cron.daily` : y d√©poser des scripts ex√©cut√©s √† la fr√©quence ¬´ quotidienne ¬ª par la m√©canique cron/`run-parts` de la distro.

---

## Partie B ‚Äî T√¢che **hebdomadaire** (purge d‚Äôarchives > 4 semaines)

### 1) Pr√©parer de ¬´ fausses ¬ª archives anciennes (pour prouver la purge)

```bash
# Cr√©er 2 archives "anciennes" (45 et 33 jours)
sudo touch -d '45 days ago' /var/log/myapp/archive/app-OLD1.log.gz
sudo touch -d '33 days ago' /var/log/myapp/archive/app-OLD2.log.gz

# Cr√©er 1 archive "r√©cente" (5 jours)
sudo touch -d '5 days ago' /var/log/myapp/archive/app-RECENT.log.gz

# V√©rifier les dates vues par ls (colonne date/heure)
ls -l /var/log/myapp/archive/
```

### 2) Cr√©er le script `/etc/cron.weekly/prune_myapp_archives`

> √âditez avec `sudo nano /etc/cron.weekly/prune_myapp_archives`, puis collez le contenu.

#### Contenu du script (√† coller) :

```bash
#!/usr/bin/env bash
set -euo pipefail

ARCHIVE_DIR="/var/log/myapp/archive"
RETENTION_DAYS=28

# 1) Ne rien faire si le dossier n'existe pas
[ -d "$ARCHIVE_DIR" ] || exit 0

# 2) Supprimer les archives plus vieilles que 28 jours
#    -print pour loguer ce qui est supprim√© (visible via syslog/journal)
DELETED="$(find "$ARCHIVE_DIR" -type f -name 'app-*.log.gz' -mtime +$RETENTION_DAYS -print -delete | wc -l || true)"

logger -t myapp.cron.weekly "Pruned $DELETED archive(s) older than $RETENTION_DAYS days from $ARCHIVE_DIR"
```

### 3) Rendre ex√©cutable

```bash
sudo chmod 0755 /etc/cron.weekly/prune_myapp_archives
```

### 4) **D√©clencher tout de suite** (live)

```bash
# Voir les scripts "√©ligibles"
run-parts --test /etc/cron.weekly

# Ex√©cuter maintenant
sudo run-parts --verbose /etc/cron.weekly
```

### 5) V√©rifications

```bash
# Les archives > 28 jours ont disparu, la r√©cente est conserv√©e
ls -l /var/log/myapp/archive/

# Traces dans les journaux
sudo tail -n 5 /var/log/syslog | grep -i myapp.cron.weekly || true
# (ou) sudo journalctl -e | grep -i myapp.cron.weekly
```

### Netoyage

```bash
# 1) V√©rifier ce qui a √©t√© cr√©√© (optionnel)
ls -l /etc/cron.daily/backup_myapp_log /etc/cron.weekly/prune_myapp_archives || true
ls -l /var/log/myapp /var/log/myapp/archive || true

# 2) Supprimer les scripts cron
sudo rm -f /etc/cron.daily/backup_myapp_log
sudo rm -f /etc/cron.weekly/prune_myapp_archives

# 3) Supprimer les logs et archives de l‚Äôappli
sudo rm -rf /var/log/myapp

# 4) Contr√¥le final (optionnel)
run-parts --test /etc/cron.daily | grep -i myapp || true
run-parts --test /etc/cron.weekly | grep -i myapp || true
```

## Points p√©dagogiques cl√©s

- Les **r√©pertoires cron syst√®me** (`/etc/cron.daily`, `/etc/cron.weekly`, etc.) contiennent des scripts ex√©cut√©s √† la fr√©quence correspondante (selon la distro), **sans √©diter la crontab utilisateur**.

- En **d√©mo live**, on **d√©clenche imm√©diatement** via `run-parts` pour v√©rifier le comportement **sans attendre**.

- **Bonnes pratiques** : noms de scripts **compatibles run-parts** (pas de point dans le nom), chemins **absolus**, `set -euo pipefail`, `logger` pour audit, permissions 0755 c√¥t√© `/etc/cron.*` et 0640 c√¥t√© log.

- S√©paration des responsabilit√©s : **daily ‚Üí rotation/archivage**, **weekly ‚Üí purge** (r√©tention). C‚Äôest un pattern r√©aliste en prod.

# D√©mo 8 ‚Äî Planifier une action unique avec `at` (archivage + checksum imm√©diat)

## Objectif (cas r√©el)

Simuler une t√¢che ponctuelle ¬´ post-op√©ration ¬ª : **archiver un r√©pertoire de travail et produire un checksum puis journaliser**, d√©clench√© **une seule fois** dans ~1 minute via `at`. On verra aussi **lister** (`atq`), **annuler** (`atrm`), et **contr√¥ler l‚Äôacc√®s** via `/etc/at.allow` et `/etc/at.deny`.  
R√©f√©rences : syntaxe de `at`, commandes `atq`/`atrm`, et contr√¥le d‚Äôacc√®s par fichiers allow/deny sont explicit√©s dans le document fourni.

---

## Pr√©-requis

```bash
# Installer l‚Äôoutil et s‚Äôassurer que le d√©mon "atd" est actif
sudo apt update && sudo apt install -y at
sudo systemctl enable --now atd
sudo systemctl status atd --no-pager
```

> `at` ex√©cute les commandes avec **/bin/sh** (message d‚Äôavertissement visible √† l‚Äôinvite), et s‚Äôemploie pour une **t√¢che unique √† un instant donn√©**.

---

## √âtape A ‚Äî Pr√©parer l‚Äôatelier (r√©pertoire & fichiers)

```bash
# 1) Dossier de travail
mkdir -p /tmp/at_demo/work

# 2) G√©n√©rer quelques fichiers ‚Äúr√©sidus‚Äù √† archiver
printf 'alpha\nbeta\ngamma\n'  > /tmp/at_demo/work/data1.txt
printf 'log line 1\nlog line 2\n' > /tmp/at_demo/work/app.log
```

---

## √âtape B ‚Äî Cr√©er le script d‚Äôarchivage √† ex√©cuter par `at`

**Chemin du fichier** : `/usr/local/bin/archive_and_verify.sh` (chemin **absolu** recommand√© pour √©viter les soucis d‚Äôenvironnement).  
Cr√©ez le fichier avec votre √©diteur (nano/vim), puis collez **exactement** le contenu ci-dessous ; enregistrez, fermez, puis rendez-le ex√©cutable.

```bash
sudo nano /usr/local/bin/archive_and_verify.sh
sudo chmod +x /usr/local/bin/archive_and_verify.sh
```

**Contenu de `/usr/local/bin/archive_and_verify.sh`** :

```bash
#!/usr/bin/env bash
set -euo pipefail

WORKDIR="/tmp/at_demo/work"
OUTDIR="/tmp/at_demo/out"
LOGFILE="/tmp/at_demo/at_demo.log"

mkdir -p "$OUTDIR"
ts="$(date +'%F_%H-%M-%S')"
archive="$OUTDIR/work_${ts}.tar.gz"
checksum="$archive.sha256"

{
  echo "[$(date +'%F %T')] START: archiving $WORKDIR"
  tar -C "$WORKDIR" -czf "$archive" .
  sha256sum "$archive" > "$checksum"
  echo "[$(date +'%F %T')] DONE: archive=$archive"
  echo "[$(date +'%F %T')] SHA256: $(cut -d' ' -f1 "$checksum")"
} >>"$LOGFILE" 2>&1
```

**Pourquoi ce design ?**

- **Cas r√©el** : on capture un √©tat de travail puis on **trace** l‚Äôop√©ration (journal + int√©grit√©).

- **Robuste** : `set -euo pipefail`, chemins absolus, et sortie vers un log d√©di√©.

- **Instantan√©** : ex√©cution courte (quelques ms) ‚Üí visible d√®s que `at` d√©clenche (‚âà 1 minute).

---

## √âtape C ‚Äî Planifier l‚Äôex√©cution unique (‚âà 1 minute)

Option 1 (invite interactive) :

```bash
at now + 1 minute
# √Ä l'invite "at>", tapez:
# /usr/local/bin/archive_and_verify.sh
# (puis Ctrl+D pour valider)
```

Option 2 (non-interactive, recommand√©) :

```bash
at -f /usr/local/bin/archive_and_verify.sh now + 1 minute
```

**Lister les jobs en file d‚Äôattente** :

```bash
atq
# Affiche un identifiant (job id), l‚Äôheure pr√©vue, et l‚Äôutilisateur
```

**V√©rifier l‚Äôenvironnement** : le message ¬´ warning: commands will be executed using /bin/sh ¬ª rappelle le shell utilis√© par `at`.

---

## √âtape D ‚Äî Observer l‚Äôex√©cution (‚â§ 60 s)

Dans un terminal :

```bash
tail -f /tmp/at_demo/at_demo.log
```

Attendez la minute suivante : vous verrez des entr√©es `START`, `DONE`, et la **SHA256**.  
V√©rifiez les artefacts :

```bash
ls -lh /tmp/at_demo/out/
```

---

## √âtape E ‚Äî Annuler proprement une t√¢che avant son ex√©cution

Planifions une **seconde** ex√©cution puis **annulons-la** :

```bash
# 1) Replanifier pour dans 1 minute
at -f /usr/local/bin/archive_and_verify.sh now + 1 minute

# 2) R√©cup√©rer l‚ÄôID
atq
# Supposons que l'ID affich√© soit 12

# 3) Annuler
atrm 12

# 4) V√©rifier qu'il n'y a plus de job
atq
```

> `atq` liste la file, `atrm <id>` supprime un job : ces commandes font partie du triptyque `at`/`atq`/`atrm` d√©crit dans le document.

---

## √âtape F ‚Äî Contr√¥ler l‚Äôacc√®s avec `/etc/at.allow` et `/etc/at.deny`

Le document pr√©cise le m√©canisme d‚Äôautorisation :

- Si **`/etc/at.allow` existe**, seuls les utilisateurs list√©s **sont autoris√©s** √† utiliser `at`.

- Sinon, si **`/etc/at.deny` existe**, les utilisateurs list√©s **sont interdits** (un `at.deny` vide ‚Üí tous autoris√©s).

- Si **aucun des deux** n‚Äôexiste, le comportement d√©pend de la distribution.

### Exemple 1 ‚Äî Restreindre √† un seul utilisateur (whitelist)

```bash
# Cr√©er un allow "strict" (remplacez $USER par l'utilisateur cible)
echo "$USER" | sudo tee /etc/at.allow
# S'assurer qu'il n'existe pas de deny contradictoire
sudo rm -f /etc/at.deny
```

**Test** : l‚Äôutilisateur pr√©sent dans `at.allow` peut planifier ; un autre non list√© re√ßoit un refus.

### Exemple 2 ‚Äî Interdire un utilisateur (blacklist)

```bash
# Variante : autoriser tout le monde sauf "guest"
echo "guest" | sudo tee /etc/at.deny
sudo rm -f /etc/at.allow
```

**Test** : `guest` ne peut pas utiliser `at`, les autres oui.

> Format attendu : **un nom d‚Äôutilisateur par ligne** dans `at.allow`/`at.deny`.

---

## Nettoyage

```bash
# Supprimer la file (si n√©cessaire, annulez chaque job restant)
atq | awk '{print $1}' | xargs -r atrm

# Retirer les fichiers/dossiers de d√©mo
sudo rm -f /usr/local/bin/archive_and_verify.sh
rm -rf /tmp/at_demo

# (optionnel) Restaurer la config d'acc√®s
# sudo rm -f /etc/at.allow /etc/at.deny
```

---

## Pi√®ges & bonnes pratiques (r√©sum√©)

- **Chemins absolus & PATH** : `at` n‚Äôh√©rite pas toujours de votre environnement interactif ‚Üí **toujours** pointer vers des chemins absolus dans les commandes/scripts.

- **Redirections** : redirigez stdout/stderr **dans le script** (journal d√©di√©) pour √©viter des e-mails ou des sorties silencieuses.

- **S√©curit√© d‚Äôacc√®s** : exploitez `at.allow` / `at.deny` pour cadrer qui peut planifier.

- **Usage pertinent** : r√©servez `at` aux **t√¢ches ponctuelles** (correctifs, archivage, bascule technique‚Ä¶), quand **cron** convient au p√©riodique et les **timers systemd** offrent une alternative int√©gr√©e √† systemd.
