# Atelier complet : Buildah de A à Z

## 1) Contexte & objectif

> **Il faut utiliser Build ah avec root**



**Contexte.** Buildah est un outil CLI focalisé sur **la construction d’images OCI** sans démon, compatible Docker/OCI. Il fonctionne racine (`root`) ou **rootless**. Il manipule deux notions clés :

- **Images** : couches OCI (pull, tag, rmi, inspect, etc.)

- **Working containers** : conteneurs temporaires issus de `buildah from`, que l’on **configure** (`buildah run`, `copy`, `config`…), puis **commit** en image.

**Objectifs pédagogiques.**

- Savoir **gérer** des images (pull, tag, inspect, rmi).

- Savoir **préparer** et **configurer** un working container, exécuter des commandes, commiter en image.

- Utiliser **réseau** et **volumes** lors de `buildah run`.

- Construire des images **de deux façons** :
  
  1. Mode “Dockerfile-like” avec `buildah bud`.
  
  2. Mode “à la main” : `from` → `run`/`copy`/`config` → `commit`.

- Comprendre l’“équivalent Compose” : **Buildah ne lance pas de stacks multi-conteneurs** ; pour **exécuter** on utilise **Podman** (compatible Docker CLI, `podman-compose` ou `podman play kube`).

---

## 2) Préparation de l’environnement

Tests sur **Debian 12** ou **Ubuntu 22.04/24.04**. On privilégie le mode **rootless** pour l’atelier.

### 2.1 Installation (Debian/Ubuntu)

```bash
# Debian 12 / Ubuntu 22.04+ (paquets officiels)
sudo apt update
sudo apt install -y buildah uidmap slirp4netns fuse-overlayfs

# Facultatif mais utile pour la partie "compose"
sudo apt install -y podman
```

Vérifications :

```bash
buildah version
podman --version   # si installé
```

Résultats attendus (exemple) :

- `buildah version` affiche une version 1.xx+

- `podman --version` affiche 4.x/5.x (si installé)

### 2.2 Préparer l’exécution rootless (recommandé)

```bash
# Basculer en session utilisateur normale (non root) pour l’atelier
whoami                # doit être votre user normal
buildah info | grep -E 'rootless|ociRuntime|store'
```

Résultat attendu : une ligne `rootless: true` (ou équivalent) si l’environnement rootless est OK.

---

## 3) Exécution pas à pas (avec explications)

### 3.1 Gestion d’images

#### 3.1.1 Récupérer une image de base

```bash
buildah pull docker.io/library/alpine:3.20
buildah pull docker.io/library/nginx:1.27-alpine
```

**Pourquoi ?** On télécharge des bases populaires (Alpine, Nginx) au format OCI/Docker.  
**Vérification :**

```bash
buildah images
buildah inspect alpine:3.20 | head -n 20
```

Résultats attendus :

- `buildah images` liste `alpine:3.20` et `nginx:1.27-alpine`.

- `buildah inspect` renvoie un JSON (architecture, config, layers).

#### 3.1.2 Taguer / Retagger

```bash
buildah tag alpine:3.20 mylab/alpine:base
buildah images | grep mylab/alpine
```

**Pourquoi ?** Nommer vos variantes pour un flux de build clair.

#### 3.1.3 Supprimer une image

```bash
buildah rmi mylab/alpine:base
```

**Astuce.** Si l’image est référencée par un working container, `rmi` échouera : il faudra supprimer le conteneur d’abord (voir §3.2).

---

### 3.2 Gestion des conteneurs (working containers)

#### 3.2.1 Créer un working container

```bash
# Crée un "conteneur de travail" à partir d'alpine
ctr=$(buildah from alpine:3.20)
echo "$ctr"   # ex: alpine-working-container
```

**Pourquoi ?** Le working container est votre espace de configuration avant création d’une image finale.

#### 3.2.2 Exécuter des commandes dans le working container

```bash
buildah run "$ctr" -- sh -lc 'cat /etc/os-release'
buildah run "$ctr" -- sh -lc 'apk add --no-cache curl'
buildah run "$ctr" -- sh -lc 'curl -s https://example.org | head -n 3'
```

**Pourquoi ?** Tester et installer des paquets dans le filesystem du working container.  
**Résultats attendus :**

- `/etc/os-release` mentionne Alpine.

- `apk` installe `curl`.

- `curl` renvoie du HTML.

#### 3.2.3 Copier des fichiers dans le working container

Créer un petit script de test à embarquer :

Créer le fichier **hello.sh** :

```bash
#!/bin/sh
echo "Hello from inside the container"
```

```bash
chmod +x hello.sh
buildah copy "$ctr" ./hello.sh /usr/local/bin/hello.sh
buildah run "$ctr" -- hello.sh
```

**Résultat attendu :** `Hello from inside the container`.

#### 3.2.4 Configurer l’image (cmd, entrypoint, labels, env, user)

```bash
buildah config --label maintainer="you@example.com" "$ctr"
buildah config --env APP_ENV=prod "$ctr"
buildah config --cmd '["/bin/sh"]' "$ctr"
# exemple entrypoint (optionnel) :
# buildah config --entrypoint '["/usr/local/bin/hello.sh"]' "$ctr"
```

**Pourquoi ?** Définir la configuration finale de l’image (labels, variables, commande par défaut).

#### 3.2.5 Commit → création d’une image

```bash
buildah commit "$ctr" mylab/alpine:hello
buildah images | grep mylab/alpine:hello
```

**Résultat attendu :** une nouvelle image `mylab/alpine:hello`.

#### 3.2.6 Nettoyer le working container

```bash
buildah rm "$ctr"
```

---

### 3.3 Réseau avec `buildah run`

> Buildah peut exécuter des commandes dans le working container avec des **modes réseau** : `--net host|none|slirp4netns|bridge`.  
> En rootless, **`slirp4netns`** est courant.

#### 3.3.1 Tester le réseau

```bash
ctr=$(buildah from alpine:3.20)
buildah run --net slirp4netns "$ctr" -- sh -lc 'apk add --no-cache iputils && ping -c1 1.1.1.1'
```

**Résultat attendu :** 1 paquet transmis/1 reçu.

#### 3.3.2 Mode “sans réseau”

```bash
buildah run --net none "$ctr" -- sh -lc 'wget -qO- https://example.org || echo "No network"'
```

**Résultat attendu :** `No network`.

```bash
buildah rm "$ctr"
```

---

### 3.4 Volumes et montages

Deux cas :

- **Montage éphémère** pendant `buildah run` via `--volume` (bind).

- **Copie** permanente dans l’image via `buildah copy`.

#### 3.4.1 Bind mount pendant `run`

```bash
mkdir -p $PWD/site
echo "<h1>Hi Buildah</h1>" > $PWD/site/index.html

ctr=$(buildah from nginx:1.27-alpine)
# Monter ./site dans /usr/share/nginx/html
buildah run \
  --volume $PWD/site:/usr/share/nginx/html:Z \
  --net slirp4netns \
  "$ctr" -- sh -lc 'ls -l /usr/share/nginx/html && grep -o "Hi Buildah" /usr/share/nginx/html/index.html'
```

**Pourquoi ?** Travailler localement et tester dans le FS du container temporaire **sans** commiter.  
**Résultat attendu :** le listing et la présence du texte.

```bash
buildah rm "$ctr"
```

#### 3.4.2 Copier dans l’image (persistant)

```bash
ctr=$(buildah from nginx:1.27-alpine)
buildah copy "$ctr" $PWD/site/ /usr/share/nginx/html/
buildah commit "$ctr" mylab/nginx:site-v1
buildah rm "$ctr"
buildah inspect mylab/nginx:site-v1 | head -n 20
```

**Résultat attendu :** l’image `mylab/nginx:site-v1` contient le contenu.

---

### 3.5 Création d’images personnalisées

#### 3.5.1 Méthode “Dockerfile-like” : `buildah bud`

Créer le fichier **Containerfile** :

```Dockerfile
FROM alpine:3.20
LABEL maintainer="you@example.com"
RUN apk add --no-cache ca-certificates curl
COPY hello.sh /usr/local/bin/hello.sh
RUN chmod +x /usr/local/bin/hello.sh
ENV APP_ENV=prod
CMD ["/usr/local/bin/hello.sh"]
```

```bash
buildah bud -t mylab/alpine:bud-demo -f Containerfile .
buildah images | grep bud-demo
```

**Résultat attendu :** `mylab/alpine:bud-demo`.

#### 3.5.2 Méthode “manuelle” : from → run/copy/config → commit

```bash
ctr=$(buildah from alpine:3.20)
buildah run "$ctr" -- sh -lc 'apk add --no-cache ca-certificates'
buildah copy "$ctr" ./hello.sh /usr/local/bin/hello.sh
buildah run "$ctr" -- sh -lc 'chmod +x /usr/local/bin/hello.sh'
buildah config --env APP_ENV=prod "$ctr"
buildah config --cmd '["/usr/local/bin/hello.sh"]' "$ctr"
buildah commit "$ctr" mylab/alpine:manual-demo
buildah rm "$ctr"
buildah images | grep manual-demo
```

**Résultat attendu :** `mylab/alpine:manual-demo`.

---

### 3.6 “Équivalent de Docker Compose” : explication + démo

**Point clé.** Buildah **ne lance pas** et **n’orchestrait** pas des stacks multi-conteneurs.

- **Buildah = build** d’images.

- **Podman = run** des conteneurs (CLI compatible Docker).

- Pour “Compose”, on utilisera :
  
  - `podman-compose` (lit un `docker-compose.yml`) **ou**
  
  - `podman play kube` (lit un YAML Kubernetes pour créer un pod).

#### 3.6.1 Démo rapide `podman-compose` (si Podman installé)

Créer le fichier **docker-compose.yml** :

```yaml
version: "3.8"
services:
  web:
    image: docker.io/library/nginx:1.27-alpine
    ports:
      - "8080:80"
    volumes:
      - ./site:/usr/share/nginx/html:Z
  api:
    image: docker.io/library/alpine:3.20
    command: ["sh", "-lc", "while true; do printf 'HTTP/1.1 200 OK\r\n\r\nAPI OK\n' | nc -l -p 5000 -s 0.0.0.0 -v; done"]
    ports:
      - "5000:5000"
```

Lancer :

```bash
# Installer podman-compose si nécessaire (Debian/Ubuntu)
sudo apt install -y podman-compose

# Démarrer la stack en rootless
podman-compose up -d
podman ps --format "table {{.Names}}\t{{.Image}}\t{{.Ports}}"
curl -s localhost:8080 | grep -o "Hi Buildah"   # si ./site contient la page
printf "\n"; echo "----"; nc -vz localhost 5000
```

Arrêter :

```bash
podman-compose down
```

**Résultat attendu :**

- `web` expose `:8080` et sert le contenu de `./site`.

- `api` répond sur `:5000`.

#### 3.6.2 Alternative : `podman play kube`

Créer le fichier **stack.yaml** (Pod avec 2 conteneurs) :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: demo-pod
spec:
  containers:
    - name: web
      image: docker.io/library/nginx:1.27-alpine
      ports:
        - containerPort: 80
      volumeMounts:
        - name: site
          mountPath: /usr/share/nginx/html
    - name: api
      image: docker.io/library/alpine:3.20
      command: ["sh", "-lc", "while true; do printf 'HTTP/1.1 200 OK\r\n\r\nAPI OK\n' | nc -l -p 5000 -s 0.0.0.0 -v; done"]
      ports:
        - containerPort: 5000
  volumes:
    - name: site
      hostPath:
        path: ./site
        type: Directory
```

Exécuter :

```bash
podman play kube stack.yaml
podman pod ps
podman ps --pod
# On peut exposer via port forwarding :
podman port -l   # liste des ports (si non mappés, exposer avec --publish lors de play kube)
```

Nettoyer :

```bash
podman play kube --down stack.yaml
```

---

## 4) Vérifications / Résultats attendus

- `buildah images` liste vos images (`mylab/alpine:hello`, `mylab/alpine:manual-demo`, `mylab/nginx:site-v1`, `mylab/alpine:bud-demo`).

- `buildah inspect <image>` renvoie un JSON cohérent (CMD, ENV, layers).

- `buildah run --net slirp4netns` permet de “ping” externe ; `--net none` bloque le réseau.

- Les bind-mounts via `--volume host:container:Z` sont visibles pendant `run`.

- Les copies via `buildah copy` persistent dans l’image après `commit`.

- Avec Podman :
  
  - `podman-compose up -d` lève les deux services, `curl localhost:8080` renvoie la page, `nc -vz localhost 5000` affiche “succeeded”.
  
  - `podman play kube stack.yaml` crée un pod avec deux conteneurs.

---

## 5) Nettoyage / Rollback

```bash
# Conteneurs/Pods (si Podman a été utilisé)
podman-compose down || true
podman pod rm -f demo-pod || true
podman rm -a -f || true

# Images locales d'atelier
buildah rmi -f mylab/alpine:hello || true
buildah rmi -f mylab/alpine:manual-demo || true
buildah rmi -f mylab/alpine:bud-demo || true
buildah rmi -f mylab/nginx:site-v1 || true

# Images de base (optionnel)
buildah rmi -f alpine:3.20 nginx:1.27-alpine || true

# Dossier de travail
rm -rf site hello.sh Containerfile docker-compose.yml stack.yaml
```

**Rollback d’une image** : si vous versionnez (`mylab/nginx:site-v1`, `site-v2`, etc.), il suffit de **réutiliser l’ancien tag** dans vos déploiements Podman ou votre pipeline.

---

## 6) Conseils & Pièges fréquents

- **Build vs Run.** Buildah **construit** des images ; il **n’est pas** un orchestrateur. Pour exécuter, utilisez **Podman**.

- **Rootless requisites.** Assurez-vous d’avoir `slirp4netns`, `fuse-overlayfs`, `uidmap`. Sans eux, les opérations rootless échouent fréquemment.

- **Modes réseau.** En rootless, `--net slirp4netns` est souvent le plus fiable. `--net none` est pratique pour tester une image “sans accès réseau”.

- **Labels/ENV/CMD.** Centralisez votre logique d’image via `buildah config` (méthode manuelle) ou `Containerfile` (méthode bud).

- **Contexte de build.** `buildah bud` lit le répertoire courant comme contexte, comme `docker build`. Nettoyez vos dossiers (fichiers lourds, `.git`) ou utilisez `.containerignore`.

- **SELinux/AppArmor.** Sur distributions avec SELinux, utilisez le suffixe `:Z` sur les bind-mounts pour relabeling.

- **Compatibilité Docker.** Les images OCI générées par Buildah sont **compatibles Docker/Podman**. Vous pouvez les pousser vers Docker Hub / registries OCI via Podman (`podman login`, `podman push`) ou via `buildah push`.

- **Compose.** Il **n’existe pas d’équivalent Compose natif dans Buildah**. Utilisez `podman-compose` (compose v2-like) **ou** `podman play kube` (YAML Kubernetes).

- **Debug.** `buildah inspect`, `buildah mount` (en root) permet de monter un working container pour inspection poussée ; en rootless, préférez `run` + commandes d’inspection.

---

### Bonus : pousser une image vers un registre (facultatif)

```bash
# Exemple avec Podman (similaire avec buildah push)
podman login docker.io
podman tag mylab/alpine:manual-demo docker.io/<votre_user>/alpine-manual-demo:1.0
podman push docker.io/<votre_user>/alpine-manual-demo:1.0
```

---

Si vous voulez, je peux compléter cet atelier par **un mini “TP corrigé”** :

- V1 : page “Hi Buildah” (déjà fait)

- V2 : page modifiée + rebuild `mylab/nginx:site-v2`

- **Rollback** : repasser de `site-v2` à `site-v1` avec Podman.
