# Atelier 1 : image vs build dans Docker Compose

---

## 1. ğŸ¯ Contexte & Objectif

Cet atelier a pour but de **comparer deux approches** dans un fichier `docker-compose.yml` :

- **Approche 1 : utilisation dâ€™une image standard** (ex. `nginx:latest`)

- **Approche 2 : construction dâ€™une image personnalisÃ©e** Ã  partir dâ€™un `Dockerfile`

Lâ€™objectif est de comprendre :

- Quand utiliser `image:` (image publique ou privÃ©e dÃ©jÃ  prÃªte)

- Quand utiliser `build:` (image Ã  construire localement)

- Comment vÃ©rifier que le comportement diffÃ¨re entre les deux

### Commandes principales

| Commande                 | RÃ´le                                         |
| ------------------------ | -------------------------------------------- |
| `docker compose up -d`   | DÃ©marre tous les services en mode dÃ©tachÃ©    |
| `docker compose ps`      | Liste les conteneurs actifs                  |
| `docker compose logs -f` | Affiche les journaux des services            |
| `docker compose down`    | Stoppe et supprime tous les conteneurs crÃ©Ã©s |

Voici une arborescence claire des **sections principales et secondaires** dâ€™un `docker-compose.yml`, **hors Swarm** (on exclut donc `deploy`, `secrets`, `configs`, etc.)

```bash
docker-compose
â”œâ”€ name                         # (facultatif) Nom explicite du projet Compose
â”œâ”€ services                     # (obligatoire) DÃ©finition des conteneurs
â”‚  â””â”€ <service_name>
â”‚     â”œâ”€ image                  # Image Ã  utiliser (ex: nginx:1.27)
â”‚     â”œâ”€ build                  # Construction dâ€™image
â”‚     â”‚  â”œâ”€ context             # Chemin du contexte (.)
â”‚     â”‚  â”œâ”€ dockerfile          # Dockerfile alternatif
â”‚     â”‚  â”œâ”€ target              # Stage multi-stage
â”‚     â”‚  â”œâ”€ args                # ARG de build (k:v ou liste)
â”‚     â”‚  â”œâ”€ ssh                 # Forward des clÃ©s SSH de build
â”‚     â”‚  â”œâ”€ cache_from          # Sources de cache
â”‚     â”‚  â””â”€ network             # RÃ©seau utilisÃ© pour le build
â”‚     â”œâ”€ container_name         # Nom explicite du conteneur (optionnel)
â”‚     â”œâ”€ command                # Commande (override CMD)
â”‚     â”œâ”€ entrypoint             # Entrypoint (override ENTRYPOINT)
â”‚     â”œâ”€ working_dir            # rÃ©pertoire de travail
â”‚     â”œâ”€ user                   # UID/GID ou user:group
â”‚     â”œâ”€ hostname               # Nom dâ€™hÃ´te
â”‚     â”œâ”€ domainname             # Domaine DNS
â”‚     â”œâ”€ environment            # Variables dâ€™environnement (k:v ou liste)
â”‚     â”œâ”€ env_file               # Fichiers .env additionnels (liste)
â”‚     â”œâ”€ ports                  # Mappages hÃ´te:conteneur (host:container[/proto])
â”‚     â”œâ”€ expose                 # Ports exposÃ©s (inter-services uniquement)
â”‚     â”œâ”€ volumes                # Montages (bind/volume/tmpfs)
â”‚     â”‚  â”œâ”€ <host:container[:ro|rw]>   # syntaxe courte
â”‚     â”‚  â””â”€ type/bind/volume/tmpfs     # syntaxe longue + options
â”‚     â”œâ”€ tmpfs                  # Montages tmpfs (liste ou objets)
â”‚     â”œâ”€ devices                # PÃ©riphÃ©riques pass-through
â”‚     â”œâ”€ ipc                    # Espace IPC (ex: "host")
â”‚     â”œâ”€ pid                    # Espace PID (ex: "host")
â”‚     â”œâ”€ shm_size               # Taille /dev/shm
â”‚     â”œâ”€ ulimits                # Limites (nproc, nofile, etc.)
â”‚     â”œâ”€ pids_limit             # Limite de PIDs
â”‚     â”œâ”€ mem_limit              # Limite mÃ©moire (ex: "512m")
â”‚     â”œâ”€ cpus                   # Limite CPU (ex: "0.50")
â”‚     â”œâ”€ cpu_shares             # Poids CPU relatif
â”‚     â”œâ”€ cpuset                 # AffinitÃ© CPU (ex: "0-1" ou "0,2")
â”‚     â”œâ”€ oom_kill_disable       # DÃ©sactiver OOM killer (bool)
â”‚     â”œâ”€ oom_score_adj          # Ajustement score OOM
â”‚     â”œâ”€ security_opt           # Options sÃ©cu (apparmor, selinux, seccomp=...)
â”‚     â”œâ”€ cap_add                # Ajout de capacitÃ©s Linux
â”‚     â”œâ”€ cap_drop               # Retrait de capacitÃ©s
â”‚     â”œâ”€ privileged             # Mode privilÃ©giÃ© (Ã  Ã©viter si possible)
â”‚     â”œâ”€ sysctls                # sysctl kernel (ex: net.core.somaxconn)
â”‚     â”œâ”€ read_only              # SystÃ¨me de fichiers racine en lecture seule
â”‚     â”œâ”€ restart                # Politique de redÃ©marrage (no, on-failure, always, unless-stopped)
â”‚     â”œâ”€ depends_on             # Ordonnancement + conditions (service_healthy)
â”‚     â”œâ”€ links                  # (legacy) Liaison de noms DNS entre services
â”‚     â”œâ”€ networks               # Attachement aux rÃ©seaux dÃ©finis
â”‚     â”‚  â”œâ”€ <network_name>
â”‚     â”‚  â”‚  â”œâ”€ aliases          # Alias DNS dans ce rÃ©seau
â”‚     â”‚  â”‚  â”œâ”€ ipv4_address     # IP statique v4 (si IPAM le permet)
â”‚     â”‚  â”‚  â””â”€ ipv6_address     # IP statique v6
â”‚     â”œâ”€ dns                    # Serveurs DNS (liste)
â”‚     â”œâ”€ dns_search             # Domaines de recherche DNS (liste)
â”‚     â”œâ”€ extra_hosts            # EntrÃ©es /etc/hosts (ex: "app:10.10.0.10")
â”‚     â”œâ”€ healthcheck            # ContrÃ´le dâ€™Ã©tat
â”‚     â”‚  â”œâ”€ test                # CMD ou liste ["CMD", "curl", ...]
â”‚     â”‚  â”œâ”€ interval            # PÃ©riode (ex: "10s")
â”‚     â”‚  â”œâ”€ timeout             # Timeout (ex: "2s")
â”‚     â”‚  â”œâ”€ retries             # Nombre dâ€™essais
â”‚     â”‚  â””â”€ start_period        # DÃ©lai avant 1er check
â”‚     â”œâ”€ logging                # Logs du conteneur
â”‚     â”‚  â”œâ”€ driver              # ex: "json-file", "local", "syslog", "gelf"
â”‚     â”‚  â””â”€ options             # options du driver (max-size, etc.)
â”‚     â”œâ”€ labels                 # Ã‰tiquettes (k:v)
â”‚     â”œâ”€ profiles               # Profils dâ€™activation conditionnelle
â”‚     â”œâ”€ tty                    # Allouer un pseudo-TTY
â”‚     â”œâ”€ stdin_open             # Garder STDIN ouvert (Ã©quiv. -it)
â”‚     â”œâ”€ stop_signal            # Signal dâ€™arrÃªt (ex: SIGTERM)
â”‚     â””â”€ stop_grace_period      # DÃ©lai dâ€™arrÃªt gracieux (ex: "30s")
â”œâ”€ volumes                      # Volumes nommÃ©s (dÃ©claratifs)
â”‚  â””â”€ <volume_name>
â”‚     â”œâ”€ driver                 # Driver (par dÃ©faut "local")
â”‚     â”œâ”€ driver_opts            # Options du driver
â”‚     â”œâ”€ external               # true | { name: <nom_externe> }
â”‚     â”œâ”€ labels                 # Ã‰tiquettes (k:v)
â”‚     â””â”€ name                   # Nom explicite (si diffÃ©rent de la clÃ©)
â”œâ”€ networks                     # RÃ©seaux dÃ©claratifs
â”‚  â””â”€ <network_name>
â”‚     â”œâ”€ name                   # Nom explicite (diffÃ©rent de la clÃ©)
â”‚     â”œâ”€ driver                 # "bridge" (par dÃ©faut), "host", "none", ...
â”‚     â”œâ”€ enable_ipv6            # Activer IPv6 (bool)
â”‚     â”œâ”€ internal               # Isoler du monde extÃ©rieur (bool)
â”‚     â”œâ”€ external               # true | { name: <nom_externe> }
â”‚     â”œâ”€ labels                 # Ã‰tiquettes (k:v)
â”‚     â”œâ”€ driver_opts            # Options du driver (bridge.* ...)
â”‚     â””â”€ ipam                   # Gestion dâ€™adressage IP
â”‚        â”œâ”€ driver              # Driver IPAM
â”‚        â”œâ”€ options             # Options IPAM
â”‚        â””â”€ config              # Liste de sous-rÃ©seaux
â”‚           â””â”€ - subnet         # ex: "172.25.0.0/16"
â”‚              â”œâ”€ gateway       # ex: "172.25.0.1"
â”‚              â”œâ”€ ip_range      # Plage assignable
â”‚              â””â”€ aux_addresses # Nomsâ†’IP rÃ©servÃ©es
â”œâ”€ labels                       # Labels globaux (au niveau projet)
â”œâ”€ x-<extension>                # Blocs dâ€™extension (ancres/merge YAML)
â””â”€ (version)                    # ClÃ© historique; inutile avec Compose spec
```

## 2. ğŸ§° PrÃ©paration de lâ€™environnement

ExÃ©cuter sur une machine Linux ou VM Debian avec Docker et Docker Compose installÃ©s :

```bash
sudo apt update
sudo apt install -y docker.io docker-compose
sudo systemctl enable --now docker
```

CrÃ©er un rÃ©pertoire de travail :

```bash
mkdir -p ~/atelier-compose-image-vs-build
cd ~/atelier-compose-image-vs-build
```

---

## 3. âš™ï¸ Ã‰tape 1 â€“ Exemple avec image: (standard)

CrÃ©er le fichier **`docker-compose-image.yml`** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:latest   # Utilise l'image officielle depuis Docker Hub
    ports:
      - "8080:80"
    container_name: nginx_image_example
```

### ğŸ” Explications :

- `image: nginx:latest` â†’ Docker va **tÃ©lÃ©charger** lâ€™image depuis Docker Hub.

- Aucun `Dockerfile` nâ€™est nÃ©cessaire.

- Le conteneur expose le port 80 du conteneur sur le port 8080 de la machine hÃ´te.

### â–¶ï¸ DÃ©marrage :

```bash
docker compose -f docker-compose-image.yml up -d
```

### âœ… VÃ©rification :

```bash
curl http://localhost:8080
```

Vous devez voir la **page par dÃ©faut de Nginx**.

---

## 4. âš™ï¸ Ã‰tape 2 â€“ Exemple avec build: (Dockerfile personnalisÃ©)

CrÃ©er le fichier **`Dockerfile`** :

```bash
# CrÃ©er le fichier Dockerfile
FROM nginx:latest
# Copier une page HTML personnalisÃ©e
COPY index.html /usr/share/nginx/html/index.html
```

CrÃ©er le fichier **`index.html`** :

```html
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Page personnalisÃ©e Dockerfile</title>
</head>
<body style="font-family: Arial; text-align: center;">
  <h1>Bonjour depuis une image construite avec Dockerfile !</h1>
</body>
</html>
```

CrÃ©er le fichier **`docker-compose-build.yml`** :

```yaml
version: "3.9"

services:
  web:
    build: .                 # Construit Ã  partir du Dockerfile local
    ports:
      - "8081:80"
    container_name: nginx_build_example
```

### ğŸ” Explications :

- `build: .` â†’ Docker Compose **construit une nouvelle image** Ã  partir du Dockerfile prÃ©sent dans le dossier courant.

- Cette image aura un contenu diffÃ©rent : la page HTML personnalisÃ©e remplace celle de Nginx.

- Le service sera exposÃ© sur le port **8081** pour ne pas entrer en conflit avec lâ€™autre.

### â–¶ï¸ DÃ©marrage :

```bash
docker compose -f docker-compose-build.yml up -d --build
```

### âœ… VÃ©rification :

```bash
curl http://localhost:8081
```

Vous devez voir :

```
Bonjour depuis une image construite avec Dockerfile !
```

## 5. ğŸ§¹ Nettoyage / Rollback

Pour supprimer les conteneurs, images et rÃ©seaux crÃ©Ã©s :

```bash
docker compose -f docker-compose-image.yml down
docker compose -f docker-compose-build.yml down
docker image prune -f
```

---

## 7. ğŸ’¡ Astuces & PiÃ¨ges

- âš ï¸ Si vous combinez `image:` et `build:` sur le **mÃªme service**, Compose construit lâ€™image **puis la tague** avec le nom fourni dans `image:` â€” ce nâ€™est **pas une erreur**, mais il faut savoir ce que vous faites.

- âœ… Bon rÃ©flexe : utilisez `image:` pour les services **externes et stables**, `build:` pour vos **applications personalisÃ©e**.

- ğŸš€ Pour forcer une reconstruction :
  
  ```bash
  docker compose build --no-cache
  ```

## 8. âš™ï¸Combiner build **et** image dans un mÃªme service

## 1) Contexte & objectif

- **Pourquoi** : personnaliser lâ€™image via un `Dockerfile` **et** lui donner un **nom/version** cohÃ©rent (ex. `demo/nginx-custom:1.0`) pour publication ou CI/CD.

- **Ce qui se passe** : `docker compose` **construit** lâ€™image (clÃ© `build:`), puis **lâ€™Ã©tiquette** avec `image:`. Ce nâ€™est **pas interdit** et câ€™est une pratique courante.

## 2) PrÃ©paration

Assurez-vous dâ€™avoir Docker et Compose prÃªts, et placez-vous dans votre dossier dâ€™atelier (ex. `~/atelier-compose-image-vs-build`).

## 3) CrÃ©ation des fichiers

CrÃ©er le fichier **index.html** :

```bash
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Nginx personnalisÃ© â€” build + image</title>
</head>
<body style="font-family: Arial; text-align: center;">
  <h1>Nginx personnalisÃ© (build) avec un tag d'image (image: demo/nginx-custom:1.0)</h1>
  <p>Cette page provient d'une image construite localement puis Ã©tiquetÃ©e.</p>
</body>
</html>
```

CrÃ©er le fichier **Dockerfile** :

```bash
# Image de base officielle Nginx
FROM nginx:latest
# Copier une page HTML personnalisÃ©e dans le document root par dÃ©faut de Nginx
COPY index.html /usr/share/nginx/html/index.html
```

CrÃ©er le fichier **docker-compose.yml** :

```yaml
version: "3.9"

services:
  web:
    # 1) build = construction Ã  partir du Dockerfile local
    build: .

    # 2) image = nom/Ã©tiquette (tag) final de l'image construite
    image: demo/nginx-custom:1.0

    # Publication du service en local
    ports:
      - "8082:80"

    # Nom explicite du conteneur (optionnel mais pratique)
    container_name: nginx_build_and_image_example

    # Variable d'environnement illustrative (optionnelle)
    environment:
      - NGINX_ENV=demo-build-image
```

## 4) ExÃ©cution & vÃ©rifications

Construire et dÃ©marrer :

```bash
docker compose up -d --build
```

VÃ©rifier lâ€™image construite et **taguÃ©e** :

```bash
docker images | grep -E 'demo/nginx-custom|REPOSITORY|TAG'
```

RÃ©sultat attendu (exemple) :

```
REPOSITORY            TAG       IMAGE ID       CREATED          SIZE
demo/nginx-custom     1.0       a1b2c3d4e5f6   <il y a  X sec>  187MB
```

VÃ©rifier le conteneur :

```bash
docker compose ps
```

VÃ©rifier la page servie :

```bash
curl -s http://localhost:8082 | head -n 5
```

Vous devez voir le HTML mentionnant **image: demo/nginx-custom:1.0**.

### Rebuild aprÃ¨s modification (cache)

Modifiez le `<h1>` dans `index.html`, puis :

```bash
docker compose build
docker compose up -d
curl -s http://localhost:8082 | head -n 5
```

Vous constatez la **mise Ã  jour**.

## 5) Nettoyage / rollback

```bash
docker compose down
docker rmi demo/nginx-custom:1.0 || true
```

## 6) Astuces & piÃ¨ges

- `build` **+** `image` dans le **mÃªme service** = **valide** : Compose **construit** puis **tague** lâ€™image.

- Pensez Ã  `.dockerignore` pour accÃ©lÃ©rer les builds.

- PrÃ©fÃ©rez des tags **versionnÃ©s** (Ã©vitez `latest`) pour la traÃ§abilitÃ©.

- ContrÃ´lez le **contexte** (`build: .`) : sâ€™il est trop large, le build sera lent.

- Publication Ã©ventuelle : `docker login` puis `docker push demo/nginx-custom:1.0`.

---

# ğŸ§‘â€ğŸ« Atelier 2: Comprendre entrypoint et command dans Docker Compose

## 1. ğŸ¯ Contexte & Objectif

Lâ€™objectif de cet atelier est de **comprendre la diffÃ©rence entre `entrypoint` et `command`** dans Docker Compose et dâ€™expÃ©rimenter leur comportement sur un conteneur simple.

Nous allons :

- CrÃ©er une image Ã  partir dâ€™un `Dockerfile` qui dÃ©finit un **ENTRYPOINT** et un **CMD**.

- Modifier ce comportement via `docker-compose.yml` Ã  lâ€™aide des clÃ©s `entrypoint` et `command`.

- Observer les effets sur lâ€™exÃ©cution du conteneur.

---

## 2. ğŸ§° PrÃ©paration de lâ€™environnement

CrÃ©er le rÃ©pertoire de travail :

```bash
mkdir -p ~/atelier-entrypoint-command
cd ~/atelier-entrypoint-command
```

---

## 3. âš™ï¸ Ã‰tape 1 â€“ CrÃ©er une image avec ENTRYPOINT et CMD

CrÃ©er le fichier **Dockerfile** :

```bash
FROM debian:stable-slim

# Installer un petit utilitaire (ping)
RUN apt update && apt install -y iputils-ping && apt clean

# DÃ©finir le point d'entrÃ©e et la commande par dÃ©faut
ENTRYPOINT ["ping"]
CMD ["127.0.0.1"]
```

### Explication :

- `ENTRYPOINT ["ping"]` â†’ dÃ©finit le programme **exÃ©cutable principal** du conteneur.

- `CMD ["127.0.0.1"]` â†’ fournit **les arguments par dÃ©faut** Ã  ce programme.  
  â†’ donc par dÃ©faut, le conteneur exÃ©cutera :
  
  ```bash
  ping 127.0.0.1
  ```

Construire lâ€™image :

```bash
docker build -t ping-demo .
```

Tester directement :

```bash
docker run --rm ping-demo -c 2
```

> âœ… RÃ©sultat attendu :  
> Deux requÃªtes ICMP vers `127.0.0.1` sâ€™affichent.

---

## 4. âš™ï¸ Ã‰tape 2 â€“ Utilisation de command: dans Docker Compose

CrÃ©er le fichier **docker-compose-command.yml** :

```yaml
version: "3.9"

services:
  ping_service:
    image: ping-demo
    command: ["-c", "3", "8.8.8.8"]   # Remplace uniquement CMD, pas ENTRYPOINT
```

### Explication :

- `command:` **remplace le CMD** dÃ©fini dans le Dockerfile, **mais garde lâ€™ENTRYPOINT**.

- Donc ici le conteneur exÃ©cutera :
  
  ```bash
  ping -c 3 8.8.8.8
  ```

DÃ©marrage du service :

```bash
docker compose -f docker-compose-command.yml up
```

> âœ… RÃ©sultat attendu :  
> Le conteneur ping trois fois lâ€™adresse `8.8.8.8` (Google DNS).

ArrÃªter le service :

```bash
docker compose -f docker-compose-command.yml down
```

---

## 5. âš™ï¸ Ã‰tape 3 â€“ Utilisation de `entrypoint:` dans Docker Compose

CrÃ©er le fichier **docker-compose-entrypoint.yml** :

```yaml
version: "3.9"

services:
  ping_service:
    image: ping-demo
    entrypoint: ["echo", "Le point d'entrÃ©e a Ã©tÃ© modifiÃ© !"]
```

### Explication :

- `entrypoint:` **remplace complÃ¨tement** lâ€™ENTRYPOINT du Dockerfile.

- `command:` (ou le CMD dâ€™origine) devient alors **les arguments passÃ©s** Ã  cette nouvelle commande.

- Dans ce cas, Docker exÃ©cutera :
  
  ```bash
  echo Le point d'entrÃ©e a Ã©tÃ© modifiÃ© !
  ```

DÃ©marrage :

```bash
docker compose -f docker-compose-entrypoint.yml up
```

> âœ… RÃ©sultat attendu :  
> Le conteneur affiche simplement :
> 
> ```
> Le point d'entrÃ©e a Ã©tÃ© modifiÃ© !
> ```
> 
> puis sâ€™arrÃªte.

---

## 6. âš™ï¸ Ã‰tape 4 â€“ Combiner entrypoint: et command: dans Docker Compose

CrÃ©er le fichier **docker-compose-both.yml** :

```yaml
version: "3.9"

services:
  ping_service:
    image: ping-demo
    entrypoint: ["ping"]
    command: ["-c", "2", "1.1.1.1"]
```

### Explication :

- Ici, **les deux** sont redÃ©finis.

- `entrypoint:` â†’ redÃ©finit le binaire Ã  exÃ©cuter.

- `command:` â†’ redÃ©finit ses arguments.

RÃ©sultat final exÃ©cutÃ© :

```bash
ping -c 2 1.1.1.1
```

DÃ©marrage :

```bash
docker compose -f docker-compose-both.yml up
```

> âœ… RÃ©sultat attendu :  
> Deux paquets ICMP envoyÃ©s vers `1.1.1.1`.

---

## 7. ğŸ§¹ Nettoyage / Rollback

ArrÃªter et supprimer tous les services et images :

```bash
docker compose -f docker-compose-command.yml down
docker compose -f docker-compose-entrypoint.yml down
docker compose -f docker-compose-both.yml down
docker rmi ping-demo
```

## 8. ğŸ’¡ Astuces & PiÃ¨ges

- âš ï¸ `entrypoint` **remplace totalement** lâ€™ENTRYPOINT du Dockerfile â†’ il ne conserve pas lâ€™ancien.

- âš™ï¸ `command` **remplace uniquement CMD** â†’ il sâ€™ajoute Ã  lâ€™ENTRYPOINT existant.

- ğŸ§© Si vous utilisez `entrypoint` dans Compose, vÃ©rifiez bien les arguments attendus : sinon le conteneur peut se bloquer ou quitter immÃ©diatement.

- ğŸ” Pour diagnostiquer le comportement rÃ©el :
  
  ```bash
  docker inspect <nom_du_conteneur> | grep -A 2 Cmd
  ```

# Atelier 3 : Utiliser entrypoint pour lancer un script de dÃ©marrage avant lâ€™application (Docker Compose)

## 1) Contexte & objectif

Mettre en place un **hook de dÃ©marrage** via `entrypoint` qui exÃ©cute un **script Bash** (prÃ©-checks, logs, gÃ©nÃ©ration dâ€™artifacts) avant de lancer lâ€™application. Comprendre :

- `entrypoint` = lance votre script, puis passe la main Ã  lâ€™app.

- `command` (Compose) = remplace le `CMD` (arguments/commande de lâ€™app), **sans toucher** Ã  lâ€™`entrypoint`.

## 2) PrÃ©paration de lâ€™environnement

ExÃ©cuter sur Debian/Ubuntu.

```bash
mkdir -p ~/atelier-entrypoint-startup && cd ~/atelier-entrypoint-startup
```

## 3) CrÃ©ation des fichiers (application Flask + script dâ€™entrÃ©e)

CrÃ©er le fichier **Dockerfile** :

```bash
FROM python:3.12-slim
# Dossier de travail
WORKDIR /app
# Copier sources
COPY app.py /app/app.py
COPY entrypoint.sh /app/entrypoint.sh
# DÃ©pendance minimale pour la dÃ©mo
RUN pip install --no-cache-dir Flask
# Rendre exÃ©cutable lâ€™entrypoint
RUN chmod +x /app/entrypoint.sh
# DÃ©finir ENTRYPOINT (hook) et CMD (commande par dÃ©faut de lâ€™app)
ENTRYPOINT ["/app/entrypoint.sh"]
CMD ["python", "app.py"]
```

CrÃ©er le fichier **entrypoint.sh** :

```bash
#!/usr/bin/env bash
# Script dâ€™entrÃ©e : prÃ©pare lâ€™environnement puis lance lâ€™app
set -euo pipefail  # exit on error, undefined var, and pipefail pour fiabilitÃ©

# 1) Journalisation de dÃ©marrage
echo "[ENTRYPOINT] DÃ©marrage du conteneur Ã  $(date '+%F %T')"

# 2) Lire variables dâ€™environnement (avec valeurs par dÃ©faut)
APP_MESSAGE="${APP_MESSAGE:-Bonjour depuis Flask via ENTRYPOINT !}"
APP_HOST="${APP_HOST:-0.0.0.0}"
APP_PORT="${APP_PORT:-8000}"
echo "[ENTRYPOINT] Variables: APP_MESSAGE='${APP_MESSAGE}', APP_HOST='${APP_HOST}', APP_PORT='${APP_PORT}'"

# 3) GÃ©nÃ©rer un petit artifact prouvant le passage du hook
BOOT_DIR="/app/boot-artifacts"
mkdir -p "${BOOT_DIR}"
echo "Boot OK Ã  $(date '+%F %T')" > "${BOOT_DIR}/startup.ok"
echo "[ENTRYPOINT] Artifact gÃ©nÃ©rÃ©: ${BOOT_DIR}/startup.ok"

# 4) (Optionnel) Attendre un service externe (DB, APIâ€¦) â€“ exemple dÃ©sactivÃ©
# sleep 0.5

# 5) Exporter pour lâ€™app
export APP_MESSAGE APP_HOST APP_PORT

# 6) Lancer lâ€™application (remplace le PID 1) en transmettant la commande/arguments
echo "[ENTRYPOINT] Lancement de l'application: $*"
exec "$@"
```

CrÃ©er le fichier **app.py** :

```bash
from flask import Flask
import os

app = Flask(__name__)

@app.get("/")
def hello():
    # Message injectÃ© via variables d'environnement (setup par l'entrypoint)
    message = os.getenv("APP_MESSAGE", "Bonjour !")
    return f"<h1>{message}</h1>"

if __name__ == "__main__":
    host = os.getenv("APP_HOST", "0.0.0.0")
    port = int(os.getenv("APP_PORT", "8000"))
    app.run(host=host, port=port, debug=False)
```

## 4) Fichier Docker Compose (avec entrypoint + command)

CrÃ©er le fichier **docker-compose.yml** :

```bash
version: "3.9"

services:
  web:
    build: .
    # entrypoint dÃ©jÃ  prÃ©sent dans l'image -> on ne le redÃ©finit pas ici
    command: ["python", "app.py"]    # remplace le CMD du Dockerfile si dÃ©sirÃ©
    environment:
      - APP_MESSAGE=Salut depuis Compose (CMD par dÃ©faut)
      - APP_HOST=0.0.0.0
      - APP_PORT=8080
    ports:
      - "8080:8080"
    # volumes:
    #   - ./artifacts:/app/boot-artifacts  # dÃ©commentez pour observer startup.ok cÃ´tÃ© hÃ´te
```

## 5) ExÃ©cution pas Ã  pas

```bash
docker compose up -d --build   # construit l'image et dÃ©marre le service
docker compose logs -f web     # observe les logs : [ENTRYPOINT] puis Flask
```

VÃ©rification HTTP :

```bash
curl -s http://localhost:8080
# Attendu : <h1>Salut depuis Compose (CMD par dÃ©faut)</h1>
```

## 6) Variation â€” remplacer uniquement la commande (ENTRYPOINT inchangÃ©)

Sans toucher au fichier, lancez avec dâ€™autres paramÃ¨tres :

```bash
docker compose run --rm -p -d 8082:8081 \
  -e APP_MESSAGE="Message dynamique via run" \
  -e APP_PORT=8082 \
  web python app.py

curl -s http://localhost:8082
# Attendu : <h1>Message dynamique via run</h1>
```

## 7) Nettoyage / rollback

```bash
docker compose down -v
docker image prune -f
```

## 8) Astuces & piÃ¨ges

- Utilisez **`exec "$@"`** dans lâ€™entrypoint pour transmettre correctement les signaux au process app (PID 1).

- Lâ€™**entrypoint ne doit pas bloquer** : prÃ©parez, loggez, puis **remettez la main** Ã  lâ€™app.

- **`entrypoint` remplace lâ€™ENTRYPOINT de lâ€™image** si redÃ©fini cÃ´tÃ© Compose ; **`command` remplace le CMD**.

- Diagnostic rapide :
  
  ```bash
  docker compose ps
  docker inspect $(docker compose ps -q web) | grep -A2 -E '"Entrypoint"|"Cmd"'
  ```

Excellent retour ğŸ‘Œ â€” tu as entiÃ¨rement raison.  
On va **reprendre lâ€™atelier 1 (`restart`)** sous **forme de dÃ©marche progressive et expÃ©rimentale**, *cas par cas*, chaque politique testÃ©e sÃ©parÃ©ment,  
avec pour chaque cas :

- Contexte

- Fichiers nÃ©cessaires

- Commandes pas Ã  pas

- RÃ©sultats attendus

- Analyse du comportement

- Nettoyage spÃ©cifique

Ce format correspond exactement au **mode â€œrecette pÃ©dagogique complÃ¨teâ€** que tu demandes.

---

# ğŸ§ª Atelier 1 â€” Politiques `restart` dans Docker Compose (cas par cas)

---

## ğŸ§­ Objectif global

Explorer **comment Docker Compose gÃ¨re le redÃ©marrage automatique** des conteneurs via la directive :

```yaml
restart: <politique>
```

Nous allons tester **4 politiques** indÃ©pendamment :

1. `no`

2. `on-failure`

3. `always`

4. `unless-stopped`

Chaque cas est isolÃ©, reproductible, et inclut sa vÃ©rification.

---

## ğŸ§° PrÃ©paration de lâ€™environnement

Sur une machine Linux (Debian/Ubuntu) :

```bash
sudo apt update
sudo apt install -y docker.io docker-compose
sudo systemctl enable --now docker
```

CrÃ©er un rÃ©pertoire de travail :

```bash
mkdir -p ~/atelier-compose-restart && cd ~/atelier-compose-restart
```

---

# âš™ï¸ CAS 1 â€” `restart: "no"`

### ğŸ¯ Objectif

Observer le comportement **par dÃ©faut** : le conteneur **ne redÃ©marre jamais**, mÃªme en cas dâ€™Ã©chec.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-no.yml** :

```yaml
version: "3.9"

services:
  test_no:
    image: alpine:3.20
    container_name: restart_no_demo
    command: ["/bin/sh", "-c", "echo 'Je sors immÃ©diatement avec succÃ¨s'; exit 0"]
    restart: "no"
```

---

### â–¶ï¸ Ã‰tape 2 â€” ExÃ©cution

```bash
docker compose -f docker-compose-no.yml up -d
```

### ğŸ” Ã‰tape 3 â€” Observation

```bash
docker compose -f docker-compose-no.yml ps
```

RÃ©sultat attendu :

```
NAME               STATE       EXITED
restart_no_demo    exited(0)   il y a quelques secondes
```

VÃ©rifions les logs :

```bash
docker logs restart_no_demo
# Affiche : Je sors immÃ©diatement avec succÃ¨s
```

### ğŸ§  Analyse

- Le conteneur **ne redÃ©marre pas**.

- Lâ€™Ã©tat final est `Exited (0)`.

- `restart: "no"` est **le comportement par dÃ©faut** quand la clÃ© est absente.

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-no.yml down
```

---

# âš™ï¸ CAS 2 â€” `restart: on-failure`

### ğŸ¯ Objectif

Observer que le conteneur redÃ©marre **uniquement** en cas dâ€™erreur (`exit code â‰  0`).

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-onfailure.yml** :

```yaml
version: "3.9"

services:
  test_onfailure:
    image: alpine:3.20
    container_name: restart_onfailure_demo
    command: ["/bin/sh", "-c", "echo 'Je sors avec erreur'; exit 1"]
    restart: on-failure:5
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer le test

```bash
docker compose -f docker-compose-onfailure.yml up -d
```

### ğŸ” Ã‰tape 3 â€” Suivre le comportement

```bash
docker compose -f docker-compose-onfailure.yml ps
```

Attendu :

```
restart_onfailure_demo   Restarting (1) ...   
```

Lance ensuite :

```bash
docker inspect restart_onfailure_demo --format '{{ .RestartCount }}'
```

RÃ©sultat attendu :

```
1 (ou 2 ou plus)
```

### ğŸ§  Analyse

- Le conteneur redÃ©marre **Ã  chaque Ã©chec**.

- `exit 1` dÃ©clenche un redÃ©marrage immÃ©diat.

- Si lâ€™application continue Ã  Ã©chouer, Compose boucle indÃ©finiment.

- En revanche, si lâ€™application finit par `exit 0`, elle **ne redÃ©marrera plus**.

### ğŸ” VÃ©rification manuelle :

```bash
docker logs --tail=5 restart_onfailure_demo
# On verra plusieurs "Je sors avec erreur"
```

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-onfailure.yml down
```

---

# âš™ï¸ CAS 3 â€” `restart: always`

### ğŸ¯ Objectif

Tester un conteneur qui redÃ©marre **quoi quâ€™il arrive** (succÃ¨s, erreur, ou arrÃªt du dÃ©mon Docker).

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-always.yml** :

```yaml
version: "3.9"

services:
  test_always:
    image: alpine:3.20
    container_name: restart_always_demo
    command: ["/bin/sh", "-c", "echo 'Je dors 1s puis je sors'; sleep 1; exit 0"]
    restart: always
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer

```bash
docker compose -f docker-compose-always.yml up -d
```

### ğŸ” Ã‰tape 3 â€” Observer la boucle

```bash
docker compose -f docker-compose-always.yml ps
```

Attendu :

```
restart_always_demo   Restarting (0) ...
```

Suivre les logs :

```bash
docker logs -f restart_always_demo
```

Le message "Je dors 1s puis je sors" se rÃ©pÃ¨te en boucle.

### ğŸ§  Analyse

- Le conteneur redÃ©marre mÃªme avec un **code de sortie 0**.

- MÃªme aprÃ¨s un `docker kill`, Docker le relance.

- Si le dÃ©mon Docker redÃ©marre â†’ ce conteneur **repart automatiquement**.

- Seul `docker stop` suivi de `docker rm` stoppera dÃ©finitivement.

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-always.yml down
```

---

# âš™ï¸ CAS 4 â€” `restart: unless-stopped`

### ğŸ¯ Objectif

Tester un comportement identique Ã  `always`, **sauf si** le conteneur a Ã©tÃ© **arrÃªtÃ© volontairement**.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-unless.yml** :

```yaml
version: "3.9"

services:
  test_unless:
    image: alpine:3.20
    container_name: restart_unless_demo
    command: ["/bin/sh", "-c", "echo 'Je tourne, puis je sors'; sleep 1; exit 0"]
    restart: unless-stopped
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer le service

```bash
docker compose -f docker-compose-unless.yml up -d
```

### ğŸ” Ã‰tape 3 â€” VÃ©rifier le comportement

```bash
docker compose -f docker-compose-unless.yml ps
# Attendu: Restarting (0) ... ou Up (selon le moment)
```

Maintenant arrÃªte le conteneur manuellement :

```bash
docker stop restart_unless_demo
docker compose -f docker-compose-unless.yml ps
```

Attendu :

```
restart_unless_demo   Exited (0)
```

ğŸ‘‰ Il ne redÃ©marre **pas** aprÃ¨s un `stop` manuel.

Si tu redÃ©marres le dÃ©mon Docker (`sudo systemctl restart docker`),  
ce conteneur **ne repartira pas** car il a Ã©tÃ© explicitement stoppÃ©.

---

### ğŸ§  Analyse

- RedÃ©marre comme `always` aprÃ¨s crash ou reboot hÃ´te.

- **Exception** : si stoppÃ© manuellement, il reste arrÃªtÃ©.

- Pratique pour les services persistants, sans redÃ©marrage intempestif aprÃ¨s maintenance manuelle.

---

### ğŸ§¹ Nettoyage global

```bash
docker compose -f docker-compose-unless.yml down
docker image prune -f
```

---

# ğŸ“Š RÃ©sumÃ© comparatif

| Politique        | RedÃ©marre aprÃ¨s crash | RedÃ©marre aprÃ¨s `exit 0` | RedÃ©marre aprÃ¨s `docker restart daemon` | RedÃ©marre aprÃ¨s `docker stop` |
| ---------------- | --------------------- | ------------------------ | --------------------------------------- | ----------------------------- |
| `no`             | âŒ                     | âŒ                        | âŒ                                       | âŒ                             |
| `on-failure`     | âœ… (exitâ‰ 0)            | âŒ                        | âŒ                                       | âŒ                             |
| `always`         | âœ…                     | âœ…                        | âœ…                                       | âœ…                             |
| `unless-stopped` | âœ…                     | âœ…                        | âœ…                                       | âŒ (si stoppÃ© manuellement)    |

---

## ğŸ§  Astuces & piÃ¨ges pÃ©dagogiques

- **Compose ne gÃ¨re pas `on-failure:N`** â†’ la limite dâ€™essais nâ€™existe que dans `docker run`.

- **Ne combinez pas `always` avec des jobs batch** (risque dâ€™exÃ©cution infinie).

- **Production :** prÃ©fÃ©rez `unless-stopped` pour des services persistants (bases, web servers).

- **Debug :** pour des scripts ponctuels ou tests unitaires, laissez `restart: "no"`.

Parfait âš™ï¸  
Nous enchaÃ®nons avec le **ğŸ§ª Atelier 2 â€” `depends_on` vs dÃ©marrage manuel (`--link`) et Ã©quivalents modernes**  
â¡ï¸ toujours en **mode â€œrecette pÃ©dagogique complÃ¨teâ€**, avec expÃ©rimentation progressive.

---

# ğŸ§ª Atelier 2 â€” Orchestration du dÃ©marrage : `depends_on` vs `--link`

---

## 1ï¸âƒ£ Contexte & objectif

Lâ€™objectif de cet atelier est de comprendre :

- ğŸ§© le **rÃ´le de `depends_on`** dans un `docker-compose.yml`

- ğŸ•’ comment il **ordonne le dÃ©marrage** des services

- âš™ï¸ la diffÃ©rence avec lâ€™ancien `--link` (aujourdâ€™hui obsolÃ¨te)

- ğŸš€ la **bonne pratique moderne** : communication via **rÃ©seaux Docker** et **DNS interne**

Nous allons crÃ©er **deux services** :

1. une **base de donnÃ©es MySQL**,

2. une **application web** (client) qui attend que MySQL soit disponible.

---

## 2ï¸âƒ£ PrÃ©paration de lâ€™environnement

Sur votre machine Linux (Debian/Ubuntu) :

```bash
sudo apt update
sudo apt install -y docker.io docker-compose
sudo systemctl enable --now docker
```

CrÃ©er le rÃ©pertoire de travail :

```bash
mkdir -p ~/atelier-compose-depends-on && cd ~/atelier-compose-depends-on
```

---

# âš™ï¸ CAS 1 â€” Sans `depends_on` (erreur de timing)

### ğŸ¯ Objectif

Observer quâ€™un service peut **Ã©chouer au dÃ©marrage** si la base MySQL nâ€™est pas encore prÃªte.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-no-depends.yml** :

```yaml
version: "3.9"

services:
  db:
    image: mysql:8.4
    container_name: db_no_depends
    environment:
      - MYSQL_ROOT_PASSWORD=rootpass
      - MYSQL_DATABASE=testdb

  web:
    image: alpine:3.20
    container_name: web_no_depends
    command: ["/bin/sh", "-c", "sleep 2 && mysql -h db -u root -prootpass -e 'SHOW DATABASES;'"]
    depends_on: []   # volontairement vide (aucun lien)
```

---

### â–¶ï¸ Ã‰tape 2 â€” DÃ©marrage

```bash
docker compose -f docker-compose-no-depends.yml up -d
```

---

### ğŸ” Ã‰tape 3 â€” Observation

Afficher les logs du service web :

```bash
docker logs web_no_depends
```

RÃ©sultat typique :

```
ERROR 2002 (HY000): Can't connect to MySQL server on 'db' (111)
```

### ğŸ§  Analyse

- Le conteneur **web** tente de se connecter Ã  MySQL avant que celui-ci soit prÃªt.

- RÃ©sultat : **Ã©chec immÃ©diat**, lâ€™ordre nâ€™est pas garanti sans `depends_on`.

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-no-depends.yml down -v
```

---

# âš™ï¸ CAS 2 â€” Avec `depends_on`

### ğŸ¯ Objectif

Forcer Docker Compose Ã  **dÃ©marrer la base avant lâ€™application**.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-depends.yml** :

```yaml
version: "3.9"

services:
  db:
    image: mysql:8.4
    container_name: db_with_depends
    environment:
      - MYSQL_ROOT_PASSWORD=rootpass
      - MYSQL_DATABASE=testdb

  web:
    image: alpine:3.20
    container_name: web_with_depends
    depends_on:
      - db
    command: ["/bin/sh", "-c", "sleep 2 && mysql -h db -u root -prootpass -e 'SHOW DATABASES;'"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” DÃ©marrage

```bash
docker compose -f docker-compose-depends.yml up -d
```

---

### ğŸ” Ã‰tape 3 â€” Observation

VÃ©rifier les logs :

```bash
docker logs web_with_depends
```

RÃ©sultat attendu :

```
Database
information_schema
mysql
performance_schema
sys
testdb
```

### ğŸ§  Analyse

- `depends_on` fait bien dÃ©marrer `db` **avant** `web`.

- âš ï¸ Cependant, il **ne garantit pas** que le service MySQL **soit prÃªt**.  
  Il garantit uniquement le **lancement** dans lâ€™ordre.

- Si `db` met trop de temps Ã  initialiser, le mÃªme problÃ¨me peut revenir.

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-depends.yml down -v
```

---

# âš™ï¸ CAS 3 â€” `depends_on.condition: service_healthy` (Compose v3.9+)

### ğŸ¯ Objectif

AmÃ©liorer la fiabilitÃ© en ne lanÃ§ant `web` que **lorsque `db` est rÃ©ellement prÃªt**.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-healthy.yml** :

```yaml
version: "3.9"

services:
  db:
    image: mysql:8.4
    container_name: db_healthy
    environment:
      - MYSQL_ROOT_PASSWORD=rootpass
      - MYSQL_DATABASE=testdb
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 3s
      timeout: 2s
      retries: 5
      start_period: 5s

  web:
    image: alpine:3.20
    container_name: web_after_health
    depends_on:
      db:
        condition: service_healthy
    command: ["/bin/sh", "-c", "mysql -h db -u root -prootpass -e 'SELECT DATABASE();'"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” DÃ©marrage

```bash
docker compose -f docker-compose-healthy.yml up -d
```

---

### ğŸ” Ã‰tape 3 â€” VÃ©rifier lâ€™Ã©tat

```bash
docker compose -f docker-compose-healthy.yml ps
```

Le service `db` doit afficher :

```
healthy
```

VÃ©rifier les logs du web :

```bash
docker logs web_after_health
```

RÃ©sultat attendu :

```
+-------------+
| DATABASE()  |
+-------------+
| testdb      |
+-------------+
```

### ğŸ§  Analyse

- Ici, `depends_on.condition: service_healthy` attend le **signal de santÃ© OK** avant dâ€™exÃ©cuter `web`.

- Ce mÃ©canisme est **le remplaÃ§ant moderne** de `--link`, car Compose gÃ¨re :
  
  - la dÃ©pendance,
  
  - le DNS automatique (`db` rÃ©solu via le rÃ©seau par dÃ©faut),
  
  - et la santÃ©.

---

# âš™ï¸ CAS 4 â€” Comparaison avec `--link` (ancienne mÃ©thode)

### ğŸ¯ Objectif

Montrer pourquoi `--link` nâ€™est plus recommandÃ©.

---

### ğŸ§© Ã‰tape 1 â€” Exemple manuel

Sans Compose, essayons avec `docker run` :

```bash
docker run -d --name old_db -e MYSQL_ROOT_PASSWORD=rootpass mysql:8.4
docker run --rm --name old_web --link old_db:mysql alpine:3.20 \
  sh -c "apk add mysql-client -q && mysql -h mysql -uroot -prootpass -e 'SHOW DATABASES;'"
```

RÃ©sultat :

```
ERROR 2002 (HY000): Can't connect to MySQL server on 'mysql' (111)
```

---

### ğŸ§  Analyse

- `--link` crÃ©ait un alias DNS interne figÃ©, sans attendre que le conteneur soit prÃªt.

- Il ne fonctionne pas avec les rÃ©seaux personnalisÃ©s modernes (`bridge`, `overlay`).

- âš ï¸ Cette option est **dÃ©prÃ©ciÃ©e** depuis Docker 1.13.

- Les bonnes pratiques actuelles :
  
  - utiliser `depends_on` ;
  
  - ajouter un `healthcheck` ;
  
  - utiliser des **rÃ©seaux dÃ©clarÃ©s** (nous le verrons Ã  lâ€™atelier 6).

---

# ğŸ§¹ Nettoyage global

```bash
docker compose -f docker-compose-healthy.yml down -v
docker rm -f old_db || true
```

---

# ğŸ“Š RÃ©sumÃ© pÃ©dagogique

| MÃ©thode                                 | Fonction                      | Garantit ordre | Garantit â€œreadyâ€ | RecommandÃ©e ? |
| --------------------------------------- | ----------------------------- | -------------- | ---------------- | ------------- |
| Aucun lien                              | Services dÃ©marrent sans ordre | âŒ              | âŒ                | âŒ             |
| `depends_on` simple                     | Lance dans lâ€™ordre            | âœ…              | âŒ                | âš ï¸            |
| `depends_on.condition: service_healthy` | Attente rÃ©elle de santÃ©       | âœ…              | âœ…                | âœ…             |
| `--link` (legacy)                       | Lien statique de conteneurs   | partiel        | âŒ                | âŒ (obsolÃ¨te)  |

---

# ğŸ’¡ Astuces & bonnes pratiques

- âœ… **Ajoutez toujours un `healthcheck`** pour vos bases et API.

- âœ… **PrÃ©fÃ©rez `depends_on.condition: service_healthy`** pour fiabilitÃ©.

- âš ï¸ **Ne pas confondre** â€œordre de lancementâ€ (Compose) et â€œdÃ©pendance rÃ©seauâ€ (rÃ©seau Docker).

- ğŸ’¡ Compose crÃ©e **un DNS automatique** par nom de service (ex. `db` â†’ IP du conteneur).

- âŒ **Ã‰vitez `--link`** : non maintenu, non compatible Swarm ou rÃ©seaux modernes.

# ğŸ§ª Atelier 3 â€” Variables dâ€™environnement : `environment` vs `env_file`

---

## 1ï¸âƒ£ Contexte & Objectif

Dans Compose, il existe **deux mÃ©thodes principales** :

| MÃ©thode        | Description                                                         | Cas dâ€™usage                                       |
| -------------- | ------------------------------------------------------------------- | ------------------------------------------------- |
| `environment:` | Variables directement Ã©crites dans le fichier `docker-compose.yml`. | Valeurs simples, visibles immÃ©diatement.          |
| `env_file:`    | Variables externalisÃ©es dans un fichier `.env`.                     | SÃ©paration des secrets, meilleure maintenabilitÃ©. |

---

## 2ï¸âƒ£ PrÃ©paration de lâ€™environnement

CrÃ©er le rÃ©pertoire de travail :

```bash
mkdir -p ~/atelier-compose-env && cd ~/atelier-compose-env
```

---

# âš™ï¸ CAS 1 â€” Utilisation directe de `environment:`

### ğŸ¯ Objectif

DÃ©finir des variables dâ€™environnement **en clair** dans le fichier Compose et les visualiser Ã  lâ€™intÃ©rieur du conteneur.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er le fichier **docker-compose-environment.yml** :

```yaml
version: "3.9"

services:
  app_env:
    image: alpine:3.20
    container_name: demo_environment
    command: ["sh", "-c", "echo 'ğŸ§© Variables internes:'; env | sort"]
    environment:
      - APP_NAME=ComposeDemo
      - APP_ENV=development
      - APP_PORT=8080
      - DEBUG=true
      - DATABASE_URL=mysql://root:pass@db:3306/demo
```

#### ğŸ’¡ Explication ligne par ligne :

- `image: alpine:3.20` â†’ image lÃ©gÃ¨re Linux, idÃ©ale pour inspection.

- `command:` â†’ commande Ã  exÃ©cuter au dÃ©marrage.  
  On affiche toutes les variables (`env | sort`) triÃ©es alphabÃ©tiquement pour lisibilitÃ©.

- `environment:` â†’ liste clÃ©=valeur injectÃ©e directement dans le conteneur.

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer le service

```bash
docker compose -f docker-compose-environment.yml up
```

> âš™ï¸ Le conteneur va exÃ©cuter la commande `env | sort` puis sâ€™arrÃªter.

---

### ğŸ” Ã‰tape 3 â€” Observer la sortie

Sortie attendue Ã  lâ€™Ã©cran :

```
ğŸ§© Variables internes:
APP_ENV=development
APP_NAME=ComposeDemo
APP_PORT=8080
DATABASE_URL=mysql://root:pass@db:3306/demo
DEBUG=true
HOSTNAME=demo_environment
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
PWD=/
SHLVL=1
```

---

### ğŸ§  Analyse

- Les variables dÃ©finies sous `environment:` sont **visibles dans le conteneur** via `env`.

- Elles sont **persistantes uniquement pendant la durÃ©e du conteneur**.

- Il est **dangereux** dâ€™y placer des secrets (ex: mots de passe, API key) car elles sont visibles via :
  
  ```bash
  docker inspect demo_environment
  ```

- Avantage : rapiditÃ©, clartÃ© dans le fichier Compose.

- InconvÃ©nient : risque de fuite dâ€™informations sensibles.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-environment.yml down
```

---

# âš™ï¸ CAS 2 â€” Utilisation de `env_file:`

### ğŸ¯ Objectif

SÃ©parer la configuration dans un fichier `.env` externe.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier `.env`

CrÃ©er le fichier **.env.app** :

```bash
APP_NAME=EnvFileDemo
APP_ENV=production
APP_PORT=9090
DEBUG=false
DATABASE_URL=postgres://admin:secret@db:5432/prod
```

---

### ğŸ§© Ã‰tape 2 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-envfile.yml** :

```yaml
version: "3.9"

services:
  app_envfile:
    image: alpine:3.20
    container_name: demo_envfile
    command: ["sh", "-c", "echo 'ğŸ“ Variables depuis env_file:'; env | grep -E 'APP_|DEBUG|DATABASE_URL' | sort"]
    env_file:
      - .env.app
```

#### ğŸ’¡ Explication ligne par ligne :

- `env_file:` â†’ Compose lit le fichier `.env.app` et injecte **toutes les variables** quâ€™il contient.

- Chaque ligne `VAR=VALEUR` devient une variable dans le conteneur.

- On utilise `grep` pour nâ€™afficher que les variables dâ€™intÃ©rÃªt.

---

### â–¶ï¸ Ã‰tape 3 â€” Lancer

```bash
docker compose -f docker-compose-envfile.yml up
```

---

### ğŸ” Ã‰tape 4 â€” RÃ©sultat attendu

```
ğŸ“ Variables depuis env_file:
APP_ENV=production
APP_NAME=EnvFileDemo
APP_PORT=9090
DATABASE_URL=postgres://admin:secret@db:5432/prod
DEBUG=false
```

---

### ğŸ§  Analyse

- Les variables viennent **du fichier `.env.app`** sans Ãªtre Ã©crites dans le YAML.

- Si vous modifiez `.env.app` et relancez `docker compose up`, les valeurs changent automatiquement.

- Vous pouvez dÃ©finir **plusieurs fichiers** avec :
  
  ```yaml
  env_file:
    - .env.common
    - .env.prod
  ```
  
  â†’ le dernier fichier Ã©crase les variables prÃ©cÃ©dentes sâ€™il y a conflit.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-envfile.yml down
```

---

# âš™ï¸ CAS 3 â€” Combinaison `environment` + `env_file`

### ğŸ¯ Objectif

VÃ©rifier la **prioritÃ©** lorsque la mÃªme variable existe dans les deux endroits.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er les fichiers

CrÃ©er **.env.combined** :

```bash
APP_NAME=FromEnvFile
DEBUG=false
LOG_LEVEL=info
```

CrÃ©er **docker-compose-combined.yml** :

```yaml
version: "3.9"

services:
  app_combined:
    image: alpine:3.20
    container_name: demo_combined
    env_file:
      - .env.combined
    environment:
      - APP_NAME=FromEnvironment
      - DEBUG=true
      - EXTRA=from_compose
    command: ["sh", "-c", "echo 'ğŸ”„ PrioritÃ©s:'; env | grep -E 'APP_|DEBUG|LOG_|EXTRA' | sort"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” ExÃ©cution

```bash
docker compose -f docker-compose-combined.yml up
```

---

### ğŸ” Ã‰tape 3 â€” RÃ©sultat attendu

```
ğŸ”„ PrioritÃ©s:
APP_NAME=FromEnvironment
DEBUG=true
EXTRA=from_compose
LOG_LEVEL=info
```

---

### ğŸ§  Analyse

| Source                                                     | PrioritÃ©               | Exemple                              |
| ---------------------------------------------------------- | ---------------------- | ------------------------------------ |
| `environment:` (dans le YAML)                              | ğŸ”º plus haute          | `APP_NAME` vient dâ€™ici               |
| `env_file:`                                                | ğŸ”» plus basse          | `LOG_LEVEL` vient du `.env.combined` |
| Variables dÃ©finies dans le shell avant `docker compose up` | ğŸ”ºğŸ”º prioritÃ© maximale | `$ export VAR=value` avant exÃ©cution |

**Ordre de rÃ©solution finale :**

1. Variables du **shell courant** (exportÃ©es via `export VAR=value`)

2. Variables de `environment:`

3. Variables des `env_file:`

4. Variables globales du `.env` racine du projet

---

# âš™ï¸ CAS 4 â€” Substitution de variables dans Compose

### ğŸ¯ Objectif

Montrer comment **injecter des variables systÃ¨me** dans le fichier YAML via `${}`.

---

### ğŸ§© Ã‰tape 1 â€” Exporter une variable systÃ¨me

```bash
export APP_VERSION=1.0.7
```

---

### ğŸ§© Ã‰tape 2 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-substitution.yml** :

```yaml
version: "3.9"

services:
  app_subst:
    image: alpine:3.20
    container_name: demo_subst
    command: ["sh", "-c", "echo 'ğŸ”§ Version injectÃ©e: ${APP_VERSION}'"]
```

---

### â–¶ï¸ Ã‰tape 3 â€” ExÃ©cution

```bash
docker compose -f docker-compose-substitution.yml up
```

RÃ©sultat attendu :

```
ğŸ”§ Version injectÃ©e: 1.0.7
```

---

### ğŸ§  Analyse

- Docker Compose remplace `${APP_VERSION}` par la valeur du **shell courant**.

- Si la variable est absente, on peut dÃ©finir une valeur par dÃ©faut :
  
  ```yaml
  command: ["sh", "-c", "echo Version: ${APP_VERSION:-default}"]
  ```

- Cela permet de rendre les Compose files **dynamiques et portables** entre environnements.

---

# ğŸ“Š RÃ©sumÃ© comparatif

| Aspect             | `environment:`         | `env_file:`            | Substitution `${VAR}`                 |
| ------------------ | ---------------------- | ---------------------- | ------------------------------------- |
| Lieu de dÃ©finition | dans le YAML           | fichier externe `.env` | variable systÃ¨me ou .env global       |
| VisibilitÃ©         | immÃ©diate dans le YAML | masquÃ©e (sÃ©curitÃ©)     | dÃ©pend du shell                       |
| PrioritÃ©           | moyenne                | basse                  | haute                                 |
| Cas dâ€™usage        | configuration rapide   | secrets, multi-env     | pipeline CI/CD, paramÃ©trage dynamique |

---

# ğŸ’¡ Bonnes pratiques

âœ… **Structure recommandÃ©e :**

```
project/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ .env              # variables globales
â”œâ”€â”€ .env.dev
â”œâ”€â”€ .env.prod
```

âœ… **Utilisez `.env`** pour les valeurs globales (`APP_NAME`, `TAG`, etc.)  
âœ… **Utilisez `env_file:`** dans chaque service pour ses paramÃ¨tres spÃ©cifiques (DB, API).  
âœ… **Ne stockez jamais** de secrets rÃ©els dans `environment:` si le fichier est versionnÃ©.  
âœ… **Combinez substitution + env_file** pour plus de flexibilitÃ© :

```yaml
image: "myapp:${APP_VERSION:-latest}"
```

---

# ğŸ§¹ Nettoyage global

```bash
docker compose -f docker-compose-environment.yml down
docker compose -f docker-compose-envfile.yml down
docker compose -f docker-compose-combined.yml down
docker compose -f docker-compose-substitution.yml down
docker image prune -f
```

Parfait ğŸš€  
On passe donc Ã  lâ€™**ğŸ§ª Atelier 4 â€” `ports` vs `expose`**, avec une **dÃ©marche ultra pÃ©dagogique** (explications ligne par ligne, tests pratiques, sorties rÃ©elles, analyses dÃ©taillÃ©es).  
Cet atelier te permettra de **maÃ®triser la communication rÃ©seau interne/externe** dans Docker Compose.

---

# ğŸ§ª Atelier 4 â€” `ports` vs `expose` (formes simple et composÃ©e)

---

## 1ï¸âƒ£ Contexte & objectif

Dans Docker Compose, la configuration rÃ©seau des conteneurs repose principalement sur deux directives :

- **`ports`** â†’ publication de ports sur la machine **hÃ´te** (extÃ©rieur).

- **`expose`** â†’ exposition **interne** entre services dâ€™un mÃªme rÃ©seau Compose.

## 2ï¸âƒ£ PrÃ©paration de lâ€™environnement

ExÃ©cuter sur ta machine Linux (Debian/Ubuntu) :

```bash
sudo apt update
sudo apt install -y docker.io docker-compose curl
sudo systemctl enable --now docker
```

CrÃ©er un rÃ©pertoire de travail :

```bash
mkdir -p ~/atelier-compose-ports && cd ~/atelier-compose-ports
```

---

# âš™ï¸ CAS 1 â€” `ports:` (forme simple)

### ğŸ¯ Objectif

Publier un port du conteneur vers le systÃ¨me hÃ´te pour y accÃ©der via le navigateur ou `curl`.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-ports-simple.yml** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:1.27
    container_name: demo_ports_simple
    ports:
      - "8080:80"   # <port_hÃ´te>:<port_conteneur>
```

#### ğŸ’¡ Explication ligne par ligne :

- `image: nginx:1.27` â†’ serveur web standard.

- `ports:` â†’ publie le port **80** interne du conteneur sur le port **8080** de ta machine.  
  Cela signifie que tu pourras atteindre le conteneur via **[http://localhost:8080](http://localhost:8080)**.

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer le service

```bash
docker compose -f docker-compose-ports-simple.yml up -d
```

---

### ğŸ” Ã‰tape 3 â€” VÃ©rification externe

Sur la machine **hÃ´te** :

```bash
curl -I http://localhost:8080
```

RÃ©sultat attendu :

```
HTTP/1.1 200 OK
Server: nginx/1.27.0
Content-Type: text/html
```

---

### ğŸ” Ã‰tape 4 â€” VÃ©rification interne

Ouvrir un shell dans le conteneur :

```bash
docker exec -it demo_ports_simple sh
```

Ã€ lâ€™intÃ©rieur :

```bash
ss -ltn
```

RÃ©sultat :

```
State  Recv-Q Send-Q Local Address:Port  Peer Address:Port  Process
LISTEN 0      511    0.0.0.0:80         0.0.0.0:*           
```

â¡ï¸ Nginx Ã©coute sur **port 80** interne.  
Docker fait la redirection **8080 â†’ 80**.

---

### ğŸ§  Analyse

- `ports:` crÃ©e une **NAT (Network Address Translation)** entre lâ€™hÃ´te et le conteneur.

- Accessible depuis **le rÃ©seau local ou Internet**, selon la configuration.

- Chaque publication crÃ©e une **rÃ¨gle iptables** sur lâ€™hÃ´te.

- âš ï¸ Les conteneurs avec `ports:` sont donc **exposÃ©s publiquement** (utile pour tests, risquÃ© en production sans pare-feu).

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-ports-simple.yml down
```

---

# âš™ï¸ CAS 2 â€” `expose:` (rÃ©seau interne uniquement)

### ğŸ¯ Objectif

Tester lâ€™exposition interne entre services **sans publier le port vers lâ€™hÃ´te**.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-expose.yml** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:1.27
    container_name: demo_expose_web
    expose:
      - "80"   # Visible uniquement pour les autres services Compose

  client:
    image: curlimages/curl:8.7.1
    container_name: demo_expose_client
    depends_on:
      - web
    command: ["sh", "-c", "sleep 3 && echo 'Test de connexion interne:' && curl -I http://web:80"]
```

#### ğŸ’¡ Explication ligne par ligne :

- `web` expose le port 80 **dans le rÃ©seau Compose**, mais **pas vers lâ€™extÃ©rieur**.

- `client` utilise **le nom DNS `web`** pour joindre le conteneur `web`.

- `curl -I http://web:80` â†’ fait une requÃªte HTTP interne via le rÃ©seau Compose.

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer

```bash
docker compose -f docker-compose-expose.yml up
```

---

### ğŸ” Ã‰tape 3 â€” Observation de la sortie

RÃ©sultat attendu :

```
Test de connexion interne:
HTTP/1.1 200 OK
Server: nginx/1.27.0
Content-Type: text/html
```

---

### ğŸ” Ã‰tape 4 â€” VÃ©rification depuis lâ€™hÃ´te

Sur lâ€™hÃ´te :

```bash
curl -I http://localhost:80
```

RÃ©sultat attendu :

```
curl: (7) Failed to connect to localhost port 80: Connection refused
```

â¡ï¸ Normal : `expose` **nâ€™ouvre pas le port vers lâ€™extÃ©rieur**.

---

### ğŸ§  Analyse

- `expose:` rend le port **disponible uniquement aux autres services du mÃªme rÃ©seau Compose**.

- Aucun mappage sur la machine hÃ´te.

- TrÃ¨s utile pour :
  
  - microservices internes (API internes, bases de donnÃ©es),
  
  - sÃ©curitÃ© renforcÃ©e (non accessible de lâ€™extÃ©rieur).

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-expose.yml down
```

---

# âš™ï¸ CAS 3 â€” `ports:` (forme composÃ©e / longue)

### ğŸ¯ Objectif

Explorer la **forme dÃ©taillÃ©e** de `ports` (utile pour contrÃ´le fin sur protocole et IP).

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-ports-long.yml** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:1.27
    container_name: demo_ports_long
    ports:
      - target: 80       # Port du conteneur
        published: 9090  # Port hÃ´te
        protocol: tcp    # Protocole (tcp ou udp)
        mode: host       # Mode: host = publication directe sur hÃ´te
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer

```bash
docker compose -f docker-compose-ports-long.yml up -d
```

---

### ğŸ” Ã‰tape 3 â€” VÃ©rification

Sur lâ€™hÃ´te :

```bash
curl -I http://localhost:9090
```

RÃ©sultat attendu :

```
HTTP/1.1 200 OK
Server: nginx/1.27.0
```

---

### ğŸ§  Analyse

- `target:` â†’ port interne du conteneur.

- `published:` â†’ port exposÃ© sur la machine hÃ´te.

- `protocol:` â†’ choix entre `tcp` ou `udp`.

- `mode:`
  
  - `host` = publication sur le rÃ©seau hÃ´te (pas de NAT).
  
  - `ingress` (Swarm uniquement) = load balancing (non applicable ici).

La **forme longue** est utile pour gÃ©nÃ©rer dynamiquement les ports, gÃ©rer plusieurs protocoles ou contrÃ´ler les publications rÃ©seau.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-ports-long.yml down
```

---

# âš™ï¸ CAS 4 â€” Combinaison `ports` + `expose`

### ğŸ¯ Objectif

Utiliser Ã  la fois `expose` pour communication interne et `ports` pour accÃ¨s externe.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-combined.yml** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:1.27
    container_name: demo_ports_expose
    expose:
      - "80"           # AccÃ¨s interne
    ports:
      - "8081:80"      # AccÃ¨s externe
  client:
    image: curlimages/curl:8.7.1
    container_name: demo_ports_expose_client
    depends_on:
      - web
    command: ["sh", "-c", "sleep 2 && echo 'AccÃ¨s interne au service web:' && curl -I http://web:80"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” DÃ©marrage

```bash
docker compose -f docker-compose-combined.yml up
```

---

### ğŸ” Ã‰tape 3 â€” RÃ©sultats

Sortie de `client` :

```
AccÃ¨s interne au service web:
HTTP/1.1 200 OK
Server: nginx/1.27.0
```

Depuis lâ€™hÃ´te :

```bash
curl -I http://localhost:8081
```

RÃ©sultat :

```
HTTP/1.1 200 OK
Server: nginx/1.27.0
```

---

### ğŸ§  Analyse

- `expose` â†’ communication **interne** entre services (`web` â†” `client`).

- `ports` â†’ communication **externe** (hÃ´te â†” conteneur).

- Les deux peuvent coexister : un service visible Ã  la fois en interne et externe.

---

# ğŸ“Š Tableau comparatif rÃ©capitulatif

| Directive              | Port visible depuis            | Visible sur                  | But principal         | Exemple typique                         |
| ---------------------- | ------------------------------ | ---------------------------- | --------------------- | --------------------------------------- |
| `ports`                | machine hÃ´te / Internet        | `localhost:PORT`             | exposition externe    | `ports: - "8080:80"`                    |
| `expose`               | autres services du mÃªme rÃ©seau | pas depuis lâ€™hÃ´te            | communication interne | `expose: - "3306"`                      |
| `ports` (forme longue) | hÃ´te                           | configurable (TCP/UDP, host) | contrÃ´le avancÃ©       | publication sÃ©lective                   |
| `ports` + `expose`     | interne + externe              | les deux                     | service mixte         | web accessible localement et en interne |

---

# ğŸ’¡ Bonnes pratiques

âœ… **Toujours privilÃ©gier `expose` pour les bases de donnÃ©es** (MySQL, Redis, Mongo).  
âœ… **Utiliser `ports` uniquement pour les services publics** (Nginx, API Gateway).  
âœ… **Ã‰viter dâ€™exposer 0.0.0.0 inutilement** sur lâ€™hÃ´te (risque sÃ©curitÃ©).  
âœ… **Utiliser la forme longue** si tu veux gÃ©rer :

- plusieurs ports/protocoles,

- publication conditionnelle,

- configuration rÃ©seau prÃ©cise.

---

# ğŸ§¹ Nettoyage global

```bash
docker compose -f docker-compose-ports-simple.yml down
docker compose -f docker-compose-expose.yml down
docker compose -f docker-compose-ports-long.yml down
docker compose -f docker-compose-combined.yml down
docker image prune -f
```

Excellent ğŸ‘Œ  
Avant de dÃ©marrer lâ€™**Atelier 5 â€” `volumes` avec drivers et options**,  
je vais te prÃ©senter une **introduction structurÃ©e complÃ¨te**, avec une **arborescence hiÃ©rarchique claire** des **drivers de volumes Docker** et de leurs **options**.

Cette partie servira de **prÃ©ambule pÃ©dagogique** Ã  lâ€™atelier (les cas pratiques suivront ensuite un par un, comme tu lâ€™as demandÃ©).

---

# ğŸ§© Introduction â€” Les volumes Docker dans Compose

---

## ğŸ¯ Objectif gÃ©nÃ©ral

Les **volumes Docker** permettent de **stocker les donnÃ©es en dehors du cycle de vie dâ€™un conteneur**.  
Contrairement aux *bind mounts* (`/host/path:/container/path`), ils sont **gÃ©rÃ©s directement par Docker** et peuvent Ãªtre :

- persistants sur lâ€™hÃ´te,

- temporaires (en mÃ©moire),

- ou distants (rÃ©seaux, NFS, etc.) selon le **driver utilisÃ©**.

Dans Docker Compose, la section `volumes:` peut apparaÃ®tre :

- soit au **niveau service** â†’ pour monter un volume dans un conteneur ;

- soit au **niveau racine** â†’ pour **dÃ©finir** ou **configurer** le volume (driver, optionsâ€¦).

---

## ğŸŒ³ Arborescence hiÃ©rarchique des drivers et options

```
volumes
â”œâ”€ <nom_du_volume>
â”‚  â”œâ”€ driver: <type_de_driver>
â”‚  â”‚
â”‚  â”œâ”€ driver_opts:               # options spÃ©cifiques au driver choisi
â”‚  â”‚   â”œâ”€ type=                  # type de systÃ¨me (ex: nfs, tmpfs, btrfs)
â”‚  â”‚   â”œâ”€ device=                # ressource ou chemin associÃ©
â”‚  â”‚   â”œâ”€ o=                     # options de montage (ro, rw, nosuid, etc.)
â”‚  â”‚   â”œâ”€ size=                  # taille max (pour tmpfs, local avec quota)
â”‚  â”‚   â””â”€ ...                    # selon le driver
â”‚  â”‚
â”‚  â”œâ”€ external: <bool/nom>       # indique si le volume est gÃ©rÃ© en dehors du projet Compose
â”‚  â”œâ”€ labels:                    # mÃ©tadonnÃ©es descriptives
â”‚  â””â”€ name:                      # nom explicite (facultatif)
â”‚
â””â”€ drivers disponibles :
    â”œâ”€ local     â†’ par dÃ©faut, stocke les donnÃ©es sur lâ€™hÃ´te Docker
    â”‚   â”œâ”€ +type=none â†’ bind mount classique
    â”‚   â”œâ”€ +type=tmpfs â†’ stockage en RAM
    â”‚   â”œâ”€ +device=/chemin â†’ dossier hÃ´te Ã  monter
    â”‚   â””â”€ +o=bind,ro,rw,uid=...,gid=...
    â”‚
    â”œâ”€ tmpfs     â†’ stockage temporaire en mÃ©moire (perd les donnÃ©es aprÃ¨s redÃ©marrage)
    â”‚   â”œâ”€ +size= (en bytes)
    â”‚   â””â”€ +mode= (permissions UNIX)
    â”‚
    â”œâ”€ nfs       â†’ volume rÃ©seau distant (nÃ©cessite nfs-common)
    â”‚   â”œâ”€ +device=host:/path
    â”‚   â””â”€ +o=nfsvers=4,addr=...,rw,...
    â”‚
    â”œâ”€ smb/cifs  â†’ partage Windows (nÃ©cessite cifs-utils)
    â”‚   â”œâ”€ +device=//<host>/<share>
    â”‚   â””â”€ +o=username=...,password=...
    â”‚
    â”œâ”€ sshfs     â†’ montage via SSH (plugin externe)
    â”‚   â”œâ”€ +device=sshfs@<user>@<host>:<path>
    â”‚   â””â”€ +o=allow_other,IdentityFile=...
    â”‚
    â”œâ”€ vsphere   â†’ stockage VMware (plugin officiel vSphere Docker Volume)
    â”‚
    â”œâ”€ rexray    â†’ plugin multi-cloud (EBS, GCE, Azure)
    â”‚
    â””â”€ autres plugins tiers (netapp, flocker, glusterfs, etc.)
```

---

## ğŸ§  Points-clÃ©s Ã  retenir avant la pratique

| Type de driver | Persistance | Localisation     | Usage typique                 | Exemple                           |
| -------------- | ----------- | ---------------- | ----------------------------- | --------------------------------- |
| `local`        | âœ…           | disque de lâ€™hÃ´te | donnÃ©es classiques (DB, logs) | `/var/lib/docker/volumes/...`     |
| `tmpfs`        | âŒ (RAM)     | mÃ©moire vive     | caches, fichiers temporaires  | RAM limitÃ©e                       |
| `nfs`          | âœ…           | distant (rÃ©seau) | cluster, stockage partagÃ©     | `nfsvers=4,addr=10.10.10.5:/data` |
| `cifs`         | âœ…           | distant (SMB)    | serveurs Windows, NAS         | `//192.168.1.10/share`            |
| `sshfs`        | âœ…           | distant via SSH  | transfert sÃ©curisÃ© distant    | `sshfs@user@host:/data`           |

---

## ğŸ’¬ Types de volumes dans Compose

| Type                      | Syntaxe               | Description                                              |
| ------------------------- | --------------------- | -------------------------------------------------------- |
| **NomÃ© (Docker-managed)** | `data:/var/lib/mysql` | GÃ©rÃ© par Docker, persiste aprÃ¨s suppression du conteneur |
| **Bind mount (local)**    | `./app:/usr/src/app`  | Monte un dossier local de lâ€™hÃ´te                         |
| **Anonymous**             | `/data` sans nom      | CrÃ©Ã© automatiquement (supprimÃ© avec le conteneur)        |
| **Tmpfs**                 | `type: tmpfs`         | En mÃ©moire uniquement                                    |

---

## 

# ğŸ§ª Atelier 5 â€“ Volumes dans Docker Compose (v2, MySQL)

---

## 1ï¸âƒ£ Contexte & Objectif

Les **volumes** assurent la **persistance des donnÃ©es** des conteneurs Docker.  
Ils permettent Ã  une application de conserver ses fichiers (bases de donnÃ©es, logs, etc.) mÃªme si le conteneur est recrÃ©Ã©.

Dans cet atelier, vous apprendrez Ã  :

- CrÃ©er et gÃ©rer diffÃ©rents types de volumes sous Docker Compose.

- Comprendre leurs diffÃ©rences, avantages et limites.

- Manipuler aussi bien des volumes **locaux**, **bind mounts**, **tmpfs** que des volumes **distants (NFS)**.

---

## 2ï¸âƒ£ PrÃ©paration de lâ€™environnement

### ğŸ’» SystÃ¨me

Ubuntu (local, sous VirtualBox)

### ğŸ§° PrÃ©paration

```bash
sudo apt update
sudo apt install -y docker.io docker-compose nfs-common curl
sudo systemctl enable --now docker
mkdir -p ~/atelier-compose-volumes && cd ~/atelier-compose-volumes
```

---

# âš™ï¸ CAS 1 â€” Volume nommÃ© classique (driver `local`)

### ğŸ¯ Objectif

Persister les donnÃ©es MySQL dans un **volume gÃ©rÃ© par Docker**.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er le fichier **docker-compose-volume-named.yml** :

```yaml
version: "3.9"

services:
  mysql:
    image: mysql:8.0
    container_name: mysql_volume_named
    restart: unless-stopped
    environment:
      - MYSQL_ROOT_PASSWORD=rootpass
      - MYSQL_DATABASE=testdb
    volumes:
      - db_data:/var/lib/mysql

volumes:
  db_data:
    driver: local
```

---

### â–¶ï¸ Ã‰tape 2 â€” DÃ©marrage

```bash
docker compose -f docker-compose-volume-named.yml up -d
```

---

### ğŸ” Ã‰tape 3 â€” VÃ©rifications

Lister les volumes :

```bash
docker volume ls
```

Inspecter le volume :

```bash
docker volume inspect atelier-compose-volumes_db_data
```

RÃ©sultat attendu :

```
"Mountpoint": "/var/lib/docker/volumes/atelier-compose-volumes_db_data/_data"
```

Lister le contenu rÃ©el :

```bash
sudo ls /var/lib/docker/volumes/atelier-compose-volumes_db_data/_data
```

---

### ğŸ§  Analyse

- Docker gÃ¨re le volume et lâ€™attache Ã  MySQL.

- MÃªme aprÃ¨s `down`, le volume reste sur le disque.

- Il est rÃ©utilisÃ© si vous refaites `up`.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-volume-named.yml down
docker volume rm atelier-compose-volumes_db_data
```

---

# âš™ï¸ CAS 2 â€” Bind mount (partage dâ€™un dossier local)

### ğŸ¯ Objectif

Monter un rÃ©pertoire local dans un conteneur Nginx pour servir un fichier HTML.

---

### ğŸ§© Ã‰tape 1 â€” PrÃ©parer le rÃ©pertoire hÃ´te

```bash
mkdir -p ~/atelier-compose-volumes/www
echo "<h1>Bonjour depuis la machine hÃ´te !</h1>" > ~/atelier-compose-volumes/www/index.html
```

---

### ğŸ§© Ã‰tape 2 â€” CrÃ©er le fichier Compose

CrÃ©er le fichier **docker-compose-bind.yml** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:1.27
    container_name: nginx_bind_mount
    ports:
      - "8080:80"
    volumes:
      - type: bind
        source: ./www
        target: /usr/share/nginx/html
        read_only: true
```

---

### â–¶ï¸ Ã‰tape 3 â€” DÃ©marrage

```bash
docker compose -f docker-compose-bind.yml up -d
```

---

### ğŸ” Ã‰tape 4 â€” VÃ©rification

Sur lâ€™hÃ´te :

```bash
curl http://localhost:8080
```

RÃ©sultat attendu :

```
<h1>Bonjour depuis la machine hÃ´te !</h1>
```

Modifier le fichier :

```bash
echo "<h1>Version mise Ã  jour !</h1>" > ~/atelier-compose-volumes/www/index.html
curl http://localhost:8080
```

RÃ©sultat attendu : contenu mis Ã  jour instantanÃ©ment.

---

### ğŸ§  Analyse

- **Bind mount** : montage direct dâ€™un rÃ©pertoire local.

- Les modifications sont **immÃ©diatement visibles**.

- `read_only: true` empÃªche lâ€™Ã©criture depuis le conteneur.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-bind.yml down
```

---

# âš™ï¸ CAS 3 â€” Volume temporaire en mÃ©moire (`tmpfs`)

### ğŸ¯ Objectif

Stocker des donnÃ©es temporaires en **RAM** (non persistantes).

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-tmpfs.yml** :

```yaml
version: "3.9"

services:
  app:
    image: alpine:3.20
    container_name: demo_tmpfs
    tmpfs:
      - /cache
    command: ["sh", "-c", "echo 'RAM OK' > /cache/test.txt && cat /cache/test.txt && sleep 5"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer

```bash
docker compose -f docker-compose-tmpfs.yml up
```

---

### ğŸ” Ã‰tape 3 â€” Relancer

```bash
docker compose -f docker-compose-tmpfs.yml up
```

Le fichier `/cache/test.txt` nâ€™existe plus â†’ donnÃ©es perdues Ã  chaque redÃ©marrage.

---

### ğŸ§  Analyse

- `tmpfs` stocke les fichiers en mÃ©moire volatile (`/dev/shm`).

- IdÃ©al pour caches, sessions, donnÃ©es temporaires.

- DisparaÃ®t dÃ¨s que le conteneur sâ€™arrÃªte.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-tmpfs.yml down
```

---

# âš™ï¸ CAS 4 â€” Driver local avec `driver_opts`

### ğŸ¯ Objectif

Monter un dossier spÃ©cifique de lâ€™hÃ´te via `driver_opts`.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le dossier cible

```bash
sudo mkdir -p /tmp/docker-data
sudo chmod 777 /tmp/docker-data
```

---

### ğŸ§© Ã‰tape 2 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-driveropts.yml** :

```yaml
version: "3.9"

services:
  app:
    image: alpine:3.20
    container_name: demo_driver_opts
    command: ["sh", "-c", "echo 'driver_opts test' > /data/test.txt && cat /data/test.txt"]
    volumes:
      - custom_data:/data

volumes:
  custom_data:
    driver: local
    driver_opts:
      type: none
      device: /tmp/docker-data
      o: bind
```

---

### â–¶ï¸ Ã‰tape 3 â€” Lancer

```bash
docker compose -f docker-compose-driveropts.yml up
```

RÃ©sultat :

```
driver_opts test
```

VÃ©rifie sur lâ€™hÃ´te :

```bash
ls /tmp/docker-data
```

â¡ï¸ fichier `test.txt` prÃ©sent.

---

### ğŸ§  Analyse

- `type: none` + `o: bind` = montage direct vers le chemin indiquÃ©.

- Permet un contrÃ´le prÃ©cis du dossier de stockage.

- Utile pour sÃ©parer des environnements dâ€™exÃ©cution.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-driveropts.yml down
sudo rm -rf /tmp/docker-data
```

---

# âš™ï¸ CAS 5 â€” Volume distant NFS (AWS ou LAN)

### ğŸ¯ Objectif

Configurer un **serveur NFS distant** (ex : instance EC2)  
et lâ€™utiliser dans un Docker Compose local.

---

## ğŸ§© Ã‰tape 1 â€” Configuration du serveur NFS (sur AWS Ubuntu)

Sur la machine EC2 distante :

```bash
sudo apt update
sudo apt install -y nfs-kernel-server
sudo mkdir -p /srv/shared
sudo chown nobody:nogroup /srv/shared
echo "Bienvenue depuis NFS AWS" | sudo tee /srv/shared/info.txt
```

Configurer les exports :

```bash
sudo nano /etc/exports
```

Ajouter :

```
/srv/shared  *(rw,sync,no_subtree_check)
```

Recharger :

```bash
sudo exportfs -ra
sudo systemctl restart nfs-kernel-server
```

---

## ğŸ”’ Ã‰tape 2 â€” RÃ¨gles de pare-feu AWS

Dans le **Security Group** associÃ© Ã  ton instance EC2 :  
ouvrir les ports suivants en **TCP et UDP** :

| Port  | Protocole | Description                   |
| ----- | --------- | ----------------------------- |
| 111   | TCP/UDP   | Portmapper                    |
| 2049  | TCP/UDP   | NFSv4 principal               |
| 20048 | TCP/UDP   | Mountd (certains clients NFS) |

> ğŸ”¹ Source : ton IP publique (pas 0.0.0.0/0) pour limiter lâ€™accÃ¨s.

---

## ğŸ§© Ã‰tape 3 â€” Test cÃ´tÃ© client (ta machine Ubuntu)

Remplacer `<IP_AWS>` par lâ€™adresse publique de ton instance.

```bash
sudo mkdir -p /mnt/nfs-test
sudo mount -t nfs -o nfsvers=4,soft <IP_AWS>:/srv/shared /mnt/nfs-test
cat /mnt/nfs-test/info.txt
sudo umount /mnt/nfs-test
```

RÃ©sultat :

```
Bienvenue depuis NFS AWS
```

---

## ğŸ§© Ã‰tape 4 â€” CrÃ©er le fichier Compose NFS

CrÃ©er **docker-compose-nfs.yml** :

```yaml
version: "3.9"

services:
  app:
    image: alpine:3.20
    container_name: demo_volume_nfs
    command: ["sh", "-c", "ls -l /data && cat /data/info.txt"]
    volumes:
      - nfs_data:/data

volumes:
  nfs_data:
    driver: local
    driver_opts:
      type: nfs
      o: addr=<IP_AWS>,nfsvers=4,soft,rw
      device: :/srv/shared
```

### ğŸ“˜ Explication des options

| Option      | RÃ´le                                                                         |
| ----------- | ---------------------------------------------------------------------------- |
| `addr`      | IP du serveur NFS distant                                                    |
| `nfsvers=4` | utilise la version 4 du protocole NFS                                        |
| `soft`      | la commande Ã©choue si le serveur ne rÃ©pond pas (vs `hard` = attente infinie) |
| `rw`        | autorise lecture/Ã©criture                                                    |
| `device`    | chemin exportÃ© par le serveur (`:/srv/shared`)                               |

---

### â–¶ï¸ Ã‰tape 5 â€” Lancer

```bash
docker compose -f docker-compose-nfs.yml up
```

RÃ©sultat attendu :

```
total 4
-rw-r--r-- 1 nobody nogroup 26 Oct 27 15:00 info.txt
Bienvenue depuis NFS AWS
```

---

### ğŸ§  Analyse

- Les donnÃ©es sont hÃ©bergÃ©es sur le **serveur distant**.

- Toute modification dans `/srv/shared` cÃ´tÃ© AWS est visible localement.

- La latence dÃ©pend du rÃ©seau et de la configuration SG.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-nfs.yml down
```

---

# ğŸ“Š RÃ©sumÃ© comparatif

| Cas | Type         | Persistance | Localisation              | Usage typique          |
| --- | ------------ | ----------- | ------------------------- | ---------------------- |
| 1   | Volume nommÃ© | âœ…           | `/var/lib/docker/volumes` | bases de donnÃ©es       |
| 2   | Bind mount   | âœ…           | dossier local             | code source, config    |
| 3   | Tmpfs        | âŒ (RAM)     | mÃ©moire vive              | caches temporaires     |
| 4   | Driver_opts  | âœ…           | dossier choisi            | stockage avancÃ©        |
| 5   | NFS          | âœ…           | serveur distant           | stockage partagÃ© cloud |

---

# ğŸ’¡ Bonnes pratiques

âœ… Toujours utiliser **volumes nommÃ©s** pour les donnÃ©es persistantes Docker.  
âœ… PrivilÃ©gier les **bind mounts** en dÃ©veloppement (code live).  
âœ… Utiliser **tmpfs** pour les fichiers sensibles/Ã©phÃ©mÃ¨res.  
âœ… Sur AWS : restreindre les IP autorisÃ©es aux ports NFS.  
âœ… Sauvegarder les volumes :

```bash
docker run --rm -v db_data:/data alpine tar czf - /data > backup.tar.gz
```

---

# ğŸ§¹ Nettoyage global

```bash
docker compose -f docker-compose-volume-named.yml down -v
docker compose -f docker-compose-bind.yml down -v
docker compose -f docker-compose-tmpfs.yml down -v
docker compose -f docker-compose-driveropts.yml down -v
docker compose -f docker-compose-nfs.yml down -v || true
docker volume prune -f
```

# ğŸŒ Introduction complÃ¨te â€” Les *drivers* et *options* rÃ©seaux dans Docker Compose

---

## ğŸ¯ Objectif

Dans Docker, un **rÃ©seau** (network) dÃ©finit **comment les conteneurs communiquent entre eux** et avec le monde extÃ©rieur.  
Compose permet de **dÃ©finir, configurer et isoler** ces rÃ©seaux avec des **drivers** et des **options avancÃ©es (IPAM, DNS, passerelles, etc.)**.

Nous allons examiner :

1. Les **drivers** de rÃ©seaux disponibles.

2. Les **options configurables** par driver.

3. Lâ€™arborescence logique dâ€™une configuration `networks:` dans un `docker-compose.yml`.

4. Les **implications pratiques** (isolation, connectivitÃ©, performances, sÃ©curitÃ©).

---

## ğŸ§© 1ï¸âƒ£ Arborescence complÃ¨te dâ€™un bloc `networks:` dans Compose

```
networks:
  <nom_du_reseau>:
    driver: <type_driver>
    driver_opts:          # options propres au driver
      com.docker.network.bridge.name: br-demo
      com.docker.network.bridge.enable_icc: "true"
    enable_ipv6: true     # active IPv6
    internal: false       # bloque la sortie vers Internet si true
    external: false       # utilise un rÃ©seau Docker dÃ©jÃ  existant
    attachable: true      # autorise docker run --network=<nom>
    labels:               # mÃ©tadonnÃ©es personnalisÃ©es
      purpose: "test-lab"
    ipam:                 # configuration IP avancÃ©e
      driver: default
      config:
        - subnet: 172.25.0.0/16
          gateway: 172.25.0.1
          ip_range: 172.25.0.0/24
          aux_addresses:
            db: 172.25.0.10
            web: 172.25.0.20
```

---

## ğŸ§  2ï¸âƒ£ Les principaux *drivers rÃ©seau* Docker

| Driver      | Description                                                                     | Usage typique                                                                      |
| ----------- | ------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| **bridge**  | RÃ©seau virtuel local par dÃ©faut. Chaque conteneur reÃ§oit une IP interne isolÃ©e. | Environnements de dÃ©veloppement / dÃ©mo                                             |
| **host**    | Partage directement le rÃ©seau de la machine hÃ´te (pas dâ€™isolation).             | Applications rÃ©seau nÃ©cessitant les ports rÃ©els (serveurs de monitoring, sniffers) |
| **none**    | Aucun rÃ©seau. Pas dâ€™accÃ¨s externe, ni DNS.                                      | Conteneurs totalement isolÃ©s                                                       |
| **overlay** | RÃ©seau distribuÃ© entre plusieurs hÃ´tes Docker (Swarm / multi-node).             | Cluster / haute disponibilitÃ©                                                      |
| **macvlan** | Attribue une vraie adresse MAC au conteneur sur le LAN physique.                | Cas dâ€™intÃ©gration rÃ©seau avancÃ©e (VMs, appliances virtuelles)                      |
| **ipvlan**  | Variante moderne de macvlan avec meilleure performance.                         | RÃ©seaux physiques segmentÃ©s                                                        |

ğŸ‘‰ Pour une machine Ubuntu locale (VirtualBox), **bridge**, **host**, et **none** sont les plus pertinents.

---

## âš™ï¸ 3ï¸âƒ£ Options globales applicables aux rÃ©seaux Docker

| Option        | Valeurs possibles            | RÃ´le                                                               |
| ------------- | ---------------------------- | ------------------------------------------------------------------ |
| `internal`    | `true` / `false`             | Si `true`, les conteneurs **ne peuvent pas sortir vers Internet**. |
| `external`    | `true` / nom rÃ©seau existant | RÃ©utilise un rÃ©seau Docker dÃ©jÃ  crÃ©Ã©.                              |
| `attachable`  | `true`                       | Autorise `docker run` Ã  se rattacher Ã  ce rÃ©seau.                  |
| `enable_ipv6` | `true`                       | Active IPv6 (doit Ãªtre activÃ© dans `/etc/docker/daemon.json`).     |
| `labels`      | `clÃ©:valeur`                 | MÃ©tadonnÃ©es pour documentation ou automation.                      |

---

## âš™ï¸ 4ï¸âƒ£ Options spÃ©cifiques au driver `bridge` (le plus courant)

Ces options se dÃ©finissent dans `driver_opts:` :

| Option                                           | Description                                                             | Exemple             |
| ------------------------------------------------ | ----------------------------------------------------------------------- | ------------------- |
| `com.docker.network.bridge.name`                 | Nom explicite de lâ€™interface rÃ©seau sur lâ€™hÃ´te.                         | `br-demo`           |
| `com.docker.network.bridge.enable_icc`           | Communication inter-conteneurs (Inter Container Communication).         | `"true"` (autorise) |
| `com.docker.network.bridge.enable_ip_masquerade` | Active la translation NAT pour la sortie Internet.                      | `"true"`            |
| `com.docker.network.bridge.host_binding_ipv4`    | Adresse IP sur laquelle Docker publie les ports (`0.0.0.0` par dÃ©faut). | `"127.0.0.1"`       |
| `com.docker.network.bridge.default_bridge`       | DÃ©finit le bridge par dÃ©faut.                                           | `"false"`           |
| `com.docker.network.bridge.gateway`              | Adresse IP de la passerelle du rÃ©seau.                                  | `"172.25.0.1"`      |

---

## âš™ï¸ 5ï¸âƒ£ IPAM â€“ *IP Address Management*

Le bloc `ipam:` permet de contrÃ´ler la **plage dâ€™adresses IP**, la **passerelle**, et les **adresses rÃ©servÃ©es**.

Exemple dâ€™un rÃ©seau personnalisÃ© :

```yaml
networks:
  mynet:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: 172.30.0.0/16
          gateway: 172.30.0.1
          ip_range: 172.30.0.0/24
          aux_addresses:
            dns: 172.30.0.2
            db: 172.30.0.10
```

| ClÃ©             | RÃ´le                                                  |
| --------------- | ----------------------------------------------------- |
| `subnet`        | Plage dâ€™adresses IP du rÃ©seau (CIDR).                 |
| `gateway`       | Adresse IP de la passerelle.                          |
| `ip_range`      | Sous-plage assignable automatiquement aux conteneurs. |
| `aux_addresses` | RÃ©servation dâ€™adresses pour des services prÃ©cis.      |

---

## ğŸ”’ 6ï¸âƒ£ Bonnes pratiques et cas dâ€™usage

| ScÃ©nario                                          | Recommandation                                           |
| ------------------------------------------------- | -------------------------------------------------------- |
| Applications multi-services sur une seule machine | `bridge` avec IPAM personnalisÃ©                          |
| Conteneur unique exposÃ© publiquement              | `host` pour Ã©viter la redirection de ports               |
| Sandbox de sÃ©curitÃ© / tests unitaires             | `none` (aucune sortie rÃ©seau)                            |
| Environnement distribuÃ© (Swarm, Kubernetes)       | `overlay`                                                |
| RÃ©seau dâ€™entreprise avec intÃ©gration LAN          | `macvlan` ou `ipvlan` (si interface physique accessible) |

---

## ğŸ”§ 7ï¸âƒ£ Commandes Docker rÃ©seau utiles

| Commande                                | Description                                            |
| --------------------------------------- | ------------------------------------------------------ |
| `docker network ls`                     | Liste les rÃ©seaux crÃ©Ã©s.                               |
| `docker network inspect <nom>`          | Affiche tous les dÃ©tails (IP, interfaces, containers). |
| `docker network create -d bridge <nom>` | CrÃ©e un rÃ©seau manuellement.                           |
| `docker network rm <nom>`               | Supprime un rÃ©seau.                                    |
| `docker inspect                         | grep -A3 Networks`                                     |

---

## ğŸ’¡ 8ï¸âƒ£ Points Ã  retenir avant la pratique

- Par dÃ©faut, Docker Compose crÃ©e **un rÃ©seau â€œproject_defaultâ€** pour tous les services.

- Chaque service peut appartenir Ã  **plusieurs rÃ©seaux**.

- Tous les conteneurs dans un mÃªme rÃ©seau peuvent **se rÃ©soudre par leur nom DNS** (`ping db`, `curl web:8080`).

- Le rÃ©seau `bridge` natif de Docker (`bridge`) est diffÃ©rent de ceux crÃ©Ã©s par Compose (`<project>_default`).

---

## ğŸ“¦ 9ï¸âƒ£ Drivers additionnels (pour culture DevOps)

| Driver                       | Plugin requis   | Fonction                                  |
| ---------------------------- | --------------- | ----------------------------------------- |
| `macvlan`                    | intÃ©grÃ©         | Fournit une adresse MAC rÃ©elle sur le LAN |
| `ipvlan`                     | intÃ©grÃ©         | Variante plus performante de macvlan      |
| `overlay`                    | intÃ©grÃ© (Swarm) | RÃ©seau multi-nÅ“ud                         |
| `weave`, `flannel`, `calico` | plugin externe  | Solutions SDN pour Kubernetes             |

---

## ğŸ“˜ 10ï¸âƒ£ Exemple synthÃ©tique complet

```yaml
networks:
  my_custom_net:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: br-custom
      com.docker.network.bridge.enable_icc: "true"
      com.docker.network.bridge.enable_ip_masquerade: "true"
    enable_ipv6: false
    internal: false
    ipam:
      config:
        - subnet: 172.28.0.0/16
          gateway: 172.28.0.1
```

1. RÃ©seau *bridge* par dÃ©faut

2. RÃ©seau personnalisÃ© avec IPAM

3. RÃ©seau *internal* (pas dâ€™accÃ¨s Internet)

4. RÃ©seau *host*

5. RÃ©seau *none*

6. Association multi-rÃ©seaux dans un mÃªme Compose

Parfait ğŸ’ª  
On reste donc dans ton environnement **rÃ©aliste et cohÃ©rent** :

> ğŸ–¥ï¸ **Une seule machine Ubuntu** (dans VirtualBox),  
> sans cluster, sans Swarm, sans VLAN physique.
> 
> âš™ï¸ Objectif : comprendre et tester **tous les types de rÃ©seaux Docker disponibles localement** avec Compose.

---

# ğŸ§ª Atelier 6 â€” RÃ©seaux dans Docker Compose (sur machine Ubuntu / VirtualBox)

---

## 1ï¸âƒ£ Contexte & Objectif

Docker crÃ©e par dÃ©faut un rÃ©seau virtuel *bridge* isolÃ© pour chaque projet Compose.  
Mais il est possible de **crÃ©er, nommer et configurer** ses propres rÃ©seaux avec des comportements trÃ¨s diffÃ©rents :

| Cas | Type de rÃ©seau                     | Objectif principal                            |
| --- | ---------------------------------- | --------------------------------------------- |
| 1   | `bridge` (par dÃ©faut)              | Communication entre conteneurs isolÃ©s         |
| 2   | `bridge` personnalisÃ© + IPAM       | ContrÃ´le prÃ©cis de la plage IP                |
| 3   | `internal: true`                   | RÃ©seau privÃ© sans Internet                    |
| 4   | `host`                             | AccÃ¨s direct au rÃ©seau hÃ´te (pas dâ€™isolation) |
| 5   | `none`                             | Conteneur totalement isolÃ©                    |
| 6   | Multi-rÃ©seaux dans un mÃªme Compose | Communication sÃ©lective entre services        |

---

## 2ï¸âƒ£ PrÃ©paration de lâ€™environnement

Sur ta machine Ubuntu (hÃ´te VirtualBox) :

```bash
sudo apt update
sudo apt install -y docker.io docker-compose curl iproute2
sudo systemctl enable --now docker
mkdir -p ~/atelier-compose-networks && cd ~/atelier-compose-networks
```

---

# âš™ï¸ CAS 1 â€” RÃ©seau *bridge* par dÃ©faut

### ğŸ¯ Objectif

DÃ©couvrir le rÃ©seau crÃ©Ã© automatiquement par Compose et tester la communication interne entre services.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-bridge-default.yml** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:1.27
    container_name: demo_bridge_web
    ports:
      - "8080:80"

  client:
    image: curlimages/curl:8.7.1
    container_name: demo_bridge_client
    depends_on:
      - web
    command: ["sh", "-c", "sleep 3 && curl -I http://web:80"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” DÃ©marrer

```bash
docker compose -f docker-compose-bridge-default.yml up
```

RÃ©sultat attendu :

```
HTTP/1.1 200 OK
Server: nginx/1.27.0
```

---

### ğŸ” Ã‰tape 3 â€” VÃ©rifier le rÃ©seau

```bash
docker network ls
```

Tu verras un rÃ©seau du type :

```
NETWORK ID     NAME                              DRIVER
ab12cd34ef56   atelier-compose-networks_default  bridge
```

Inspecte-le :

```bash
docker network inspect atelier-compose-networks_default | grep -A3 "Containers"
```

â¡ï¸ Les deux conteneurs (`web` et `client`) sont connectÃ©s Ã  ce rÃ©seau.

---

### ğŸ§  Analyse

- Le rÃ©seau `*_default` est **crÃ©Ã© automatiquement**.

- Tous les services peuvent communiquer via leur **nom DNS** (`web`, `client`).

- Les ports exposÃ©s (`8080:80`) permettent un accÃ¨s depuis lâ€™hÃ´te Ubuntu.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-bridge-default.yml down
```

---

# âš™ï¸ CAS 2 â€” RÃ©seau *bridge* personnalisÃ© avec IPAM

### ğŸ¯ Objectif

CrÃ©er un rÃ©seau avec un **nom**, une **plage IP spÃ©cifique**, et un **bridge** identifiable.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-bridge-custom.yml** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:1.27
    container_name: demo_bridge_custom_web
    networks:
      - mynet

  client:
    image: curlimages/curl:8.7.1
    container_name: demo_bridge_custom_client
    depends_on:
      - web
    networks:
      - mynet
    command: ["sh", "-c", "sleep 2 && ping -c 2 web"]

networks:
  mynet:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: br-demo
      com.docker.network.bridge.enable_icc: "true"
    ipam:
      driver: default
      config:
        - subnet: 172.25.0.0/16
          gateway: 172.25.0.1
```

---

### â–¶ï¸ Ã‰tape 2 â€” DÃ©marrer

```bash
docker compose -f docker-compose-bridge-custom.yml up
```

RÃ©sultat attendu :

```
PING web (172.25.0.2): 56 data bytes
64 bytes from web: icmp_seq=1 ttl=64 time=0.091 ms
```

---

### ğŸ” Ã‰tape 3 â€” VÃ©rification

Sur lâ€™hÃ´te :

```bash
ip a | grep br-demo
```

Tu verras une interface `br-demo` crÃ©Ã©e automatiquement.

---

### ğŸ§  Analyse

- IPAM dÃ©finit la plage IP (172.25.0.0/16).

- Le `driver_opts` nomme lâ€™interface Linux (`br-demo`).

- `enable_icc: "true"` autorise la communication inter-conteneurs.

- Ce rÃ©seau est **personnalisÃ©** et **persistant**.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-bridge-custom.yml down
docker network rm atelier-compose-networks_mynet
```

---

# âš™ï¸ CAS 3 â€” RÃ©seau interne (`internal: true`)

### ğŸ¯ Objectif

CrÃ©er un rÃ©seau **sans sortie Internet**, mais permettant la communication entre conteneurs.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-internal.yml** :

```yaml
version: "3.9"

services:
  api:
    image: nginx:1.27
    container_name: demo_internal_api
    networks:
      - internal_net

  test:
    image: curlimages/curl:8.7.1
    container_name: demo_internal_test
    depends_on:
      - api
    networks:
      - internal_net
    command: ["sh", "-c", "sleep 3 && curl -I http://api"]

networks:
  internal_net:
    driver: bridge
    internal: true
```

---

### â–¶ï¸ Ã‰tape 2 â€” DÃ©marrer

```bash
docker compose -f docker-compose-internal.yml up
```

RÃ©sultat attendu :

```
HTTP/1.1 200 OK
```

---

### ğŸ” Ã‰tape 3 â€” VÃ©rification Internet bloquÃ©

Essaye :

```bash
docker exec -it demo_internal_test ping -c 1 8.8.8.8
```

RÃ©sultat attendu :

```
ping: bad address '8.8.8.8'
```

---

### ğŸ§  Analyse

- Le rÃ©seau est **fermÃ© vers lâ€™extÃ©rieur** (`internal: true`).

- IdÃ©al pour des **bases de donnÃ©es** ou des **services internes**.

- Communication autorisÃ©e uniquement entre services du mÃªme rÃ©seau.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-internal.yml down
```

---

# âš™ï¸ CAS 4 â€” RÃ©seau `host`

### ğŸ¯ Objectif

Faire fonctionner un conteneur **sur le rÃ©seau de lâ€™hÃ´te** (pas de NAT, pas de bridge).

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-host.yml** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:1.27
    container_name: demo_host_net
    network_mode: host
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer

```bash
docker compose -f docker-compose-host.yml up -d
```

Tester :

```bash
curl http://localhost
```

â¡ï¸ AccÃ¨s direct, sans redirection de port.

---

### ğŸ§  Analyse

- Le conteneur partage **le mÃªme rÃ©seau** que lâ€™hÃ´te.

- Aucun port nâ€™est publiÃ© (`ports:` inutile).

- Performances meilleures, mais **aucune isolation rÃ©seau**.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-host.yml down
```

---

# âš™ï¸ CAS 5 â€” RÃ©seau `none` (isolation totale)

### ğŸ¯ Objectif

CrÃ©er un conteneur totalement isolÃ© : aucun accÃ¨s Internet, ni DNS.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-none.yml** :

```yaml
version: "3.9"

services:
  isolated:
    image: alpine:3.20
    container_name: demo_none
    network_mode: none
    command: ["sh", "-c", "ip a && sleep 10"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer

```bash
docker compose -f docker-compose-none.yml up
```

RÃ©sultat :

```
1: lo: <LOOPBACK> mtu 65536 ...
```

â¡ï¸ Seule lâ€™interface `lo` (loopback) est visible.

---

### ğŸ§  Analyse

- Conteneur totalement coupÃ© du rÃ©seau.

- Parfait pour **tests de sÃ©curitÃ©**, **exÃ©cution de batchs** sans dÃ©pendance rÃ©seau.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-none.yml down
```

---

# âš™ï¸ CAS 6 â€” Multi-rÃ©seaux (isolation sÃ©lective)

### ğŸ¯ Objectif

Faire communiquer une application sur **deux rÃ©seaux diffÃ©rents** :  
un rÃ©seau interne et un rÃ©seau public.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-multinet.yml** :

```yaml
version: "3.9"

services:
  db:
    image: mysql:8.0
    container_name: demo_multi_db
    environment:
      - MYSQL_ROOT_PASSWORD=rootpass
    networks:
      - internal_net

  api:
    image: nginx:1.27
    container_name: demo_multi_api
    depends_on:
      - db
    networks:
      - internal_net
      - public_net
    ports:
      - "8085:80"

networks:
  internal_net:
    driver: bridge
    internal: true

  public_net:
    driver: bridge
    ipam:
      config:
        - subnet: 172.30.0.0/16
          gateway: 172.30.0.1
```

---

### â–¶ï¸ Ã‰tape 2 â€” DÃ©marrer

```bash
docker compose -f docker-compose-multinet.yml up -d
```

---

### ğŸ” Ã‰tape 3 â€” VÃ©rification

Inspecte les rÃ©seaux :

```bash
docker inspect demo_multi_api | grep -A5 Networks
```

Tu verras :

```
"internal_net": { "IPAddress": "172.18.0.3" },
"public_net":   { "IPAddress": "172.30.0.2" }
```

---

### ğŸ§  Analyse

- `api` est connectÃ© Ã  **deux rÃ©seaux** :
  
  - `internal_net` pour parler Ã  `db`,
  
  - `public_net` pour recevoir des requÃªtes HTTP.

- Structure typique des **architectures en couches** (DB privÃ©e / API publique).

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-multinet.yml down
```

---

# ğŸ“Š RÃ©sumÃ© global

| Cas | Type de rÃ©seau  | AccÃ¨s Internet | Isolation  | Cas dâ€™usage              |
| --- | --------------- | -------------- | ---------- | ------------------------ |
| 1   | bridge (dÃ©faut) | âœ…              | Moyenne    | apps internes            |
| 2   | bridge + IPAM   | âœ…              | Moyenne    | IP maÃ®trisÃ©e             |
| 3   | internal        | âŒ              | Forte      | bases, backend           |
| 4   | host            | âœ…              | Faible     | monitoring, perf         |
| 5   | none            | âŒ              | Totale     | sandbox                  |
| 6   | multi-net       | SÃ©lectif       | Granulaire | architectures multi-tier |

---

# ğŸ’¡ Bonnes pratiques

âœ… Utiliser des **rÃ©seaux internal** pour les services non publics (DB, cache).  
âœ… Utiliser un **bridge personnalisÃ©** avec IPAM pour contrÃ´ler les IPs.  
âœ… RÃ©server `host` uniquement pour des services systÃ¨me.  
âœ… Pour des API publiques, combiner :

```yaml
networks:
  - public_net
  - private_net
```

âœ… Inspecter les rÃ©seaux rÃ©guliÃ¨rement :

```bash
docker network inspect <nom_reseau>
```

Excellente remarque ğŸ‘ â€” tu mets le doigt sur **deux notions souvent nÃ©gligÃ©es**, mais **fondamentales en production** :  
la directive **`external:`** pour **les rÃ©seaux** et pour **les volumes**.  
Effectivement, dans les ateliers 5 (Volumes) et 6 (Networks), on a couvert toutes les configurations *internes* (`driver`, `driver_opts`, `ipam`, etc.),  
mais **pas encore le cas â€œexternalâ€**.  
On va donc corriger cela ici, avant de passer Ã  lâ€™atelier 7.

---

# ğŸ§© Interlude technique â€” Le mot-clÃ© `external:` pour rÃ©seaux et volumes

---

## ğŸ¯ Objectif

La directive **`external:`** indique Ã  Docker Compose de **rÃ©utiliser une ressource dÃ©jÃ  existante** (volume ou rÃ©seau)  
au lieu de la crÃ©er ou de la gÃ©rer automatiquement.  
Cela permet de **partager des ressources entre plusieurs projets Compose**,  
ou dâ€™utiliser des volumes/rÃ©seaux crÃ©Ã©s manuellement via `docker network create` / `docker volume create`.

---

# âš™ï¸ Partie 1 â€” `external` pour un **rÃ©seau**

---

## ğŸ§  Principe

- Sans `external`, Compose crÃ©e un rÃ©seau nommÃ© :  
  `nom_du_projet_nom_du_reseau`

- Avec `external: true`, Compose **se connecte Ã  un rÃ©seau dÃ©jÃ  existant**.  
  Il ne le crÃ©e **pas** et **ne le supprime pas**.

Cela permet :

- Ã  plusieurs projets Compose dâ€™Ãªtre sur le **mÃªme rÃ©seau logique**,

- de **connecter manuellement** dâ€™autres conteneurs externes (via `docker run --network`).

---

## ğŸ§© Exemple concret (Ubuntu local)

### Ã‰tape 1 â€” CrÃ©er un rÃ©seau externe

```bash
docker network create -d bridge shared_net
docker network ls
```

### Ã‰tape 2 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-external-network.yml** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:1.27
    container_name: demo_external_net_web
    networks:
      - shared_net_ext

networks:
  shared_net_ext:
    external: true
    name: shared_net
```

### Ã‰tape 3 â€” Lancer

```bash
docker compose -f docker-compose-external-network.yml up -d
```

### Ã‰tape 4 â€” VÃ©rification

```bash
docker inspect demo_external_net_web | grep -A3 Networks
```

RÃ©sultat :

```
"shared_net": {
    "IPAMConfig": null,
    "Links": null,
    "Aliases": ["demo_external_net_web"]
}
```

---

## ğŸ§  Analyse

- Le rÃ©seau **`shared_net`** existait dÃ©jÃ  â†’ Compose sâ€™y rattache.

- Ã€ la suppression (`down`), Compose **nâ€™efface pas** le rÃ©seau externe.

- Utile pour connecter :
  
  - plusieurs stacks (ex : une base Redis commune),
  
  - un conteneur lancÃ© Ã  la main,
  
  - ou une stack dâ€™intÃ©gration avec dâ€™autres outils (Prometheus, ELKâ€¦).

---

## ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-external-network.yml down
docker network rm shared_net
```

---

# âš™ï¸ Partie 2 â€” `external` pour un **volume**

---

## ğŸ§  Principe

Un volume `external` signifie que Compose **ne gÃ¨re pas la crÃ©ation** du volume :  
il doit dÃ©jÃ  exister dans Docker.  
Cela permet :

- de **partager le mÃªme volume entre plusieurs projets Compose** (ex: sauvegardes, cache, logs),

- ou dâ€™utiliser un volume **crÃ©Ã© Ã  la main** via `docker volume create`.

---

## ğŸ§© Exemple concret (Ubuntu local)

### Ã‰tape 1 â€” CrÃ©er un volume externe

```bash
docker volume create shared_data
docker volume ls
```

### Ã‰tape 2 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-external-volume.yml** :

```yaml
version: "3.9"

services:
  app:
    image: alpine:3.20
    container_name: demo_external_vol
    command: ["sh", "-c", "echo 'Contenu externe' > /data/hello.txt && cat /data/hello.txt"]
    volumes:
      - shared_vol:/data

volumes:
  shared_vol:
    external: true
    name: shared_data
```

---

### Ã‰tape 3 â€” Lancer

```bash
docker compose -f docker-compose-external-volume.yml up
```

Sortie attendue :

```
Contenu externe
```

---

### Ã‰tape 4 â€” VÃ©rifier le contenu sur le volume

```bash
docker run --rm -v shared_data:/mnt alpine cat /mnt/hello.txt
```

RÃ©sultat :

```
Contenu externe
```

---

## ğŸ§  Analyse

- Le volume `shared_data` Ã©tait **prÃ©existant** : Compose **ne le crÃ©e pas**.

- Il **nâ€™est pas supprimÃ©** par `docker compose down`.

- Cela permet :
  
  - dâ€™utiliser un mÃªme volume entre plusieurs stacks Compose ;
  
  - de garder des donnÃ©es partagÃ©es entre versions dâ€™une mÃªme app.

---

## ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-external-volume.yml down
docker volume rm shared_data
```

---

# ğŸ“Š Comparatif : `external` vs standard

| Ã‰lÃ©ment               | Sans `external`         | Avec `external`                    |
| --------------------- | ----------------------- | ---------------------------------- |
| CrÃ©ation automatique  | âœ… oui                   | âŒ non                              |
| Suppression au `down` | âœ… oui                   | âŒ non                              |
| Nom du rÃ©seau/volume  | `project_name_resource` | dÃ©fini manuellement                |
| Usage multi-projet    | âš ï¸ non conseillÃ©        | âœ… oui                              |
| Exemple dâ€™usage       | stack isolÃ©e            | stack intÃ©grÃ©e, monitoring partagÃ© |

---

# ğŸ’¡ Bonnes pratiques

âœ… Toujours crÃ©er explicitement les ressources partagÃ©es :

```bash
docker network create shared_net
docker volume create shared_data
```

âœ… RÃ©fÃ©rencer ensuite dans Compose :

```yaml
networks:
  shared_net:
    external: true
```

âœ… VÃ©rifier les ressources externes avant lancement :

```bash
docker network inspect shared_net
docker volume inspect shared_data
```

âœ… Utiliser des noms cohÃ©rents :

```
corp_net_backend
corp_data_mysql
```

âœ… Attention : ne pas confondre :

- `external: true` (rÃ©utilisation)

- `external: { name: ... }` (nom explicite, Ã©quivalent mais plus prÃ©cis).

Excellent ğŸ‘  
On enchaÃ®ne donc avec **lâ€™ğŸ§ª Atelier 7 â€” `user` et `security_opt`**, toujours dans ton environnement

> ğŸ–¥ï¸ Ubuntu sous VirtualBox (une seule machine).

Cet atelier est essentiel : il traite de la **sÃ©curitÃ© et de lâ€™isolation dâ€™exÃ©cution des conteneurs**.  
On va explorer comment :

- exÃ©cuter un conteneur avec un **utilisateur non-root** ;

- restreindre ses privilÃ¨ges Linux via **`security_opt`** ;

- utiliser **`cap_add`** et **`cap_drop`** pour gÃ©rer les *capabilities* Linux ;

- comprendre les implications dans un contexte Compose.

---

Parfait âš™ï¸  
On passe donc Ã  lâ€™**ğŸ§ª Atelier 8 â€” Limitations de ressources Docker Compose : `mem_limit`, `cpus`, `pids_limit`, `ulimits`**,  
toujours dans le mÃªme environnement de travail :

> ğŸ–¥ï¸ Ubuntu sous VirtualBox (une seule machine hÃ´te, Docker installÃ© localement).

---

# ğŸ§ª Atelier 9 â€” Limiter les ressources des conteneurs Docker Compose

---

## 1ï¸âƒ£ Contexte & Objectif

Docker permet de **limiter la consommation de ressources** dâ€™un conteneur pour Ã©viter quâ€™il monopolise la machine hÃ´te.  
Câ€™est essentiel dans :

- les environnements de production multi-services ;

- les pipelines CI/CD ;

- ou simplement pour **stabiliser** un environnement dâ€™apprentissage.

Les paramÃ¨tres principaux sont :

| Directive    | RÃ´le                                                                 | Exemple                   |
| ------------ | -------------------------------------------------------------------- | ------------------------- |
| `mem_limit`  | limite la mÃ©moire RAM utilisÃ©e                                       | `mem_limit: 256m`         |
| `cpus`       | limite la part CPU (exprimÃ©e en cÅ“urs logiques)                      | `cpus: 0.5`               |
| `pids_limit` | limite le nombre maximum de processus simultanÃ©s                     | `pids_limit: 50`          |
| `ulimits`    | dÃ©finit les limites *Linux kernel* (fichiers ouverts, threads, etc.) | `ulimits: {nofile: 1024}` |

---

## 2ï¸âƒ£ PrÃ©paration de lâ€™environnement

Sur la machine Ubuntu :

```bash
sudo apt update
sudo apt install -y docker.io docker-compose stress-ng
sudo systemctl enable --now docker
mkdir -p ~/atelier-compose-limits && cd ~/atelier-compose-limits
```

---

# âš™ï¸ CAS 1 â€” Limitation mÃ©moire (`mem_limit`)

### ğŸ¯ Objectif

EmpÃªcher un conteneur de dÃ©passer une quantitÃ© de RAM donnÃ©e.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-memlimit.yml** :

```yaml
version: "3.9"

services:
  stress_mem:
    image: polinux/stress
    container_name: demo_mem_limit
    mem_limit: 128m
    command: ["--vm", "2", "--vm-bytes", "200M", "--timeout", "10s"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer

```bash
docker compose -f docker-compose-memlimit.yml up
```

RÃ©sultat attendu :

```
stress: info: [1] dispatching hogs: 2 vm
stress: FAIL: [1] (416) <-- VM allocation failed: Cannot allocate memory
```

---

### ğŸ§  Analyse

- Le conteneur essaie dâ€™allouer 200 Mo alors que `mem_limit` = 128 Mo.

- Le kernel Docker (cgroups) bloque la demande et lâ€™application Ã©choue.

- `mem_limit` sâ€™exprime en :
  
  - octets (`b`)
  
  - kilo (`k`)
  
  - mÃ©ga (`m`)
  
  - giga (`g`)

> âš ï¸ Sur un systÃ¨me sans swap, le conteneur sera immÃ©diatement tuÃ©.

---

### ğŸ” VÃ©rification

```bash
docker stats demo_mem_limit
```

Tu verras :

```
MEM USAGE / LIMIT: 120MiB / 128MiB
```

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-memlimit.yml down
```

---

# âš™ï¸ CAS 2 â€” Limitation CPU (`cpus`)

### ğŸ¯ Objectif

Limiter la part de CPU quâ€™un conteneur peut consommer.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-cpulimit.yml** :

```yaml
version: "3.9"

services:
  stress_cpu:
    image: polinux/stress
    container_name: demo_cpu_limit
    cpus: 0.5        # = 50% dâ€™un cÅ“ur logique
    command: ["--cpu", "2", "--timeout", "15s"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer

```bash
docker compose -f docker-compose-cpulimit.yml up
```

Ouvre un autre terminal :

```bash
docker stats demo_cpu_limit
```

Tu verras :

```
CPU % ~50.00
```

---

### ğŸ§  Analyse

- `cpus: 0.5` signifie : le conteneur ne peut pas dÃ©passer **50 % dâ€™un CPU**.

- Sur un CPU Ã  4 cÅ“urs, il pourra utiliser 0.5 / 4 = 12.5 % du total.

- Cette option agit sur le **temps CPU allouÃ© par cgroups**.

> âš ï¸ Sous VirtualBox, lâ€™efficacitÃ© dÃ©pend du nombre de CPU virtuels allouÃ©s Ã  la VM.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-cpulimit.yml down
```

---

# âš™ï¸ CAS 3 â€” Limitation du nombre de processus (`pids_limit`)

### ğŸ¯ Objectif

EmpÃªcher un conteneur de lancer trop de processus (fork bomb, erreurs non maÃ®trisÃ©es).

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-pidslimit.yml** :

```yaml
version: "3.9"

services:
  stress_pids:
    image: alpine:3.20
    container_name: demo_pids_limit
    pids_limit: 50
    command: ["sh", "-c", "for i in $(seq 1 100); do sleep 100 & done; wait"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer

```bash
docker compose -f docker-compose-pidslimit.yml up
```

RÃ©sultat attendu :

```
sh: can't fork: Resource temporarily unavailable
```

---

### ğŸ§  Analyse

- Le conteneur essaie de lancer 100 processus simultanÃ©s.

- `pids_limit: 50` bloque la crÃ©ation au-delÃ  de 50.

- Protection utile contre :
  
  - les scripts dÃ©faillants,
  
  - les attaques â€œfork bombâ€.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-pidslimit.yml down
```

---

# âš™ï¸ CAS 4 â€” Limites systÃ¨me via `ulimits`

### ğŸ¯ Objectif

Configurer les limites systÃ¨me Linux internes (ex : nombre de fichiers ouverts).

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-ulimits.yml** :

```yaml
version: "3.9"

services:
  app:
    image: alpine:3.20
    container_name: demo_ulimits
    ulimits:
      nproc: 100     # max processus utilisateur
      nofile: 200    # max fichiers ouverts
    command: ["sh", "-c", "ulimit -a && sleep 5"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer

```bash
docker compose -f docker-compose-ulimits.yml up
```

RÃ©sultat :

```
max user processes (-u) 100
open files (-n) 200
```

---

### ğŸ§  Analyse

- `ulimits` reflÃ¨te la commande Linux `ulimit`.

- Ces paramÃ¨tres sont **indÃ©pendants de Docker** (limites POSIX).

- TrÃ¨s utile pour contrÃ´ler :
  
  - le nombre de connexions simultanÃ©es (sockets),
  
  - les fichiers log ouverts,
  
  - les processus de fond dans une app.

---

# âš™ï¸ CAS 5 â€” Combinaison complÃ¨te (production rÃ©aliste)

### ğŸ¯ Objectif

Combiner plusieurs limitations sur un conteneur applicatif.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-combined-limits.yml** :

```yaml
version: "3.9"

services:
  api:
    image: nginx:1.27
    container_name: demo_combined_limits
    mem_limit: 256m
    cpus: 0.25
    pids_limit: 100
    ulimits:
      nofile: 256
    ports:
      - "8080:80"
```

---

### â–¶ï¸ Ã‰tape 2 â€” DÃ©marrer

```bash
docker compose -f docker-compose-combined-limits.yml up -d
docker stats demo_combined_limits
```

---

### ğŸ§  Analyse

- RAM limitÃ©e Ã  256 Mo.

- CPU limitÃ© Ã  25 % dâ€™un cÅ“ur.

- 100 processus maximum.

- 256 fichiers ouverts au maximum.

- Parfait pour dÃ©ployer des **petits services web** ou **API contrÃ´lÃ©es**.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-combined-limits.yml down
```

---

# ğŸ“Š Tableau comparatif

| Option       | UnitÃ©                    | AppliquÃ© par     | Effet                   |
| ------------ | ------------------------ | ---------------- | ----------------------- |
| `mem_limit`  | Mo / Go                  | cgroups (kernel) | RAM maximale autorisÃ©e  |
| `cpus`       | fraction (ex: 0.5)       | cgroups          | part CPU allouÃ©e        |
| `pids_limit` | nombre                   | cgroups          | nombre max de processus |
| `ulimits`    | variable selon ressource | shell Linux      | limites POSIX internes  |

---

# ğŸ’¡ Bonnes pratiques

âœ… Toujours fixer un `mem_limit` mÃªme pour des services simples (Ã©vite les crashs du systÃ¨me).  
âœ… Utiliser `pids_limit` sur les conteneurs exÃ©cutant du code non fiable.  
âœ… Pour les serveurs applicatifs :

```yaml
ulimits:
  nofile: 1024
  nproc: 200
```

âœ… VÃ©rifier les limites actives :

```bash
docker inspect <container> | grep -A3 Limit
```

âœ… Surveiller en temps rÃ©el :

```bash
docker stats
```

---

# ğŸ§¹ Nettoyage global

```bash
docker compose -f docker-compose-memlimit.yml down
docker compose -f docker-compose-cpulimit.yml down
docker compose -f docker-compose-pidslimit.yml down
docker compose -f docker-compose-ulimits.yml down
docker compose -f docker-compose-combined-limits.yml down
docker image prune -f
```

---

# ğŸ§ª Atelier 8 â€” SÃ©curitÃ© des conteneurs : `user`, `security_opt`, `cap_add`, `cap_drop`

---

## 1ï¸âƒ£ Contexte & Objectif

Par dÃ©faut, un conteneur Docker sâ€™exÃ©cute en **root** Ã  lâ€™intÃ©rieur de son espace isolÃ©.  
Cela pose un risque : si un attaquant Ã©chappe au conteneur, il devient root sur la machine hÃ´te.

Les options suivantes permettent de **rÃ©duire la surface dâ€™attaque** :

| Option                   | RÃ´le                                                                   |
| ------------------------ | ---------------------------------------------------------------------- |
| `user:`                  | DÃ©finit lâ€™UID/GID ou nom dâ€™utilisateur pour exÃ©cuter le process.       |
| `security_opt:`          | Configure AppArmor, SELinux, seccomp ou dâ€™autres profils de sÃ©curitÃ©.  |
| `cap_add:` / `cap_drop:` | Ajoute ou retire des *capabilities* Linux (permissions systÃ¨me fines). |

---

## 2ï¸âƒ£ PrÃ©paration de lâ€™environnement

Sur ta machine Ubuntu :

```bash
sudo apt update
sudo apt install -y docker.io docker-compose curl
sudo systemctl enable --now docker
mkdir -p ~/atelier-compose-security && cd ~/atelier-compose-security
```

---

# âš™ï¸ CAS 1 â€” ExÃ©cution en utilisateur non-root (`user:`)

### ğŸ¯ Objectif

Lancer un conteneur avec un utilisateur non-root et vÃ©rifier son UID/GID.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-user.yml** :

```yaml
version: "3.9"

services:
  app:
    image: alpine:3.20
    container_name: demo_user_app
    user: "1001:1001"              # UID:GID non-root
    command: ["sh", "-c", "id && whoami && touch /data/test.txt || echo 'Permission denied'"]
    volumes:
      - type: bind
        source: ./data
        target: /data
```

### â–¶ï¸ Ã‰tape 2 â€” PrÃ©parer le dossier

```bash
mkdir -p ~/atelier-compose-security/data
sudo chmod 777 ~/atelier-compose-security/data
```

### â–¶ï¸ Ã‰tape 3 â€” Lancer

```bash
docker compose -f docker-compose-user.yml up
```

RÃ©sultat attendu :

```
uid=1001 gid=1001
Permission denied
```

---

### ğŸ§  Analyse

- Le conteneur sâ€™exÃ©cute sous lâ€™UID 1001, sans privilÃ¨ges root.

- Lâ€™Ã©criture Ã©choue si les permissions ne sont pas adaptÃ©es.

- Câ€™est la **premiÃ¨re ligne de dÃ©fense** contre les Ã©lÃ©vations de privilÃ¨ges.

> ğŸ”¹ Si tu veux autoriser lâ€™Ã©criture :

```bash
sudo chown 1001:1001 ./data
```

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-user.yml down
```

---

# âš™ï¸ CAS 2 â€” `security_opt` avec profil AppArmor

### ğŸ¯ Objectif

Appliquer un profil de sÃ©curitÃ© **AppArmor** pour restreindre ce que le conteneur peut faire.

---

### ğŸ§© Ã‰tape 1 â€” VÃ©rifier AppArmor sur Ubuntu

```bash
sudo aa-status
```

RÃ©sultat attendu :

```
apparmor module is loaded.
```

---

### ğŸ§© Ã‰tape 2 â€” CrÃ©er un profil AppArmor minimal

CrÃ©er **/etc/apparmor.d/docker-nginx** :

```bash
# AppArmor profile minimal pour un conteneur Nginx
profile docker-nginx flags=(attach_disconnected,mediate_deleted) {
  # autoriser les fichiers nÃ©cessaires
  file,
  capability net_bind_service,
  network inet stream,
  network inet6 stream,
  deny /etc/shadow r,
}
```

Charger le profil :

```bash
sudo apparmor_parser -r /etc/apparmor.d/docker-nginx
```

---

### ğŸ§© Ã‰tape 3 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-apparmor.yml** :

```yaml
version: "3.9"

services:
  web:
    image: nginx:1.27
    container_name: demo_apparmor_web
    security_opt:
      - apparmor:docker-nginx
    ports:
      - "8081:80"
```

### â–¶ï¸ Ã‰tape 4 â€” DÃ©marrer

```bash
docker compose -f docker-compose-apparmor.yml up -d
```

---

### ğŸ§  Analyse

- Le profil AppArmor `docker-nginx` limite les accÃ¨s fichier et rÃ©seau.

- Si tu essayes dâ€™ouvrir `/etc/shadow` depuis le conteneur â†’ **permission denied**.

- Tu peux crÃ©er plusieurs profils selon le rÃ´le du conteneur.

---

### ğŸ§¹ Nettoyage

```bash
docker compose -f docker-compose-apparmor.yml down
sudo apparmor_parser -R /etc/apparmor.d/docker-nginx
```

---

# âš™ï¸ CAS 3 â€” Capabilities Linux (`cap_add` et `cap_drop`)

### ğŸ¯ Objectif

Comprendre comment ajuster les **permissions systÃ¨me fines** dâ€™un conteneur.

---

## ğŸ”¹ Rappel rapide

Sous Linux, chaque processus possÃ¨de un ensemble de *capabilities* :  
ex. `NET_ADMIN`, `SYS_TIME`, `CHOWN`, `KILL`, etc.

Docker retire la plupart dâ€™entre elles par dÃ©faut.  
Mais on peut en **ajouter** ou **supprimer** explicitement.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-capabilities.yml** :

```yaml
version: "3.9"

services:
  net_test:
    image: alpine:3.20
    container_name: demo_cap_add
    cap_add:
      - NET_ADMIN
    command: ["sh", "-c", "apk add iproute2 -q && ip link add dummy0 type dummy && ip link show dummy0 && sleep 5"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” DÃ©marrer

```bash
docker compose -f docker-compose-capabilities.yml up
```

RÃ©sultat attendu :

```
dummy0: <BROADCAST,NOARP> mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
```

---

### ğŸ§  Analyse

- `cap_add: NET_ADMIN` donne la capacitÃ© de gÃ©rer des interfaces rÃ©seau.

- Sans cette permission, la commande `ip link add` Ã©choue (`Operation not permitted`).

- Les capabilities sont beaucoup plus fines que `user:` :
  
  - root + `cap_drop: ALL` = conteneur quasi stÃ©rile.
  
  - user non-root + `cap_add` sÃ©lectif = sÃ©curitÃ© renforcÃ©e.

---

### ğŸ§© Ã‰tape 3 â€” Exemple inverse (suppression)

CrÃ©er **docker-compose-cap-drop.yml** :

```yaml
version: "3.9"

services:
  test_drop:
    image: alpine:3.20
    container_name: demo_cap_drop
    cap_drop:
      - NET_RAW
    command: ["sh", "-c", "apk add iputils -q && ping -c 1 127.0.0.1 || echo 'ICMP bloquÃ©'"]
```

### â–¶ï¸ Ã‰tape 4 â€” Lancer

```bash
docker compose -f docker-compose-cap-drop.yml up
```

RÃ©sultat attendu :

```
ICMP bloquÃ©
```

---

### ğŸ§  Analyse

- `cap_drop: NET_RAW` empÃªche lâ€™Ã©mission de paquets ICMP â†’ `ping` Ã©choue.

- On peut retirer **toutes** les capacitÃ©s (`cap_drop: ALL`) et nâ€™en rÃ©activer que certaines.

---

# âš™ï¸ CAS 4 â€” Combinaison complÃ¨te (sÃ©curitÃ© renforcÃ©e)

### ğŸ¯ Objectif

ExÃ©cuter une application non-root, avec profil restreint, capabilities limitÃ©es, et root FS en lecture seule.

---

### ğŸ§© Ã‰tape 1 â€” CrÃ©er le fichier Compose

CrÃ©er **docker-compose-secure.yml** :

```yaml
version: "3.9"

services:
  secure_app:
    image: alpine:3.20
    container_name: demo_secure
    user: "1001:1001"
    read_only: true
    cap_drop:
      - ALL
    security_opt:
      - no-new-privileges:true
    command: ["sh", "-c", "echo 'SÃ©curitÃ© renforcÃ©e' && sleep 5"]
```

---

### â–¶ï¸ Ã‰tape 2 â€” Lancer

```bash
docker compose -f docker-compose-secure.yml up
```

RÃ©sultat :

```
SÃ©curitÃ© renforcÃ©e
```

---

### ğŸ§  Analyse

- `read_only: true` : systÃ¨me de fichiers en lecture seule.

- `no-new-privileges:true` : empÃªche tout gain de privilÃ¨ges (sudo, setuid).

- `user:` + `cap_drop: ALL` = aucune Ã©lÃ©vation possible.

- Parfait pour des **conteneurs applicatifs en production**.

---

# ğŸ“Š RÃ©sumÃ© comparatif

| Option         | RÃ´le                                         | Exemple dâ€™usage                    |
| -------------- | -------------------------------------------- | ---------------------------------- |
| `user`         | exÃ©cution sous UID/GID spÃ©cifique            | Ã©viter le root                     |
| `security_opt` | profils AppArmor / Seccomp / NoNewPrivileges | isolation stricte                  |
| `cap_add`      | ajouter une permission systÃ¨me               | ex: `NET_ADMIN`                    |
| `cap_drop`     | retirer une permission                       | ex: `NET_RAW`                      |
| `read_only`    | FS en lecture seule                          | limiter les modifications internes |

---

# ğŸ’¡ Bonnes pratiques

âœ… Toujours exÃ©cuter les conteneurs applicatifs avec `user:` non-root.  
âœ… Utiliser `read_only: true` pour les services statiques (nginx, API).  
âœ… Supprimer les capacitÃ©s inutiles (`cap_drop: ALL`).  
âœ… Appliquer `security_opt: no-new-privileges:true`.  
âœ… VÃ©rifier les capacitÃ©s dâ€™un conteneur :

```bash
docker inspect <container> | grep Cap
```

âœ… Tester les restrictions avec :

```bash
docker exec -it <container> sh
```

---

# ğŸ§¹ Nettoyage global

```bash
docker compose -f docker-compose-user.yml down
docker compose -f docker-compose-apparmor.yml down
docker compose -f docker-compose-capabilities.yml down
docker compose -f docker-compose-cap-drop.yml down
docker compose -f docker-compose-secure.yml down
docker image prune -f
```
