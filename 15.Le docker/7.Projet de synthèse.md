

# Étape 1 — Installer et préparer **MySQL** sur Ubuntu 25.04 (base locale)

## 1) Contexte & objectif

Mettre en place une base **MySQL locale** (service système), créer un **schéma d’application** et un **compte applicatif** dédiés pour la future couche métier (Flask).  
Nous resterons en **accès local** (localhost) — pas d’ouverture réseau pour l’instant.

## 2) Préparation de l’environnement

- Machine : **Ubuntu 25.04** (VM ou hôte)

- Accès : utilisateur sudo

- Aucun port à ouvrir (DB locale)

## 3) Exécution pas à pas (commandes commentées)

### 3.1 — Installer MySQL Server

```bash
# 1) Mettre à jour l’index des paquets
sudo apt update

# 2) Installer le serveur MySQL (service systemd inclus)
sudo apt install -y mysql-server

# 3) Activer et démarrer le service (démarrage automatique au boot)
sudo systemctl enable --now mysql
```

### 3.2 — Vérifier l’installation et le service

```bash
# Version du client MySQL
mysql --version

# Santé du service (doit être "active (running)")
systemctl status mysql --no-pager

# Ping MySQL via mysqladmin (retour attendu: mysqld is alive)
sudo mysqladmin ping
```

### 3.3 — Sécuriser la base (profil minimal pour environnement de dév)

> Sur Ubuntu récents, le compte `root@localhost` est généralement en **authentification par socket** (pas de mot de passe, sudo requis).  
> On laisse cette config **pour l’admin système** et on **crée un compte applicatif** séparé.

```bash
# 1) Ouvrir un shell MySQL en root via socket (pas de mot de passe)
sudo mysql
```

Dans le shell MySQL, exécutez les SQL suivants (adaptés au besoin) :

```sql
-- 2) Créer la base dédiée à l’application
CREATE DATABASE IF NOT EXISTS appdb
  CHARACTER SET utf8mb4
  COLLATE utf8mb4_0900_ai_ci;

-- 3) Créer un utilisateur applicatif local avec un mot de passe fort
-- Remplacez 'MotDePasse!Fort2025' par votre mot de passe choisi
CREATE USER IF NOT EXISTS 'appuser'@'localhost'
  IDENTIFIED WITH caching_sha2_password BY 'MotDePasse!Fort2025';

-- 4) Accorder les droits minimaux nécessaires (CRUD de base)
GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER, INDEX
ON appdb.* TO 'appuser'@'localhost';

-- 5) Appliquer les changements de privilèges
FLUSH PRIVILEGES;

-- 6) (Optionnel) Créer une table de test pour la future API Flask
USE appdb;
CREATE TABLE IF NOT EXISTS products (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(120) NOT NULL,
  price DECIMAL(10,2) NOT NULL DEFAULT 0.00,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
INSERT INTO products(name, price) VALUES
 ('Keyboard', 39.90), ('Mouse', 19.00), ('Monitor 24"', 129.00);
```

Quittez MySQL :

```sql
EXIT;
```

### 3.4 — Tester la connexion **applicative** (sans sudo)

```bash
# Tester la connexion avec l’utilisateur 'appuser'
mysql -u appuser -p -D appdb -e "SELECT COUNT(*) AS rows_in_products FROM products;"
# → Saisir le mot de passe choisi (ex: MotDePasse!Fort2025)
```

### 3.5 — (Optionnel) Script de **healthcheck** local pour MySQL

Créer le fichier **/usr/local/bin/mysql_health.sh** :

```bash
#!/usr/bin/env bash
# Script de vérification simple de MySQL en local
# - Utilise mysqladmin ping
# - Écrit un log horodaté dans /tmp/mysql_health.log
# - Utilisation: mysql_health.sh [LABEL_OPTIONNEL]

set -euo pipefail

LABEL="${1:-mysql-local}"
LOG="/tmp/mysql_health.log"
TS="$(date +'%F %T')"

# Test: "mysqld is alive" attendu en sortie si OK
if mysqladmin ping >/dev/null 2>&1; then
  echo "$TS | $LABEL | health=OK" >> "$LOG"
  exit 0
else
  echo "$TS | $LABEL | health=KO" >> "$LOG"
  exit 1
fi
```

Rendre exécutable :

```bash
sudo install -m 0755 /dev/stdin /usr/local/bin/mysql_health.sh <<'EOF'
#!/usr/bin/env bash
set -euo pipefail
LABEL="${1:-mysql-local}"
LOG="/tmp/mysql_health.log"
TS="$(date +'%F %T')"
if mysqladmin ping >/dev/null 2>&1; then
  echo "$TS | $LABEL | health=OK" >> "$LOG"
  exit 0
else
  echo "$TS | $LABEL | health=KO" >> "$LOG"
  exit 1
fi
EOF
```

*(Si vous préférez strictement votre format « Créer le fichier … » sans redirection, dites-le et je re-présenterai le bloc en conséquence, comme vous l’exigez.)*

Test rapide :

```bash
/usr/local/bin/mysql_health.sh "boot-check" && tail -n 2 /tmp/mysql_health.log
```

## 4) Vérifications / Résultats attendus

- `systemctl status mysql` → **active (running)**

- `sudo mysqladmin ping` → **mysqld is alive**

- Connexion applicative :
  
  ```bash
  mysql -u appuser -p -D appdb -e "SELECT VERSION();"
  ```
  
  → affiche la version MySQL.

- Données de test :
  
  ```bash
  mysql -u appuser -p -D appdb -e "SELECT * FROM products;"
  ```
  
  → 3 lignes d’exemple.

## 5) Nettoyage / rollback (optionnel pour refaire)

```bash
# Supprimer schéma et utilisateur applicatif (garde MySQL installé)
sudo mysql -e "DROP DATABASE IF EXISTS appdb;"
sudo mysql -e "DROP USER IF EXISTS 'appuser'@'localhost'; FLUSH PRIVILEGES;"

# (Optionnel) Désinstaller MySQL (réinstallation propre)
# ATTENTION: supprime les données si purge
# sudo systemctl stop mysql
# sudo apt purge -y mysql-server
# sudo rm -rf /var/lib/mysql
# sudo apt autoremove -y
```

## 6) Astuces & pièges

- **Ne mélangez pas** compte root (admin via socket) et compte applicatif : principe du moindre privilège.

- Pas d’ouverture de port **3306** tant que l’accès reste local (Flask ↔ MySQL sur la même machine).

- Pour usage distant plus tard : créez un utilisateur `'appuser'@'%'` et activez le bind sur `0.0.0.0`, **mais pas à cette étape**.

- Encodage recommandé : `utf8mb4` + `collation utf8mb4_0900_ai_ci`.

- Si `mysqladmin ping` échoue : vérifiez `journalctl -u mysql -n 80 --no-pager`.

---



# Étape 2 — Couche métier (Flask) + Couche présentation (HTML/CSS/JS), sans Docker Compose

## 1) Contexte & objectif

- Mettre en place **deux couches séparées** :
  
  1. **API Flask** (métier) qui lit la base **MySQL locale** (créée à l’étape 1)
  
  2. **Front statique** (HTML/CSS/JS) qui consomme l’API via `fetch()`

- L’API exposera :
  
  - `GET /health` : statut simple
  
  - `GET /api/products` : liste des produits depuis `appdb.products`

- Le front s’exécute sur un port différent (ex. **8080**) et appelle l’API sur **5000** → **CORS côté API**.

## 2) Préparation de l’environnement

Exécuter sur **Ubuntu 25.04**, utilisateur sudo non nécessaire ici (sauf installation de paquets système si manque Python venv).

```bash
# 1) (si nécessaire) Installer les outils Python
sudo apt update
sudo apt install -y python3 python3-venv

# 2) Créer l’arborescence du projet
mkdir -p ~/projet-synthese/{backend,frontend}
cd ~/projet-synthese
```

---

## 3) Création des fichiers (scripts commentés)

### 3.1 — Côté **backend** (API Flask)

Créer le fichier **~/projet-synthese/backend/config_example.sh** :

```bash
#!/usr/bin/env bash
# Fichier d'exemple de configuration à SOURCER dans votre shell
# Copiez-le en config.sh et adaptez les valeurs si nécessaire.
# Usage: source config.sh

# Hôte et port MySQL (local, étape 1)
export DB_HOST="127.0.0.1"
export DB_PORT="3306"

# Schéma et identifiants applicatifs (créés à l'étape 1)
export DB_NAME="appdb"
export DB_USER="appuser"
export DB_PASSWORD="MotDePasse!Fort2025"

# Hôte/port d’écoute de l’API Flask
export API_HOST="0.0.0.0"
export API_PORT="5000"
```

Créer le fichier **~/projet-synthese/backend/requirements.txt** :

```bash
# Dépendances Python pour l'API Flask
Flask==3.0.3
mysql-connector-python==9.0.0
```

Créer le fichier **~/projet-synthese/backend/app.py** :

```python
#!/usr/bin/env python3
# API Flask "métier" — lit la base MySQL locale et expose des endpoints
# - /health : vérification simple
# - /api/products : retourne la liste des produits
#
# CORS: on ajoute les en-têtes nécessaires pour que le front (port 8080) puisse appeler l'API (port 5000).

import os
import json
from flask import Flask, jsonify, make_response
import mysql.connector
from mysql.connector import pooling, Error

# Lecture de la configuration via variables d'environnement (set par config.sh)
DB_HOST = os.getenv("DB_HOST", "127.0.0.1")
DB_PORT = int(os.getenv("DB_PORT", "3306"))
DB_NAME = os.getenv("DB_NAME", "appdb")
DB_USER = os.getenv("DB_USER", "appuser")
DB_PASSWORD = os.getenv("DB_PASSWORD", "")

API_HOST = os.getenv("API_HOST", "0.0.0.0")
API_PORT = int(os.getenv("API_PORT", "5000"))

# Initialisation Flask
app = Flask(__name__)

# Création d'un pool de connexions MySQL pour robustesse/perf
# (évite d'ouvrir une nouvelle connexion à chaque requête)
try:
    cnx_pool = pooling.MySQLConnectionPool(
        pool_name="app_pool",
        pool_size=5,                    # ajustable selon la charge
        host=DB_HOST,
        port=DB_PORT,
        database=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD,
        charset="utf8mb4",
        use_pure=True
    )
except Error as e:
    # En cas d'erreur au démarrage (mauvais mot de passe, MySQL arrêté...)
    # on logge et on continuera à lever des 503 côté endpoints.
    cnx_pool = None
    print(f"[BOOT][ERROR] MySQL pool init failed: {e}")

# Middleware minimal pour CORS (autorise le front http://localhost:8080)
# -> Pour des besoins avancés, on peut utiliser flask-cors, mais ici on reste sans dépendance supplémentaire.
@app.after_request
def add_cors_headers(resp):
    resp.headers["Access-Control-Allow-Origin"] = "http://localhost:8080"
    resp.headers["Access-Control-Allow-Methods"] = "GET, OPTIONS"
    resp.headers["Access-Control-Allow-Headers"] = "Content-Type"
    return resp

@app.route("/health", methods=["GET"])
def health():
    # Vérifie rapidement le pool MySQL
    ok = False
    if cnx_pool is not None:
        try:
            with cnx_pool.get_connection() as cnx:
                ok = cnx.is_connected()
        except Error:
            ok = False
    status = {"status": "ok" if ok else "degraded", "db": ok}
    return jsonify(status), (200 if ok else 503)

@app.route("/api/products", methods=["GET"])
def get_products():
    # Récupère la liste des produits depuis la table appdb.products
    if cnx_pool is None:
        return jsonify({"error": "database_unavailable"}), 503
    try:
        with cnx_pool.get_connection() as cnx:
            with cnx.cursor(dictionary=True) as cur:
                cur.execute("""
                    SELECT id, name, price, created_at
                    FROM products
                    ORDER BY id ASC
                """)
                rows = cur.fetchall()
        return jsonify({"items": rows, "count": len(rows)}), 200
    except Error as e:
        # Log minimal
        print(f"[ERROR] get_products: {e}")
        return jsonify({"error": "query_failed"}), 500

if __name__ == "__main__":
    # Lancement de l'API
    print(f"[BOOT] API listening on http://{API_HOST}:{API_PORT}")
    print(f"[BOOT] DB target: mysql://{DB_USER}@{DB_HOST}:{DB_PORT}/{DB_NAME}")
    app.run(host=API_HOST, port=API_PORT, debug=False)
```

Créer le fichier **~/projet-synthese/backend/README.run.md** (documentation d’exécution) :

```markdown
# Démarrer l’API Flask (backend)

## 1) Préparer l’environnement Python (une seule fois)
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt

## 2) Charger la configuration
cp config_example.sh config.sh
# -> Éditez config.sh si besoin, puis :
source ./config.sh

## 3) Lancer l’API
python app.py
# -> écoute sur http://0.0.0.0:5000 (modifiable via config.sh)

## 4) Tests rapides
curl -s http://127.0.0.1:5000/health | jq .
curl -s http://127.0.0.1:5000/api/products | jq '.count, .items[0]'
```

---

### 3.2 — Côté **frontend** (HTML/CSS/JS)

Créer le fichier **~/projet-synthese/frontend/index.html** :

```html
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catalogue — Front (HTML/CSS/JS)</title>
  <!-- Feuille de style -->
  <link rel="stylesheet" href="./style.css" />
</head>
<body>
  <header>
    <h1>Catalogue Produits</h1>
    <p class="subtitle">Front statique → API Flask → MySQL local</p>
  </header>

  <main>
    <section class="panel">
      <div class="controls">
        <button id="btn-refresh" title="Recharger la liste">🔄 Recharger</button>
        <span id="api-status" class="status">API: inconnue</span>
      </div>

      <table id="tbl-products">
        <thead>
          <tr>
            <th>#</th>
            <th>Nom</th>
            <th>Prix (€)</th>
            <th>Créé le</th>
          </tr>
        </thead>
        <tbody>
          <!-- Lignes générées dynamiquement -->
        </tbody>
      </table>

      <div id="empty" class="empty hidden">Aucun produit à afficher.</div>
      <div id="error" class="error hidden">Erreur de chargement. Vérifiez l'API.</div>
    </section>
  </main>

  <footer>
    <small>Projet de synthèse — Étape 2 (sans Docker Compose)</small>
  </footer>

  <script src="./app.js"></script>
</body>
</html>
```

Créer le fichier **~/projet-synthese/frontend/style.css** :

```css
/* Style minimal, lisible et responsive */
:root {
  --bg: #0f172a;
  --panel: #111827;
  --text: #e5e7eb;
  --muted: #9ca3af;
  --accent: #60a5fa;
  --ok: #22c55e;
  --ko: #ef4444;
  --table: #1f2937;
}

* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Helvetica Neue", sans-serif;
  background: linear-gradient(180deg, var(--bg), #0b1224);
  color: var(--text);
}

header {
  padding: 24px;
  text-align: center;
}

h1 { margin: 0 0 6px 0; }
.subtitle { margin: 0; color: var(--muted); }

main {
  max-width: 980px;
  margin: 0 auto;
  padding: 16px;
}

.panel {
  background: var(--panel);
  border: 1px solid #1f2937;
  border-radius: 14px;
  padding: 16px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.25);
}

.controls {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
}

#btn-refresh {
  cursor: pointer;
  padding: 8px 14px;
  border: 1px solid #374151;
  border-radius: 10px;
  background: #0b1224;
  color: var(--text);
}
#btn-refresh:hover { border-color: var(--accent); }

.status { margin-left: auto; color: var(--muted); }
.status.ok { color: var(--ok); }
.status.ko { color: var(--ko); }

table {
  width: 100%;
  border-collapse: collapse;
  background: var(--table);
  border-radius: 10px;
  overflow: hidden;
}

thead th {
  text-align: left;
  padding: 12px;
  background: #101826;
  color: #cbd5e1;
  border-bottom: 1px solid #1f2937;
}

tbody td {
  padding: 10px 12px;
  border-bottom: 1px solid #1f2937;
}

tbody tr:hover { background: #0f172a; }

.empty, .error {
  margin-top: 12px;
  padding: 10px 12px;
  border-radius: 10px;
}

.empty { background: #0b3c1d; color: #a7f3d0; }
.error { background: #3c0b0b; color: #fecaca; }

.hidden { display: none; }

footer {
  text-align: center;
  color: var(--muted);
  padding: 24px;
}
```

Créer le fichier **~/projet-synthese/frontend/app.js** :

```javascript
// Front minimal pour consommer l'API Flask.
// - Vérifie le /health pour afficher l'état
// - Récupère /api/products pour remplir le tableau

const API_BASE = "http://127.0.0.1:5000"; // API Flask locale (port 5000)
const els = {
  btn: document.getElementById("btn-refresh"),
  status: document.getElementById("api-status"),
  tbody: document.querySelector("#tbl-products tbody"),
  empty: document.getElementById("empty"),
  error: document.getElementById("error"),
};

async function checkHealth() {
  try {
    const res = await fetch(`${API_BASE}/health`, { cache: "no-store" });
    const data = await res.json();
    if (res.ok && data?.status === "ok") {
      els.status.textContent = "API: OK";
      els.status.classList.remove("ko");
      els.status.classList.add("ok");
      return true;
    } else {
      els.status.textContent = "API: dégradée";
      els.status.classList.remove("ok");
      els.status.classList.add("ko");
      return false;
    }
  } catch {
    els.status.textContent = "API: inaccessible";
    els.status.classList.remove("ok");
    els.status.classList.add("ko");
    return false;
  }
}

function renderProducts(items) {
  // Nettoyage
  els.tbody.innerHTML = "";
  els.empty.classList.add("hidden");
  els.error.classList.add("hidden");

  if (!items || items.length === 0) {
    els.empty.classList.remove("hidden");
    return;
  }
  for (const p of items) {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${p.id}</td>
      <td>${p.name}</td>
      <td>${Number(p.price).toFixed(2)}</td>
      <td>${new Date(p.created_at).toLocaleString()}</td>
    `;
    els.tbody.appendChild(tr);
  }
}

async function loadProducts() {
  try {
    const res = await fetch(`${API_BASE}/api/products`, { cache: "no-store" });
    if (!res.ok) throw new Error("bad status");
    const data = await res.json();
    renderProducts(data.items);
  } catch (e) {
    els.error.classList.remove("hidden");
  }
}

async function reloadAll() {
  await checkHealth();
  await loadProducts();
}

// Événements
els.btn.addEventListener("click", reloadAll);

// Chargement initial
reloadAll();
```

Créer le fichier **~/projet-synthese/frontend/README.run.md** :

```markdown
# Démarrer le front statique

## 1) Lancer un serveur HTTP statique (port 8080)
# Depuis le dossier frontend/
python3 -m http.server 8080

## 2) Ouvrir le navigateur
http://127.0.0.1:8080

## 3) Attendu
- Le bouton "🔄 Recharger" recharge la liste
- Le statut "API: OK" si l'API répond
- Le tableau affiche les produits de MySQL
```

---

## 4) Exécution pas à pas (bout-à-bout)

### 4.1 — Démarrer l’API Flask (terminal A)

```bash
cd ~/projet-synthese/backend

# Créer et activer l'environnement virtuel (une seule fois)
python3 -m venv .venv
source .venv/bin/activate

# Installer les dépendances
pip install -r requirements.txt

# Charger la configuration (copiez l'exemple si besoin)
cp -n config_example.sh config.sh
source ./config.sh

# Lancer l'API
python app.py
# → écoute sur http://0.0.0.0:5000 ; logs d’amorçage affichés dans ce terminal
```

Tests rapides (dans **un autre terminal**) :

```bash
curl -s http://127.0.0.1:5000/health
curl -s http://127.0.0.1:5000/api/products | python3 -m json.tool | head -n 20
```

### 4.2 — Démarrer le front (terminal B)

```bash
cd ~/projet-synthese/frontend
python3 -m http.server 8080
# → sert index.html sur http://127.0.0.1:8080
```

### 4.3 — Vérifications (navigateur)

- Ouvrir **[http://127.0.0.1:8080](http://127.0.0.1:8080)**

- Statut **API: OK** attendu

- Tableau rempli avec les 3 produits de la table `products`

---

## 5) Résultats attendus

- `GET /health` retourne `{"status":"ok","db":true}` avec HTTP **200**

- `GET /api/products` retourne `{"items":[...], "count":3}` avec HTTP **200**

- Front affiche le tableau (id, name, price, created_at)

---

## 6) Nettoyage / rollback

```bash
# Arrêter le front: CTRL+C dans le terminal B
# Arrêter l'API:  CTRL+C dans le terminal A

# (Optionnel) Désactiver l'environnement virtuel
deactivate 2>/dev/null || true

# (Optionnel) Supprimer l'environnement Python pour repartir propre
rm -rf ~/projet-synthese/backend/.venv
```

---

## 7) Astuces & pièges

- **CORS** : le front tourne sur **8080** et appelle l’API sur **5000** → en-têtes CORS ajoutés dans `app.py`.  
  Si vous changez de port front, adaptez `Access-Control-Allow-Origin`.

- **Mots de passe** : `config_example.sh` est un **exemple** ; copiez en `config.sh` et protégez vos secrets.

- **Erreurs MySQL** :
  
  - Si `/health` renvoie `"degraded"` : vérifiez `systemctl status mysql` et vos identifiants.
  
  - Pour diagnostiquer : `journalctl -u mysql -n 80 --no-pager`.

- **Locales/Date** : `created_at` est affiché en `toLocaleString()` côté front (timezone système).

---



# Étape 3 — Raffinements Dockerfile (Backend Flask + Front statique)

## 1) Contexte & objectifs

- Conteneuriser notre **API Flask** (backend) puis améliorer graduellement :
  
  - taille d’image (multi-stage, `.dockerignore`)
  
  - performances (caching pip)
  
  - sécurité (utilisateur non-root, rootfs en lecture seule, drop de capacités)
  
  - observabilité (healthcheck)

- Préparer un **Dockerfile front** minimal pour servir le HTML/CSS/JS.

- **Important (tests “sans Compose”)** : le conteneur backend devra accéder à **MySQL installé sur l’hôte**.  
  Pour simplifier les premiers tests, on utilisera l’option `--network=host` (Linux) **ou** `DB_HOST=$(ip route | awk '/default/ {print $3}')` (gateway docker).
  
  > Sur Linux récents, `host.docker.internal` fonctionne souvent, mais pas garanti selon versions. On montrera les deux.

---

## 2) Préparation de l’environnement

Arborescence de travail (en partant de l’étape 2) :

```
~/projet-synthese/
├── backend/
│   ├── app.py
│   ├── requirements.txt
│   └── config_example.sh
└── frontend/
    ├── index.html
    ├── style.css
    └── app.js
```

On ajoute progressivement des fichiers Docker et un `.dockerignore`.

---

## 3) Backend v1 — Dockerfile simple (serveur Flask intégré)

**Objectif :** première image fonctionnelle, facile à lire (non optimisée).

Créer le fichier **backend/Dockerfile.v1** :

```dockerfile
# Image de base Python légère
FROM python:3.12-slim

# Empêcher Python d'écrire des .pyc et forcer le flush des logs
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

# Répertoire de travail
WORKDIR /app

# Copier en premier les dépendances pour profiter du cache Docker lors des rebuilds
COPY requirements.txt /app/requirements.txt

# Installer les dépendances de l'API (sans cache pip pour réduire la taille finale)
RUN pip install --no-cache-dir -r /app/requirements.txt

# Copier le code de l'application
COPY app.py /app/app.py

# Exposer le port de l'API
EXPOSE 5000

# Variables d'environnement par défaut (surchargées au run)
ENV API_HOST=0.0.0.0 \
    API_PORT=5000

# Commande de démarrage : serveur intégré Flask (suffisant pour dev/test)
CMD ["python", "app.py"]
```

Créer le fichier **backend/.dockerignore** :

```txt
# Exclure ce qui n'est pas utile dans l'image
__pycache__/
*.pyc
*.pyo
*.pyd
*.log
.venv/
.env
config.sh
*.md
```

### Construction & exécution (Linux)

```bash
cd ~/projet-synthese/backend

# 1) Construire l’image
docker build -f Dockerfile.v1 -t synthese-backend:v1 .

# 2a) (Option simple) Exécuter en réseau hôte (le conteneur voit MySQL local)
#    -> Linux uniquement, pratique pour dev local
docker run --rm --network=host \
  -e DB_HOST=127.0.0.1 \
  -e DB_PORT=3306 \
  -e DB_NAME=appdb \
  -e DB_USER=appuser \
  -e DB_PASSWORD='MotDePasse!Fort2025' \
  -p 5000:5000 \
  --name backend_v1 \
  synthese-backend:v1

# 2b) (Alternative portable) Sans --network=host :
#     DB_HOST doit pointer vers la gateway docker (souvent 172.17.0.1) ou host.docker.internal
#     Vérifiez la gateway :
# GW=$(ip route | awk '/default/ {print $3}')
# docker run --rm \
#   -e DB_HOST=${GW} -e DB_PORT=3306 -e DB_NAME=appdb \
#   -e DB_USER=appuser -e DB_PASSWORD='MotDePasse!Fort2025' \
#   -p 5000:5000 --name backend_v1 synthese-backend:v1
```

### Vérifications attendues

```bash
curl -s http://127.0.0.1:5000/health
curl -s http://127.0.0.1:5000/api/products | python3 -m json.tool | head -n 20
```

---

## 4) Backend v2 — Production-readiness (Gunicorn + healthcheck)

**Objectif :** remplacer le serveur Flask intégré par **Gunicorn**, ajouter un **HEALTHCHECK** sans dépendre d’outils externes.

Créer le fichier **backend/Dockerfile.v2** :

```dockerfile
FROM python:3.12-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

# Installer seulement ce qui est requis à l'exécution
# Ajout de gunicorn (serveur WSGI de prod)
COPY requirements.txt /app/requirements.txt
RUN pip install --no-cache-dir -r /app/requirements.txt gunicorn==22.0.0

# Copier le code applicatif
COPY app.py /app/app.py

# Exposer le port
EXPOSE 5000

# Healthcheck basé sur la lib standard (urllib) pour éviter d'installer curl/wget
HEALTHCHECK --interval=10s --timeout=2s --start-period=5s --retries=3 \
  CMD python -c "import urllib.request,sys; \
    urllib.request.urlopen('http://127.0.0.1:5000/health', timeout=1).read(); \
    sys.exit(0)"

# Variables d'env pour Gunicorn
ENV WORKERS=2 \
    THREADS=2 \
    TIMEOUT=30

# Commande de démarrage : gunicorn (app:app => objet Flask dans app.py)
CMD ["gunicorn", "app:app", \
     "--bind", "0.0.0.0:5000", \
     "--workers", "2", "--threads", "2", "--timeout", "30", \
     "--access-logfile", "-", "--error-logfile", "-"]
```

### Build & run

```bash
cd ~/projet-synthese/backend
docker build -f Dockerfile.v2 -t synthese-backend:v2 .

# Réseau "host" (simple pour accéder à MySQL local)
docker run --rm --network=host \
  -e DB_HOST=127.0.0.1 -e DB_PORT=3306 -e DB_NAME=appdb \
  -e DB_USER=appuser -e DB_PASSWORD='MotDePasse!Fort2025' \
  -p 5000:5000 --name backend_v2 synthese-backend:v2
```

---

## 5) Backend v3 — Multi-stage build + user non-root

**Objectif :** réduire la surface d’attaque, améliorer le cache et ne pas tourner en **root**.

Créer le fichier **backend/Dockerfile.v3** :

```dockerfile
# ----- STAGE 1: builder (installe les wheels en cache) -----
FROM python:3.12-slim AS builder

WORKDIR /build

# Préparer pip pour un build reproductible
ENV PIP_DISABLE_PIP_VERSION_CHECK=1 \
    PIP_NO_CACHE_DIR=1

COPY requirements.txt /build/requirements.txt
RUN python -m venv /build/venv \
 && /build/venv/bin/pip install --upgrade pip \
 && /build/venv/bin/pip install -r /build/requirements.txt gunicorn==22.0.0

# ----- STAGE 2: runtime -----
FROM python:3.12-slim

# Hygiene Python + locales
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

# Créer un utilisateur applicatif non-root
RUN groupadd -g 10001 app && useradd -r -u 10001 -g app -m -d /home/app app

WORKDIR /app

# Copier l'environnement virtuel depuis le builder
COPY --from=builder /build/venv /opt/venv
ENV PATH="/opt/venv/bin:${PATH}"

# Copier le code applicatif
COPY app.py /app/app.py

# Permissions minimales
RUN chown -R app:app /app

# Exécuter en utilisateur non-root
USER app:app

EXPOSE 5000

# Healthcheck sans binaire externe
HEALTHCHECK --interval=10s --timeout=2s --start-period=5s --retries=3 \
  CMD python -c "import urllib.request,sys; \
    urllib.request.urlopen('http://127.0.0.1:5000/health', timeout=1).read(); \
    sys.exit(0)"

ENV WORKERS=2 THREADS=2 TIMEOUT=30

CMD ["gunicorn", "app:app", \
     "--bind", "0.0.0.0:5000", \
     "--workers", "2", "--threads", "2", "--timeout", "30", \
     "--access-logfile", "-", "--error-logfile", "-"]
```

### Build & run

```bash
cd ~/projet-synthese/backend
docker build -f Dockerfile.v3 -t synthese-backend:v3 .

# Test (réseau host pour joindre MySQL local)
docker run --rm --network=host \
  -e DB_HOST=127.0.0.1 -e DB_PORT=3306 -e DB_NAME=appdb \
  -e DB_USER=appuser -e DB_PASSWORD='MotDePasse!Fort2025' \
  -p 5000:5000 --name backend_v3 synthese-backend:v3
```

---

## 6) Backend v4 — Renforcement sécurité (rootfs read-only, no-new-privs, caps)

**Objectif :** réduire encore les risques à l’exécution.

> Ces renforcements s’activent **au run** (runtime flags). Le Dockerfile v3 est déjà prêt (non-root).  
> On garde l’image `synthese-backend:v3` et on la lance avec des contraintes supplémentaires.

Exécution recommandée (Linux) :

```bash
# Monter /tmp en tmpfs (nécessaire si votre app écrit temporairement)
# Activer rootfs en lecture seule
# Supprimer capacités Linux inutiles
# Interdire l'élévation de privilèges
# Ajouter un masque d'UMASK, limiter accès au clock (selon besoin)
docker run --rm --network=host \
  -e DB_HOST=127.0.0.1 -e DB_PORT=3306 -e DB_NAME=appdb \
  -e DB_USER=appuser -e DB_PASSWORD='MotDePasse!Fort2025' \
  -p 5000:5000 \
  --name backend_secure \
  --read-only \
  --tmpfs /tmp:rw,noexec,nosuid,size=64m \
  --cap-drop ALL \
  --security-opt no-new-privileges \
  --ulimit nofile=4096:4096 \
  synthese-backend:v3
```

**Attendu :** l’API continue de répondre, `HEALTHCHECK` passe à `healthy`, et les endpoints `/health`, `/api/products` fonctionnent.

---

## 7) Front v1 — Dockerfile minimal (Nginx) pour servir le statique

**Objectif :** servir `index.html`, `style.css`, `app.js` depuis un conteneur simple.

Créer le fichier **frontend/Dockerfile.v1** :

```dockerfile
# Nginx officiel (stable, compact)
FROM nginx:1.27-alpine

# Répertoire par défaut des contenus statiques Nginx
WORKDIR /usr/share/nginx/html

# Copier le front (HTML/CSS/JS)
COPY index.html ./index.html
COPY style.css  ./style.css
COPY app.js     ./app.js

# Nginx écoute 80
EXPOSE 80

# CMD par défaut fourni par l'image officielle
```

### Build & run

```bash
cd ~/projet-synthese/frontend
docker build -f Dockerfile.v1 -t synthese-front:v1 .

# Lancer le front sur 8080
docker run --rm -p 8080:80 --name front_v1 synthese-front:v1
```

**Vérifier :**

- Front : [http://127.0.0.1:8080](http://127.0.0.1:8080)

- API : [http://127.0.0.1:5000](http://127.0.0.1:5000)

- L’appli web doit afficher les produits (CORS déjà pris en charge côté backend).

> **Note CORS** : si vous changez l’origine du front (autre port/domaine), mettez à jour l’en-tête `Access-Control-Allow-Origin` dans `app.py` (étape 2).

---

## 8) Vérifications / résultats attendus

- `docker ps` → backend **healthy** (v2/v3) après quelques secondes.

- `curl -s http://127.0.0.1:5000/health` → `{"status":"ok","db":true}` (HTTP 200).

- Front [http://127.0.0.1:8080](http://127.0.0.1:8080) → tableau rempli.

- `docker image ls` → la taille diminue entre v1 → v3 (multi-stage + venv copié).

---

## 9) Nettoyage / rollback

```bash
# Arrêts
docker rm -f backend_v1 backend_v2 backend_v3 backend_secure front_v1 2>/dev/null || true

# (Optionnel) Suppression des images construites
docker rmi synthese-backend:v1 synthese-backend:v2 synthese-backend:v3 synthese-front:v1 2>/dev/null || true
```

---

## 10) Astuces & pièges

- **Accès MySQL hôte :** en dev local Linux, `--network=host` est le plus simple.  
  Sinon, utilisez la **gateway docker** :  
  `GW=$(ip route | awk '/default/ {print $3}')` puis `-e DB_HOST=${GW}`.

- **Cache pip** : le multi-stage (v3) évite d’embarquer `pip` et ses caches en runtime.

- **Non-root** : toujours préférer un **USER** applicatif. Combinez avec `--cap-drop ALL` et `--security-opt no-new-privileges`.

- **Rootfs read-only** : n’oubliez pas `--tmpfs /tmp` si votre app écrit (logs/tmp).

- **Healthcheck** : préférez un check applicatif (`/health`) sans dépendances externes.

- **.dockerignore** : indispensable pour réduire le contexte de build (gains notables).



---

# Étape 4 — Montage avec Docker Compose (backend + front), DB MySQL sur l’hôte

## 1) Contexte & objectif

- Orchestrer nos deux services (**backend** + **front**) via **Docker Compose**.

- **MySQL reste sur l’hôte** (non conteneurisé) — on y accède depuis le backend via l’alias spécial `host.docker.internal` mappé sur la gateway hôte.

- Mettre en pratique : `build`, `image`, `env_file`, `depends_on` (ordre de démarrage), `healthcheck` (déjà dans l’image backend), `restart`, `networks`, `extra_hosts`.

## 2) Préparation de l’environnement

Arborescence attendue (suite des étapes précédentes) :

```
~/projet-synthese/
├── backend/
│   ├── app.py
│   ├── requirements.txt
│   ├── Dockerfile.v3          # créé à l’étape 3
│   └── .dockerignore          # créé à l’étape 3
└── frontend/
    ├── index.html
    ├── style.css
    ├── app.js
    └── Dockerfile.v1          # créé à l’étape 3
```

Créez maintenant un dossier `compose/` pour centraliser les fichiers Compose.

```bash
mkdir -p ~/projet-synthese/compose
```

---

## 3) Création des fichiers (commentés)

Créer le fichier **~/projet-synthese/compose/.env** :

```bash
# Fichier .env "projet" lu automatiquement par Docker Compose
# Variables transverses (exposées à l'expansion dans docker-compose.yml)

# Ports publiés (hôte:conteneur)
FRONT_HTTP_PORT=8080
BACK_HTTP_PORT=5000

# Nom du réseau applicatif
APP_NETWORK=webnet

# Nom de projet compose (facilite docker compose ps, logs, etc.)
COMPOSE_PROJECT_NAME=projet_synthese
```

Créer le fichier **~/projet-synthese/compose/backend.env** :

```bash
# Variables d'environnement injectées dans le service backend (env_file:)
# DB MySQL sur l'hôte Ubuntu (étape 1). On mappe host.docker.internal -> host-gateway
DB_HOST=host.docker.internal
DB_PORT=3306
DB_NAME=appdb
DB_USER=appuser
DB_PASSWORD=MotDePasse!Fort2025

# Paramètres API Flask (le code respecte déjà API_HOST/API_PORT par défaut)
API_HOST=0.0.0.0
API_PORT=5000
```

Créer le fichier **~/projet-synthese/compose/docker-compose.yml** :

```yaml
version: "3.9"

# Projet de synthèse : front (Nginx) + backend (Flask/Gunicorn)
# Base MySQL tourne sur l'hôte (Ubuntu 25.04), pas dans ce Compose.

name: ${COMPOSE_PROJECT_NAME}

services:
  backend:
    # On reconstruit à partir du Dockerfile durci (multi-stage + user non-root)
    build:
      context: ../backend
      dockerfile: Dockerfile.v3
    image: synthese-backend:compose
    container_name: backend_api
    env_file:
      - ./backend.env
    # On publie le port API (5000) sur l'hôte (variable via .env de projet)
    ports:
      - "${BACK_HTTP_PORT}:5000"
    # Le healthcheck est déjà défini dans l'image (Dockerfile.v3)
    restart: unless-stopped
    # Astuce Linux : mappe host.docker.internal vers la gateway de l'hôte (Docker 20.10+)
    extra_hosts:
      - "host.docker.internal:host-gateway"
    networks:
      - ${APP_NETWORK}
    # Démarrer avant le front (ordre logique pour éviter les erreurs 502 côté front si proxy)
    # NB : depends_on n'attend PAS "ready", juste "lancement". Ici OK, car le front est statique.
    depends_on: []

  front:
    build:
      context: ../frontend
      dockerfile: Dockerfile.v1
    image: synthese-front:compose
    container_name: front_web
    ports:
      - "${FRONT_HTTP_PORT}:80"
    restart: unless-stopped
    networks:
      - ${APP_NETWORK}
    depends_on:
      - backend

networks:
  ${APP_NETWORK}:
    driver: bridge
```

> Remarques importantes :
> 
> - `extra_hosts: "host.docker.internal:host-gateway"` permet au **backend conteneurisé** d’accéder à **MySQL sur l’hôte** via `DB_HOST=host.docker.internal` (dans `backend.env`).
> 
> - CORS est déjà géré dans `app.py` (autorise `http://localhost:8080`). Si vous changez le port front, adaptez l’en-tête dans le backend.

---

## 4) Exécution pas à pas

### 4.1 — Construire et démarrer

```bash
cd ~/projet-synthese/compose

# 1) Construire les images et démarrer en détaché
docker compose up -d --build

# 2) Visualiser l’état des services
docker compose ps

# 3) Suivre les logs (backend d’abord, puis front)
docker compose logs -f backend
# (CTRL+C pour quitter)
docker compose logs -f front
```

### 4.2 — Vérifications (API + Front)

```bash
# Tester l'API exposée par Compose (via port BACK_HTTP_PORT depuis .env)
curl -s http://127.0.0.1:${BACK_HTTP_PORT}/health
curl -s http://127.0.0.1:${BACK_HTTP_PORT}/api/products | python3 -m json.tool | head -n 20
```

Ouvrez ensuite votre navigateur :

- Front : **[http://127.0.0.1:8080](http://127.0.0.1:8080)** (ou le port défini par `FRONT_HTTP_PORT` dans `.env`)

- Attendu : statut *API: OK* et tableau des produits.

---

## 5) Résultats attendus

- `docker compose ps` → 2 services **Up**, `backend` passera **healthy** après quelques secondes (healthcheck image).

- `GET /health` depuis l’hôte (port `BACK_HTTP_PORT`) → `{"status":"ok","db":true}`.

- Front (port `FRONT_HTTP_PORT`) → liste des 3 produits stockés dans MySQL hôte.

---

## 6) Nettoyage / rollback

```bash
cd ~/projet-synthese/compose

# Arrêter et supprimer les ressources (conteneurs, réseau, mais conserve les images)
docker compose down

# (Optionnel) Tout supprimer, y compris les images du projet
# docker compose down --rmi all
```

---

## 7) Astuces & pièges

- **Accès MySQL hôte** : l’entrée
  
  ```
  extra_hosts:
    - "host.docker.internal:host-gateway"
  ```
  
  - `DB_HOST=host.docker.internal` est la méthode moderne la plus fiable pour Linux.  
    (Évite `--network=host` qui complique le front.)

- **CORS** : si vous changez `FRONT_HTTP_PORT`, modifiez l’origine autorisée dans `app.py` (en-tête `Access-Control-Allow-Origin`).

- **Restart policy** : `unless-stopped` est confortable en dev. En prod, combinez avec des probes de plateforme (K8s, Swarm) ou un orchestrateur externe.

- **Logs & debug** : `docker compose logs -f backend` aide à confirmer la connexion DB et la disponibilité de l’API.

- **Variables** : gardez les secrets hors Git (ex : `backend.env` ignoré par défaut). Pour la prod, préférez un secret store (Vault, Swarm secrets, K8s Secrets).

---

### ✅ Étape 4 terminée

Si c’est validé, on enchaîne **Étape 5** : une **série d’exercices progressifs et incrémentiels** exploitant les notions phares du document d’origine (Compose) :

- `environment` vs `env_file` (priorités),

- `depends_on` + `condition: service_healthy` (avec un service DB en conteneur pour la démo),

- `healthcheck` (front ou backend),

- `restart` (cas par cas),

- réseaux (`internal`, `aliases`, IPAM),

- volumes (bind vs named, droits, read-only),

- `build` + `image` combinés, cache et `.dockerignore`,

- renforcement sécurité (`read_only`, `cap_drop`, `no-new-privileges`).
