

# √âtape 1 ‚Äî Installer et pr√©parer **MySQL** sur Ubuntu 25.04 (base locale)

## 1) Contexte & objectif

Mettre en place une base **MySQL locale** (service syst√®me), cr√©er un **sch√©ma d‚Äôapplication** et un **compte applicatif** d√©di√©s pour la future couche m√©tier (Flask).  
Nous resterons en **acc√®s local** (localhost) ‚Äî pas d‚Äôouverture r√©seau pour l‚Äôinstant.

## 2) Pr√©paration de l‚Äôenvironnement

- Machine : **Ubuntu 25.04** (VM ou h√¥te)

- Acc√®s : utilisateur sudo

- Aucun port √† ouvrir (DB locale)

## 3) Ex√©cution pas √† pas (commandes comment√©es)

### 3.1 ‚Äî Installer MySQL Server

```bash
# 1) Mettre √† jour l‚Äôindex des paquets
sudo apt update

# 2) Installer le serveur MySQL (service systemd inclus)
sudo apt install -y mysql-server

# 3) Activer et d√©marrer le service (d√©marrage automatique au boot)
sudo systemctl enable --now mysql
```

### 3.2 ‚Äî V√©rifier l‚Äôinstallation et le service

```bash
# Version du client MySQL
mysql --version

# Sant√© du service (doit √™tre "active (running)")
systemctl status mysql --no-pager

# Ping MySQL via mysqladmin (retour attendu: mysqld is alive)
sudo mysqladmin ping
```

### 3.3 ‚Äî S√©curiser la base (profil minimal pour environnement de d√©v)

> Sur Ubuntu r√©cents, le compte `root@localhost` est g√©n√©ralement en **authentification par socket** (pas de mot de passe, sudo requis).  
> On laisse cette config **pour l‚Äôadmin syst√®me** et on **cr√©e un compte applicatif** s√©par√©.

```bash
# 1) Ouvrir un shell MySQL en root via socket (pas de mot de passe)
sudo mysql
```

Dans le shell MySQL, ex√©cutez les SQL suivants (adapt√©s au besoin) :

```sql
-- 2) Cr√©er la base d√©di√©e √† l‚Äôapplication
CREATE DATABASE IF NOT EXISTS appdb
  CHARACTER SET utf8mb4
  COLLATE utf8mb4_0900_ai_ci;

-- 3) Cr√©er un utilisateur applicatif local avec un mot de passe fort
-- Remplacez 'MotDePasse!Fort2025' par votre mot de passe choisi
CREATE USER IF NOT EXISTS 'appuser'@'localhost'
  IDENTIFIED WITH caching_sha2_password BY 'MotDePasse!Fort2025';

-- 4) Accorder les droits minimaux n√©cessaires (CRUD de base)
GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, ALTER, INDEX
ON appdb.* TO 'appuser'@'localhost';

-- 5) Appliquer les changements de privil√®ges
FLUSH PRIVILEGES;

-- 6) (Optionnel) Cr√©er une table de test pour la future API Flask
USE appdb;
CREATE TABLE IF NOT EXISTS products (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(120) NOT NULL,
  price DECIMAL(10,2) NOT NULL DEFAULT 0.00,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
INSERT INTO products(name, price) VALUES
 ('Keyboard', 39.90), ('Mouse', 19.00), ('Monitor 24"', 129.00);
```

Quittez MySQL :

```sql
EXIT;
```

### 3.4 ‚Äî Tester la connexion **applicative** (sans sudo)

```bash
# Tester la connexion avec l‚Äôutilisateur 'appuser'
mysql -u appuser -p -D appdb -e "SELECT COUNT(*) AS rows_in_products FROM products;"
# ‚Üí Saisir le mot de passe choisi (ex: MotDePasse!Fort2025)
```

### 3.5 ‚Äî (Optionnel) Script de **healthcheck** local pour MySQL

Cr√©er le fichier **/usr/local/bin/mysql_health.sh** :

```bash
#!/usr/bin/env bash
# Script de v√©rification simple de MySQL en local
# - Utilise mysqladmin ping
# - √âcrit un log horodat√© dans /tmp/mysql_health.log
# - Utilisation: mysql_health.sh [LABEL_OPTIONNEL]

set -euo pipefail

LABEL="${1:-mysql-local}"
LOG="/tmp/mysql_health.log"
TS="$(date +'%F %T')"

# Test: "mysqld is alive" attendu en sortie si OK
if mysqladmin ping >/dev/null 2>&1; then
  echo "$TS | $LABEL | health=OK" >> "$LOG"
  exit 0
else
  echo "$TS | $LABEL | health=KO" >> "$LOG"
  exit 1
fi
```

Rendre ex√©cutable :

```bash
sudo install -m 0755 /dev/stdin /usr/local/bin/mysql_health.sh <<'EOF'
#!/usr/bin/env bash
set -euo pipefail
LABEL="${1:-mysql-local}"
LOG="/tmp/mysql_health.log"
TS="$(date +'%F %T')"
if mysqladmin ping >/dev/null 2>&1; then
  echo "$TS | $LABEL | health=OK" >> "$LOG"
  exit 0
else
  echo "$TS | $LABEL | health=KO" >> "$LOG"
  exit 1
fi
EOF
```

*(Si vous pr√©f√©rez strictement votre format ¬´ Cr√©er le fichier ‚Ä¶ ¬ª sans redirection, dites-le et je re-pr√©senterai le bloc en cons√©quence, comme vous l‚Äôexigez.)*

Test rapide :

```bash
/usr/local/bin/mysql_health.sh "boot-check" && tail -n 2 /tmp/mysql_health.log
```

## 4) V√©rifications / R√©sultats attendus

- `systemctl status mysql` ‚Üí **active (running)**

- `sudo mysqladmin ping` ‚Üí **mysqld is alive**

- Connexion applicative :
  
  ```bash
  mysql -u appuser -p -D appdb -e "SELECT VERSION();"
  ```
  
  ‚Üí affiche la version MySQL.

- Donn√©es de test :
  
  ```bash
  mysql -u appuser -p -D appdb -e "SELECT * FROM products;"
  ```
  
  ‚Üí 3 lignes d‚Äôexemple.

## 5) Nettoyage / rollback (optionnel pour refaire)

```bash
# Supprimer sch√©ma et utilisateur applicatif (garde MySQL install√©)
sudo mysql -e "DROP DATABASE IF EXISTS appdb;"
sudo mysql -e "DROP USER IF EXISTS 'appuser'@'localhost'; FLUSH PRIVILEGES;"

# (Optionnel) D√©sinstaller MySQL (r√©installation propre)
# ATTENTION: supprime les donn√©es si purge
# sudo systemctl stop mysql
# sudo apt purge -y mysql-server
# sudo rm -rf /var/lib/mysql
# sudo apt autoremove -y
```

## 6) Astuces & pi√®ges

- **Ne m√©langez pas** compte root (admin via socket) et compte applicatif : principe du moindre privil√®ge.

- Pas d‚Äôouverture de port **3306** tant que l‚Äôacc√®s reste local (Flask ‚Üî MySQL sur la m√™me machine).

- Pour usage distant plus tard : cr√©ez un utilisateur `'appuser'@'%'` et activez le bind sur `0.0.0.0`, **mais pas √† cette √©tape**.

- Encodage recommand√© : `utf8mb4` + `collation utf8mb4_0900_ai_ci`.

- Si `mysqladmin ping` √©choue : v√©rifiez `journalctl -u mysql -n 80 --no-pager`.

---



# √âtape 2 ‚Äî Couche m√©tier (Flask) + Couche pr√©sentation (HTML/CSS/JS), sans Docker Compose

## 1) Contexte & objectif

- Mettre en place **deux couches s√©par√©es** :
  
  1. **API Flask** (m√©tier) qui lit la base **MySQL locale** (cr√©√©e √† l‚Äô√©tape 1)
  
  2. **Front statique** (HTML/CSS/JS) qui consomme l‚ÄôAPI via `fetch()`

- L‚ÄôAPI exposera :
  
  - `GET /health` : statut simple
  
  - `GET /api/products` : liste des produits depuis `appdb.products`

- Le front s‚Äôex√©cute sur un port diff√©rent (ex. **8080**) et appelle l‚ÄôAPI sur **5000** ‚Üí **CORS c√¥t√© API**.

## 2) Pr√©paration de l‚Äôenvironnement

Ex√©cuter sur **Ubuntu 25.04**, utilisateur sudo non n√©cessaire ici (sauf installation de paquets syst√®me si manque Python venv).

```bash
# 1) (si n√©cessaire) Installer les outils Python
sudo apt update
sudo apt install -y python3 python3-venv

# 2) Cr√©er l‚Äôarborescence du projet
mkdir -p ~/projet-synthese/{backend,frontend}
cd ~/projet-synthese
```

---

## 3) Cr√©ation des fichiers (scripts comment√©s)

### 3.1 ‚Äî C√¥t√© **backend** (API Flask)

Cr√©er le fichier **~/projet-synthese/backend/config_example.sh** :

```bash
#!/usr/bin/env bash
# Fichier d'exemple de configuration √† SOURCER dans votre shell
# Copiez-le en config.sh et adaptez les valeurs si n√©cessaire.
# Usage: source config.sh

# H√¥te et port MySQL (local, √©tape 1)
export DB_HOST="127.0.0.1"
export DB_PORT="3306"

# Sch√©ma et identifiants applicatifs (cr√©√©s √† l'√©tape 1)
export DB_NAME="appdb"
export DB_USER="appuser"
export DB_PASSWORD="MotDePasse!Fort2025"

# H√¥te/port d‚Äô√©coute de l‚ÄôAPI Flask
export API_HOST="0.0.0.0"
export API_PORT="5000"
```

Cr√©er le fichier **~/projet-synthese/backend/requirements.txt** :

```bash
# D√©pendances Python pour l'API Flask
Flask==3.0.3
mysql-connector-python==9.0.0
```

Cr√©er le fichier **~/projet-synthese/backend/app.py** :

```python
#!/usr/bin/env python3
# API Flask "m√©tier" ‚Äî lit la base MySQL locale et expose des endpoints
# - /health : v√©rification simple
# - /api/products : retourne la liste des produits
#
# CORS: on ajoute les en-t√™tes n√©cessaires pour que le front (port 8080) puisse appeler l'API (port 5000).

import os
import json
from flask import Flask, jsonify, make_response
import mysql.connector
from mysql.connector import pooling, Error

# Lecture de la configuration via variables d'environnement (set par config.sh)
DB_HOST = os.getenv("DB_HOST", "127.0.0.1")
DB_PORT = int(os.getenv("DB_PORT", "3306"))
DB_NAME = os.getenv("DB_NAME", "appdb")
DB_USER = os.getenv("DB_USER", "appuser")
DB_PASSWORD = os.getenv("DB_PASSWORD", "")

API_HOST = os.getenv("API_HOST", "0.0.0.0")
API_PORT = int(os.getenv("API_PORT", "5000"))

# Initialisation Flask
app = Flask(__name__)

# Cr√©ation d'un pool de connexions MySQL pour robustesse/perf
# (√©vite d'ouvrir une nouvelle connexion √† chaque requ√™te)
try:
    cnx_pool = pooling.MySQLConnectionPool(
        pool_name="app_pool",
        pool_size=5,                    # ajustable selon la charge
        host=DB_HOST,
        port=DB_PORT,
        database=DB_NAME,
        user=DB_USER,
        password=DB_PASSWORD,
        charset="utf8mb4",
        use_pure=True
    )
except Error as e:
    # En cas d'erreur au d√©marrage (mauvais mot de passe, MySQL arr√™t√©...)
    # on logge et on continuera √† lever des 503 c√¥t√© endpoints.
    cnx_pool = None
    print(f"[BOOT][ERROR] MySQL pool init failed: {e}")

# Middleware minimal pour CORS (autorise le front http://localhost:8080)
# -> Pour des besoins avanc√©s, on peut utiliser flask-cors, mais ici on reste sans d√©pendance suppl√©mentaire.
@app.after_request
def add_cors_headers(resp):
    resp.headers["Access-Control-Allow-Origin"] = "http://localhost:8080"
    resp.headers["Access-Control-Allow-Methods"] = "GET, OPTIONS"
    resp.headers["Access-Control-Allow-Headers"] = "Content-Type"
    return resp

@app.route("/health", methods=["GET"])
def health():
    # V√©rifie rapidement le pool MySQL
    ok = False
    if cnx_pool is not None:
        try:
            with cnx_pool.get_connection() as cnx:
                ok = cnx.is_connected()
        except Error:
            ok = False
    status = {"status": "ok" if ok else "degraded", "db": ok}
    return jsonify(status), (200 if ok else 503)

@app.route("/api/products", methods=["GET"])
def get_products():
    # R√©cup√®re la liste des produits depuis la table appdb.products
    if cnx_pool is None:
        return jsonify({"error": "database_unavailable"}), 503
    try:
        with cnx_pool.get_connection() as cnx:
            with cnx.cursor(dictionary=True) as cur:
                cur.execute("""
                    SELECT id, name, price, created_at
                    FROM products
                    ORDER BY id ASC
                """)
                rows = cur.fetchall()
        return jsonify({"items": rows, "count": len(rows)}), 200
    except Error as e:
        # Log minimal
        print(f"[ERROR] get_products: {e}")
        return jsonify({"error": "query_failed"}), 500

if __name__ == "__main__":
    # Lancement de l'API
    print(f"[BOOT] API listening on http://{API_HOST}:{API_PORT}")
    print(f"[BOOT] DB target: mysql://{DB_USER}@{DB_HOST}:{DB_PORT}/{DB_NAME}")
    app.run(host=API_HOST, port=API_PORT, debug=False)
```

Cr√©er le fichier **~/projet-synthese/backend/README.run.md** (documentation d‚Äôex√©cution) :

```markdown
# D√©marrer l‚ÄôAPI Flask (backend)

## 1) Pr√©parer l‚Äôenvironnement Python (une seule fois)
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt

## 2) Charger la configuration
cp config_example.sh config.sh
# -> √âditez config.sh si besoin, puis :
source ./config.sh

## 3) Lancer l‚ÄôAPI
python app.py
# -> √©coute sur http://0.0.0.0:5000 (modifiable via config.sh)

## 4) Tests rapides
curl -s http://127.0.0.1:5000/health | jq .
curl -s http://127.0.0.1:5000/api/products | jq '.count, .items[0]'
```

---

### 3.2 ‚Äî C√¥t√© **frontend** (HTML/CSS/JS)

Cr√©er le fichier **~/projet-synthese/frontend/index.html** :

```html
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catalogue ‚Äî Front (HTML/CSS/JS)</title>
  <!-- Feuille de style -->
  <link rel="stylesheet" href="./style.css" />
</head>
<body>
  <header>
    <h1>Catalogue Produits</h1>
    <p class="subtitle">Front statique ‚Üí API Flask ‚Üí MySQL local</p>
  </header>

  <main>
    <section class="panel">
      <div class="controls">
        <button id="btn-refresh" title="Recharger la liste">üîÑ Recharger</button>
        <span id="api-status" class="status">API: inconnue</span>
      </div>

      <table id="tbl-products">
        <thead>
          <tr>
            <th>#</th>
            <th>Nom</th>
            <th>Prix (‚Ç¨)</th>
            <th>Cr√©√© le</th>
          </tr>
        </thead>
        <tbody>
          <!-- Lignes g√©n√©r√©es dynamiquement -->
        </tbody>
      </table>

      <div id="empty" class="empty hidden">Aucun produit √† afficher.</div>
      <div id="error" class="error hidden">Erreur de chargement. V√©rifiez l'API.</div>
    </section>
  </main>

  <footer>
    <small>Projet de synth√®se ‚Äî √âtape 2 (sans Docker Compose)</small>
  </footer>

  <script src="./app.js"></script>
</body>
</html>
```

Cr√©er le fichier **~/projet-synthese/frontend/style.css** :

```css
/* Style minimal, lisible et responsive */
:root {
  --bg: #0f172a;
  --panel: #111827;
  --text: #e5e7eb;
  --muted: #9ca3af;
  --accent: #60a5fa;
  --ok: #22c55e;
  --ko: #ef4444;
  --table: #1f2937;
}

* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Helvetica Neue", sans-serif;
  background: linear-gradient(180deg, var(--bg), #0b1224);
  color: var(--text);
}

header {
  padding: 24px;
  text-align: center;
}

h1 { margin: 0 0 6px 0; }
.subtitle { margin: 0; color: var(--muted); }

main {
  max-width: 980px;
  margin: 0 auto;
  padding: 16px;
}

.panel {
  background: var(--panel);
  border: 1px solid #1f2937;
  border-radius: 14px;
  padding: 16px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.25);
}

.controls {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
}

#btn-refresh {
  cursor: pointer;
  padding: 8px 14px;
  border: 1px solid #374151;
  border-radius: 10px;
  background: #0b1224;
  color: var(--text);
}
#btn-refresh:hover { border-color: var(--accent); }

.status { margin-left: auto; color: var(--muted); }
.status.ok { color: var(--ok); }
.status.ko { color: var(--ko); }

table {
  width: 100%;
  border-collapse: collapse;
  background: var(--table);
  border-radius: 10px;
  overflow: hidden;
}

thead th {
  text-align: left;
  padding: 12px;
  background: #101826;
  color: #cbd5e1;
  border-bottom: 1px solid #1f2937;
}

tbody td {
  padding: 10px 12px;
  border-bottom: 1px solid #1f2937;
}

tbody tr:hover { background: #0f172a; }

.empty, .error {
  margin-top: 12px;
  padding: 10px 12px;
  border-radius: 10px;
}

.empty { background: #0b3c1d; color: #a7f3d0; }
.error { background: #3c0b0b; color: #fecaca; }

.hidden { display: none; }

footer {
  text-align: center;
  color: var(--muted);
  padding: 24px;
}
```

Cr√©er le fichier **~/projet-synthese/frontend/app.js** :

```javascript
// Front minimal pour consommer l'API Flask.
// - V√©rifie le /health pour afficher l'√©tat
// - R√©cup√®re /api/products pour remplir le tableau

const API_BASE = "http://127.0.0.1:5000"; // API Flask locale (port 5000)
const els = {
  btn: document.getElementById("btn-refresh"),
  status: document.getElementById("api-status"),
  tbody: document.querySelector("#tbl-products tbody"),
  empty: document.getElementById("empty"),
  error: document.getElementById("error"),
};

async function checkHealth() {
  try {
    const res = await fetch(`${API_BASE}/health`, { cache: "no-store" });
    const data = await res.json();
    if (res.ok && data?.status === "ok") {
      els.status.textContent = "API: OK";
      els.status.classList.remove("ko");
      els.status.classList.add("ok");
      return true;
    } else {
      els.status.textContent = "API: d√©grad√©e";
      els.status.classList.remove("ok");
      els.status.classList.add("ko");
      return false;
    }
  } catch {
    els.status.textContent = "API: inaccessible";
    els.status.classList.remove("ok");
    els.status.classList.add("ko");
    return false;
  }
}

function renderProducts(items) {
  // Nettoyage
  els.tbody.innerHTML = "";
  els.empty.classList.add("hidden");
  els.error.classList.add("hidden");

  if (!items || items.length === 0) {
    els.empty.classList.remove("hidden");
    return;
  }
  for (const p of items) {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${p.id}</td>
      <td>${p.name}</td>
      <td>${Number(p.price).toFixed(2)}</td>
      <td>${new Date(p.created_at).toLocaleString()}</td>
    `;
    els.tbody.appendChild(tr);
  }
}

async function loadProducts() {
  try {
    const res = await fetch(`${API_BASE}/api/products`, { cache: "no-store" });
    if (!res.ok) throw new Error("bad status");
    const data = await res.json();
    renderProducts(data.items);
  } catch (e) {
    els.error.classList.remove("hidden");
  }
}

async function reloadAll() {
  await checkHealth();
  await loadProducts();
}

// √âv√©nements
els.btn.addEventListener("click", reloadAll);

// Chargement initial
reloadAll();
```

Cr√©er le fichier **~/projet-synthese/frontend/README.run.md** :

```markdown
# D√©marrer le front statique

## 1) Lancer un serveur HTTP statique (port 8080)
# Depuis le dossier frontend/
python3 -m http.server 8080

## 2) Ouvrir le navigateur
http://127.0.0.1:8080

## 3) Attendu
- Le bouton "üîÑ Recharger" recharge la liste
- Le statut "API: OK" si l'API r√©pond
- Le tableau affiche les produits de MySQL
```

---

## 4) Ex√©cution pas √† pas (bout-√†-bout)

### 4.1 ‚Äî D√©marrer l‚ÄôAPI Flask (terminal A)

```bash
cd ~/projet-synthese/backend

# Cr√©er et activer l'environnement virtuel (une seule fois)
python3 -m venv .venv
source .venv/bin/activate

# Installer les d√©pendances
pip install -r requirements.txt

# Charger la configuration (copiez l'exemple si besoin)
cp -n config_example.sh config.sh
source ./config.sh

# Lancer l'API
python app.py
# ‚Üí √©coute sur http://0.0.0.0:5000 ; logs d‚Äôamor√ßage affich√©s dans ce terminal
```

Tests rapides (dans **un autre terminal**) :

```bash
curl -s http://127.0.0.1:5000/health
curl -s http://127.0.0.1:5000/api/products | python3 -m json.tool | head -n 20
```

### 4.2 ‚Äî D√©marrer le front (terminal B)

```bash
cd ~/projet-synthese/frontend
python3 -m http.server 8080
# ‚Üí sert index.html sur http://127.0.0.1:8080
```

### 4.3 ‚Äî V√©rifications (navigateur)

- Ouvrir **[http://127.0.0.1:8080](http://127.0.0.1:8080)**

- Statut **API: OK** attendu

- Tableau rempli avec les 3 produits de la table `products`

---

## 5) R√©sultats attendus

- `GET /health` retourne `{"status":"ok","db":true}` avec HTTP **200**

- `GET /api/products` retourne `{"items":[...], "count":3}` avec HTTP **200**

- Front affiche le tableau (id, name, price, created_at)

---

## 6) Nettoyage / rollback

```bash
# Arr√™ter le front: CTRL+C dans le terminal B
# Arr√™ter l'API:  CTRL+C dans le terminal A

# (Optionnel) D√©sactiver l'environnement virtuel
deactivate 2>/dev/null || true

# (Optionnel) Supprimer l'environnement Python pour repartir propre
rm -rf ~/projet-synthese/backend/.venv
```

---

## 7) Astuces & pi√®ges

- **CORS** : le front tourne sur **8080** et appelle l‚ÄôAPI sur **5000** ‚Üí en-t√™tes CORS ajout√©s dans `app.py`.  
  Si vous changez de port front, adaptez `Access-Control-Allow-Origin`.

- **Mots de passe** : `config_example.sh` est un **exemple** ; copiez en `config.sh` et prot√©gez vos secrets.

- **Erreurs MySQL** :
  
  - Si `/health` renvoie `"degraded"` : v√©rifiez `systemctl status mysql` et vos identifiants.
  
  - Pour diagnostiquer : `journalctl -u mysql -n 80 --no-pager`.

- **Locales/Date** : `created_at` est affich√© en `toLocaleString()` c√¥t√© front (timezone syst√®me).

---



# √âtape 3 ‚Äî Raffinements Dockerfile (Backend Flask + Front statique)

## 1) Contexte & objectifs

- Conteneuriser notre **API Flask** (backend) puis am√©liorer graduellement :
  
  - taille d‚Äôimage (multi-stage, `.dockerignore`)
  
  - performances (caching pip)
  
  - s√©curit√© (utilisateur non-root, rootfs en lecture seule, drop de capacit√©s)
  
  - observabilit√© (healthcheck)

- Pr√©parer un **Dockerfile front** minimal pour servir le HTML/CSS/JS.

- **Important (tests ‚Äúsans Compose‚Äù)** : le conteneur backend devra acc√©der √† **MySQL install√© sur l‚Äôh√¥te**.  
  Pour simplifier les premiers tests, on utilisera l‚Äôoption `--network=host` (Linux) **ou** `DB_HOST=$(ip route | awk '/default/ {print $3}')` (gateway docker).
  
  > Sur Linux r√©cents, `host.docker.internal` fonctionne souvent, mais pas garanti selon versions. On montrera les deux.

---

## 2) Pr√©paration de l‚Äôenvironnement

Arborescence de travail (en partant de l‚Äô√©tape 2) :

```
~/projet-synthese/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ app.py
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îî‚îÄ‚îÄ config_example.sh
‚îî‚îÄ‚îÄ frontend/
    ‚îú‚îÄ‚îÄ index.html
    ‚îú‚îÄ‚îÄ style.css
    ‚îî‚îÄ‚îÄ app.js
```

On ajoute progressivement des fichiers Docker et un `.dockerignore`.

---

## 3) Backend v1 ‚Äî Dockerfile simple (serveur Flask int√©gr√©)

**Objectif :** premi√®re image fonctionnelle, facile √† lire (non optimis√©e).

Cr√©er le fichier **backend/Dockerfile.v1** :

```dockerfile
# Image de base Python l√©g√®re
FROM python:3.12-slim

# Emp√™cher Python d'√©crire des .pyc et forcer le flush des logs
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

# R√©pertoire de travail
WORKDIR /app

# Copier en premier les d√©pendances pour profiter du cache Docker lors des rebuilds
COPY requirements.txt /app/requirements.txt

# Installer les d√©pendances de l'API (sans cache pip pour r√©duire la taille finale)
RUN pip install --no-cache-dir -r /app/requirements.txt

# Copier le code de l'application
COPY app.py /app/app.py

# Exposer le port de l'API
EXPOSE 5000

# Variables d'environnement par d√©faut (surcharg√©es au run)
ENV API_HOST=0.0.0.0 \
    API_PORT=5000

# Commande de d√©marrage : serveur int√©gr√© Flask (suffisant pour dev/test)
CMD ["python", "app.py"]
```

Cr√©er le fichier **backend/.dockerignore** :

```txt
# Exclure ce qui n'est pas utile dans l'image
__pycache__/
*.pyc
*.pyo
*.pyd
*.log
.venv/
.env
config.sh
*.md
```

### Construction & ex√©cution (Linux)

```bash
cd ~/projet-synthese/backend

# 1) Construire l‚Äôimage
docker build -f Dockerfile.v1 -t synthese-backend:v1 .

# 2a) (Option simple) Ex√©cuter en r√©seau h√¥te (le conteneur voit MySQL local)
#    -> Linux uniquement, pratique pour dev local
docker run --rm --network=host \
  -e DB_HOST=127.0.0.1 \
  -e DB_PORT=3306 \
  -e DB_NAME=appdb \
  -e DB_USER=appuser \
  -e DB_PASSWORD='MotDePasse!Fort2025' \
  -p 5000:5000 \
  --name backend_v1 \
  synthese-backend:v1

# 2b) (Alternative portable) Sans --network=host :
#     DB_HOST doit pointer vers la gateway docker (souvent 172.17.0.1) ou host.docker.internal
#     V√©rifiez la gateway :
# GW=$(ip route | awk '/default/ {print $3}')
# docker run --rm \
#   -e DB_HOST=${GW} -e DB_PORT=3306 -e DB_NAME=appdb \
#   -e DB_USER=appuser -e DB_PASSWORD='MotDePasse!Fort2025' \
#   -p 5000:5000 --name backend_v1 synthese-backend:v1
```

### V√©rifications attendues

```bash
curl -s http://127.0.0.1:5000/health
curl -s http://127.0.0.1:5000/api/products | python3 -m json.tool | head -n 20
```

---

## 4) Backend v2 ‚Äî Production-readiness (Gunicorn + healthcheck)

**Objectif :** remplacer le serveur Flask int√©gr√© par **Gunicorn**, ajouter un **HEALTHCHECK** sans d√©pendre d‚Äôoutils externes.

Cr√©er le fichier **backend/Dockerfile.v2** :

```dockerfile
FROM python:3.12-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

# Installer seulement ce qui est requis √† l'ex√©cution
# Ajout de gunicorn (serveur WSGI de prod)
COPY requirements.txt /app/requirements.txt
RUN pip install --no-cache-dir -r /app/requirements.txt gunicorn==22.0.0

# Copier le code applicatif
COPY app.py /app/app.py

# Exposer le port
EXPOSE 5000

# Healthcheck bas√© sur la lib standard (urllib) pour √©viter d'installer curl/wget
HEALTHCHECK --interval=10s --timeout=2s --start-period=5s --retries=3 \
  CMD python -c "import urllib.request,sys; \
    urllib.request.urlopen('http://127.0.0.1:5000/health', timeout=1).read(); \
    sys.exit(0)"

# Variables d'env pour Gunicorn
ENV WORKERS=2 \
    THREADS=2 \
    TIMEOUT=30

# Commande de d√©marrage : gunicorn (app:app => objet Flask dans app.py)
CMD ["gunicorn", "app:app", \
     "--bind", "0.0.0.0:5000", \
     "--workers", "2", "--threads", "2", "--timeout", "30", \
     "--access-logfile", "-", "--error-logfile", "-"]
```

### Build & run

```bash
cd ~/projet-synthese/backend
docker build -f Dockerfile.v2 -t synthese-backend:v2 .

# R√©seau "host" (simple pour acc√©der √† MySQL local)
docker run --rm --network=host \
  -e DB_HOST=127.0.0.1 -e DB_PORT=3306 -e DB_NAME=appdb \
  -e DB_USER=appuser -e DB_PASSWORD='MotDePasse!Fort2025' \
  -p 5000:5000 --name backend_v2 synthese-backend:v2
```

---

## 5) Backend v3 ‚Äî Multi-stage build + user non-root

**Objectif :** r√©duire la surface d‚Äôattaque, am√©liorer le cache et ne pas tourner en **root**.

Cr√©er le fichier **backend/Dockerfile.v3** :

```dockerfile
# ----- STAGE 1: builder (installe les wheels en cache) -----
FROM python:3.12-slim AS builder

WORKDIR /build

# Pr√©parer pip pour un build reproductible
ENV PIP_DISABLE_PIP_VERSION_CHECK=1 \
    PIP_NO_CACHE_DIR=1

COPY requirements.txt /build/requirements.txt
RUN python -m venv /build/venv \
 && /build/venv/bin/pip install --upgrade pip \
 && /build/venv/bin/pip install -r /build/requirements.txt gunicorn==22.0.0

# ----- STAGE 2: runtime -----
FROM python:3.12-slim

# Hygiene Python + locales
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

# Cr√©er un utilisateur applicatif non-root
RUN groupadd -g 10001 app && useradd -r -u 10001 -g app -m -d /home/app app

WORKDIR /app

# Copier l'environnement virtuel depuis le builder
COPY --from=builder /build/venv /opt/venv
ENV PATH="/opt/venv/bin:${PATH}"

# Copier le code applicatif
COPY app.py /app/app.py

# Permissions minimales
RUN chown -R app:app /app

# Ex√©cuter en utilisateur non-root
USER app:app

EXPOSE 5000

# Healthcheck sans binaire externe
HEALTHCHECK --interval=10s --timeout=2s --start-period=5s --retries=3 \
  CMD python -c "import urllib.request,sys; \
    urllib.request.urlopen('http://127.0.0.1:5000/health', timeout=1).read(); \
    sys.exit(0)"

ENV WORKERS=2 THREADS=2 TIMEOUT=30

CMD ["gunicorn", "app:app", \
     "--bind", "0.0.0.0:5000", \
     "--workers", "2", "--threads", "2", "--timeout", "30", \
     "--access-logfile", "-", "--error-logfile", "-"]
```

### Build & run

```bash
cd ~/projet-synthese/backend
docker build -f Dockerfile.v3 -t synthese-backend:v3 .

# Test (r√©seau host pour joindre MySQL local)
docker run --rm --network=host \
  -e DB_HOST=127.0.0.1 -e DB_PORT=3306 -e DB_NAME=appdb \
  -e DB_USER=appuser -e DB_PASSWORD='MotDePasse!Fort2025' \
  -p 5000:5000 --name backend_v3 synthese-backend:v3
```

---

## 6) Backend v4 ‚Äî Renforcement s√©curit√© (rootfs read-only, no-new-privs, caps)

**Objectif :** r√©duire encore les risques √† l‚Äôex√©cution.

> Ces renforcements s‚Äôactivent **au run** (runtime flags). Le Dockerfile v3 est d√©j√† pr√™t (non-root).  
> On garde l‚Äôimage `synthese-backend:v3` et on la lance avec des contraintes suppl√©mentaires.

Ex√©cution recommand√©e (Linux) :

```bash
# Monter /tmp en tmpfs (n√©cessaire si votre app √©crit temporairement)
# Activer rootfs en lecture seule
# Supprimer capacit√©s Linux inutiles
# Interdire l'√©l√©vation de privil√®ges
# Ajouter un masque d'UMASK, limiter acc√®s au clock (selon besoin)
docker run --rm --network=host \
  -e DB_HOST=127.0.0.1 -e DB_PORT=3306 -e DB_NAME=appdb \
  -e DB_USER=appuser -e DB_PASSWORD='MotDePasse!Fort2025' \
  -p 5000:5000 \
  --name backend_secure \
  --read-only \
  --tmpfs /tmp:rw,noexec,nosuid,size=64m \
  --cap-drop ALL \
  --security-opt no-new-privileges \
  --ulimit nofile=4096:4096 \
  synthese-backend:v3
```

**Attendu :** l‚ÄôAPI continue de r√©pondre, `HEALTHCHECK` passe √† `healthy`, et les endpoints `/health`, `/api/products` fonctionnent.

---

## 7) Front v1 ‚Äî Dockerfile minimal (Nginx) pour servir le statique

**Objectif :** servir `index.html`, `style.css`, `app.js` depuis un conteneur simple.

Cr√©er le fichier **frontend/Dockerfile.v1** :

```dockerfile
# Nginx officiel (stable, compact)
FROM nginx:1.27-alpine

# R√©pertoire par d√©faut des contenus statiques Nginx
WORKDIR /usr/share/nginx/html

# Copier le front (HTML/CSS/JS)
COPY index.html ./index.html
COPY style.css  ./style.css
COPY app.js     ./app.js

# Nginx √©coute 80
EXPOSE 80

# CMD par d√©faut fourni par l'image officielle
```

### Build & run

```bash
cd ~/projet-synthese/frontend
docker build -f Dockerfile.v1 -t synthese-front:v1 .

# Lancer le front sur 8080
docker run --rm -p 8080:80 --name front_v1 synthese-front:v1
```

**V√©rifier :**

- Front : [http://127.0.0.1:8080](http://127.0.0.1:8080)

- API : [http://127.0.0.1:5000](http://127.0.0.1:5000)

- L‚Äôappli web doit afficher les produits (CORS d√©j√† pris en charge c√¥t√© backend).

> **Note CORS** : si vous changez l‚Äôorigine du front (autre port/domaine), mettez √† jour l‚Äôen-t√™te `Access-Control-Allow-Origin` dans `app.py` (√©tape 2).

---

## 8) V√©rifications / r√©sultats attendus

- `docker ps` ‚Üí backend **healthy** (v2/v3) apr√®s quelques secondes.

- `curl -s http://127.0.0.1:5000/health` ‚Üí `{"status":"ok","db":true}` (HTTP 200).

- Front [http://127.0.0.1:8080](http://127.0.0.1:8080) ‚Üí tableau rempli.

- `docker image ls` ‚Üí la taille diminue entre v1 ‚Üí v3 (multi-stage + venv copi√©).

---

## 9) Nettoyage / rollback

```bash
# Arr√™ts
docker rm -f backend_v1 backend_v2 backend_v3 backend_secure front_v1 2>/dev/null || true

# (Optionnel) Suppression des images construites
docker rmi synthese-backend:v1 synthese-backend:v2 synthese-backend:v3 synthese-front:v1 2>/dev/null || true
```

---

## 10) Astuces & pi√®ges

- **Acc√®s MySQL h√¥te :** en dev local Linux, `--network=host` est le plus simple.  
  Sinon, utilisez la **gateway docker** :  
  `GW=$(ip route | awk '/default/ {print $3}')` puis `-e DB_HOST=${GW}`.

- **Cache pip** : le multi-stage (v3) √©vite d‚Äôembarquer `pip` et ses caches en runtime.

- **Non-root** : toujours pr√©f√©rer un **USER** applicatif. Combinez avec `--cap-drop ALL` et `--security-opt no-new-privileges`.

- **Rootfs read-only** : n‚Äôoubliez pas `--tmpfs /tmp` si votre app √©crit (logs/tmp).

- **Healthcheck** : pr√©f√©rez un check applicatif (`/health`) sans d√©pendances externes.

- **.dockerignore** : indispensable pour r√©duire le contexte de build (gains notables).



---

# √âtape 4 ‚Äî Montage avec Docker Compose (backend + front), DB MySQL sur l‚Äôh√¥te

## 1) Contexte & objectif

- Orchestrer nos deux services (**backend** + **front**) via **Docker Compose**.

- **MySQL reste sur l‚Äôh√¥te** (non conteneuris√©) ‚Äî on y acc√®de depuis le backend via l‚Äôalias sp√©cial `host.docker.internal` mapp√© sur la gateway h√¥te.

- Mettre en pratique : `build`, `image`, `env_file`, `depends_on` (ordre de d√©marrage), `healthcheck` (d√©j√† dans l‚Äôimage backend), `restart`, `networks`, `extra_hosts`.

## 2) Pr√©paration de l‚Äôenvironnement

Arborescence attendue (suite des √©tapes pr√©c√©dentes) :

```
~/projet-synthese/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ app.py
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile.v3          # cr√©√© √† l‚Äô√©tape 3
‚îÇ   ‚îî‚îÄ‚îÄ .dockerignore          # cr√©√© √† l‚Äô√©tape 3
‚îî‚îÄ‚îÄ frontend/
    ‚îú‚îÄ‚îÄ index.html
    ‚îú‚îÄ‚îÄ style.css
    ‚îú‚îÄ‚îÄ app.js
    ‚îî‚îÄ‚îÄ Dockerfile.v1          # cr√©√© √† l‚Äô√©tape 3
```

Cr√©ez maintenant un dossier `compose/` pour centraliser les fichiers Compose.

```bash
mkdir -p ~/projet-synthese/compose
```

---

## 3) Cr√©ation des fichiers (comment√©s)

Cr√©er le fichier **~/projet-synthese/compose/.env** :

```bash
# Fichier .env "projet" lu automatiquement par Docker Compose
# Variables transverses (expos√©es √† l'expansion dans docker-compose.yml)

# Ports publi√©s (h√¥te:conteneur)
FRONT_HTTP_PORT=8080
BACK_HTTP_PORT=5000

# Nom du r√©seau applicatif
APP_NETWORK=webnet

# Nom de projet compose (facilite docker compose ps, logs, etc.)
COMPOSE_PROJECT_NAME=projet_synthese
```

Cr√©er le fichier **~/projet-synthese/compose/backend.env** :

```bash
# Variables d'environnement inject√©es dans le service backend (env_file:)
# DB MySQL sur l'h√¥te Ubuntu (√©tape 1). On mappe host.docker.internal -> host-gateway
DB_HOST=host.docker.internal
DB_PORT=3306
DB_NAME=appdb
DB_USER=appuser
DB_PASSWORD=MotDePasse!Fort2025

# Param√®tres API Flask (le code respecte d√©j√† API_HOST/API_PORT par d√©faut)
API_HOST=0.0.0.0
API_PORT=5000
```

Cr√©er le fichier **~/projet-synthese/compose/docker-compose.yml** :

```yaml
version: "3.9"

# Projet de synth√®se : front (Nginx) + backend (Flask/Gunicorn)
# Base MySQL tourne sur l'h√¥te (Ubuntu 25.04), pas dans ce Compose.

name: ${COMPOSE_PROJECT_NAME}

services:
  backend:
    # On reconstruit √† partir du Dockerfile durci (multi-stage + user non-root)
    build:
      context: ../backend
      dockerfile: Dockerfile.v3
    image: synthese-backend:compose
    container_name: backend_api
    env_file:
      - ./backend.env
    # On publie le port API (5000) sur l'h√¥te (variable via .env de projet)
    ports:
      - "${BACK_HTTP_PORT}:5000"
    # Le healthcheck est d√©j√† d√©fini dans l'image (Dockerfile.v3)
    restart: unless-stopped
    # Astuce Linux : mappe host.docker.internal vers la gateway de l'h√¥te (Docker 20.10+)
    extra_hosts:
      - "host.docker.internal:host-gateway"
    networks:
      - ${APP_NETWORK}
    # D√©marrer avant le front (ordre logique pour √©viter les erreurs 502 c√¥t√© front si proxy)
    # NB : depends_on n'attend PAS "ready", juste "lancement". Ici OK, car le front est statique.
    depends_on: []

  front:
    build:
      context: ../frontend
      dockerfile: Dockerfile.v1
    image: synthese-front:compose
    container_name: front_web
    ports:
      - "${FRONT_HTTP_PORT}:80"
    restart: unless-stopped
    networks:
      - ${APP_NETWORK}
    depends_on:
      - backend

networks:
  ${APP_NETWORK}:
    driver: bridge
```

> Remarques importantes :
> 
> - `extra_hosts: "host.docker.internal:host-gateway"` permet au **backend conteneuris√©** d‚Äôacc√©der √† **MySQL sur l‚Äôh√¥te** via `DB_HOST=host.docker.internal` (dans `backend.env`).
> 
> - CORS est d√©j√† g√©r√© dans `app.py` (autorise `http://localhost:8080`). Si vous changez le port front, adaptez l‚Äôen-t√™te dans le backend.

---

## 4) Ex√©cution pas √† pas

### 4.1 ‚Äî Construire et d√©marrer

```bash
cd ~/projet-synthese/compose

# 1) Construire les images et d√©marrer en d√©tach√©
docker compose up -d --build

# 2) Visualiser l‚Äô√©tat des services
docker compose ps

# 3) Suivre les logs (backend d‚Äôabord, puis front)
docker compose logs -f backend
# (CTRL+C pour quitter)
docker compose logs -f front
```

### 4.2 ‚Äî V√©rifications (API + Front)

```bash
# Tester l'API expos√©e par Compose (via port BACK_HTTP_PORT depuis .env)
curl -s http://127.0.0.1:${BACK_HTTP_PORT}/health
curl -s http://127.0.0.1:${BACK_HTTP_PORT}/api/products | python3 -m json.tool | head -n 20
```

Ouvrez ensuite votre navigateur :

- Front : **[http://127.0.0.1:8080](http://127.0.0.1:8080)** (ou le port d√©fini par `FRONT_HTTP_PORT` dans `.env`)

- Attendu : statut *API: OK* et tableau des produits.

---

## 5) R√©sultats attendus

- `docker compose ps` ‚Üí 2 services **Up**, `backend` passera **healthy** apr√®s quelques secondes (healthcheck image).

- `GET /health` depuis l‚Äôh√¥te (port `BACK_HTTP_PORT`) ‚Üí `{"status":"ok","db":true}`.

- Front (port `FRONT_HTTP_PORT`) ‚Üí liste des 3 produits stock√©s dans MySQL h√¥te.

---

## 6) Nettoyage / rollback

```bash
cd ~/projet-synthese/compose

# Arr√™ter et supprimer les ressources (conteneurs, r√©seau, mais conserve les images)
docker compose down

# (Optionnel) Tout supprimer, y compris les images du projet
# docker compose down --rmi all
```

---

## 7) Astuces & pi√®ges

- **Acc√®s MySQL h√¥te** : l‚Äôentr√©e
  
  ```
  extra_hosts:
    - "host.docker.internal:host-gateway"
  ```
  
  - `DB_HOST=host.docker.internal` est la m√©thode moderne la plus fiable pour Linux.  
    (√âvite `--network=host` qui complique le front.)

- **CORS** : si vous changez `FRONT_HTTP_PORT`, modifiez l‚Äôorigine autoris√©e dans `app.py` (en-t√™te `Access-Control-Allow-Origin`).

- **Restart policy** : `unless-stopped` est confortable en dev. En prod, combinez avec des probes de plateforme (K8s, Swarm) ou un orchestrateur externe.

- **Logs & debug** : `docker compose logs -f backend` aide √† confirmer la connexion DB et la disponibilit√© de l‚ÄôAPI.

- **Variables** : gardez les secrets hors Git (ex : `backend.env` ignor√© par d√©faut). Pour la prod, pr√©f√©rez un secret store (Vault, Swarm secrets, K8s Secrets).

---

### ‚úÖ √âtape 4 termin√©e

Si c‚Äôest valid√©, on encha√Æne **√âtape 5** : une **s√©rie d‚Äôexercices progressifs et incr√©mentiels** exploitant les notions phares du document d‚Äôorigine (Compose) :

- `environment` vs `env_file` (priorit√©s),

- `depends_on` + `condition: service_healthy` (avec un service DB en conteneur pour la d√©mo),

- `healthcheck` (front ou backend),

- `restart` (cas par cas),

- r√©seaux (`internal`, `aliases`, IPAM),

- volumes (bind vs named, droits, read-only),

- `build` + `image` combin√©s, cache et `.dockerignore`,

- renforcement s√©curit√© (`read_only`, `cap_drop`, `no-new-privileges`).
