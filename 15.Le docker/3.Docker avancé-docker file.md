# 🧱 Docker avancé

## Partie I : Exploration complète des mots-clés Dockerfile

---

## 🎯 Objectif

Comprendre et expérimenter **chaque instruction Dockerfile fondamentale**, à travers de petits exemples immédiatement testables.  
À la fin de cette section, tu sauras :

- construire une image à partir d’une base (`FROM`) ;

- ajouter des métadonnées (`LABEL`) et des variables (`ARG`, `ENV`) ;

- manipuler des fichiers avec `COPY` et `ADD` ;

- exécuter des commandes avec `RUN`, `CMD`, `ENTRYPOINT` ;

- définir le contexte d’exécution (`WORKDIR`, `USER`, `EXPOSE`, `VOLUME`).

---

## 🪜 Étape 1 : `FROM` et `LABEL`

Créer le fichier **`Dockerfile`** :

```dockerfile
# Base minimale : Ubuntu
FROM ubuntu:latest

# Métadonnées pour identifier l’image
LABEL maintainer="formateur@lab"
LABEL version="1.0"
LABEL description="Image Ubuntu de démonstration avec métadonnées"
```

> 🧠 `LABEL` n’affecte pas le comportement du conteneur ; il sert à documenter ou automatiser (CI/CD, audit).

Construire et vérifier :

```bash
docker build -t demo-label .
docker inspect demo-label | grep -A3 Labels
```

---

## 🪜 Étape 2 : `ARG` et `ENV`

Créer le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest

# Variable utilisée seulement pendant le build
ARG APP_VERSION=1.0

# Variable disponible à l’exécution
ENV APP_NAME="DemoApp" \
    APP_VERSION=${APP_VERSION}

RUN echo "Building ${APP_NAME} v${APP_VERSION}"

CMD ["bash", "-c", "echo 'Running $APP_NAME version $APP_VERSION'"]
```

Construire et exécuter :

```bash
docker build --build-arg APP_VERSION=2.5 -t demo-env .
docker run demo-env
```

> 🔹 `ARG` : uniquement durant le *build*.  
> 🔹 `ENV` : persiste dans le conteneur.

---

## 🪜 Étape 3 : `WORKDIR` et `RUN`

Créer le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
WORKDIR /app
RUN echo "Fichier créé depuis le Dockerfile" > fichier.txt
CMD ["ls", "-l"]
```

> `WORKDIR` crée le dossier s’il n’existe pas et y place le contexte de travail pour les instructions suivantes.

Tester :

```bash
docker build -t demo-workdir .
docker run demo-workdir
```

---

## 🪜 Étape 4 : `COPY` vs `ADD`

**But :** comprendre quand utiliser l’un ou l’autre.

### 4.1 Exemple : `COPY`

Créer le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
WORKDIR /data
COPY fichier_local.txt /data/
CMD ["cat", "/data/fichier_local.txt"]
```

Créer le fichier **`fichier_local.txt`** :

```bash
echo "Hello from COPY!" > fichier_local.txt
```

Build & run :

```bash
docker build -t demo-copy .
docker run demo-copy
```

### 4.2 Exemple : `ADD` avec archive compressée

Créer le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
WORKDIR /app
ADD archive.tar.gz /app/
CMD ["ls", "-l", "/app"]
```

Créer une petite archive pour test :

```bash
tar czf archive.tar.gz /etc/hostname
```

Build & run :

```bash
docker build -t demo-add .
docker run demo-add
```

> 💡 `ADD` sait **décompresser automatiquement** les fichiers `.tar.gz` et **télécharger des URL distantes** ;  
> `COPY` est **plus sûr** → utiliser `ADD` seulement si tu veux la décompression ou le fetch HTTP.

---

## 🪜 Étape 5 : `EXPOSE`, `VOLUME`, `USER`

Créer le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest

RUN useradd -m customuser
USER customuser

WORKDIR /data
VOLUME /data
EXPOSE 8080

CMD ["bash", "-c", "echo 'Utilisateur actuel : $(whoami)'; sleep 10"]
```

Build & run :

```bash
docker build -t demo-user .
docker run -it demo-user
```

> 🔹 `USER` définit l’utilisateur d’exécution.  
> 🔹 `VOLUME` déclare un point de persistance (montable).  
> 🔹 `EXPOSE` documente un port (n’ouvre rien, c’est informatif).

---

## 🪜 Étape 6 : `RUN` vs `ENTRYPOINT`

Créer le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
RUN echo "Exécution pendant le build (image créée)"
ENTRYPOINT ["echo", "Exécution au lancement du conteneur →"]
```

Build & run :

```bash
docker build -t demo-run-entrypoint .
docker run demo-run-entrypoint
```

> 🧩 **RUN** : pendant la construction → modifie l’image.  
> **ENTRYPOINT** : pendant l’exécution → commande principale du conteneur.

---

## 🪜 Étape 7 : `ENTRYPOINT` vs `CMD`

### 7.1 Cas : combinaison

Créer le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
ENTRYPOINT ["echo", "Hello"]
CMD ["World"]
```

Tester :

```bash
docker build -t demo-entry-cmd .
docker run demo-entry-cmd
docker run demo-entry-cmd Bechir
```

Résultats :

```
Hello World
Hello Bechir
```

### 7.2 Cas : CMD seul

Créer le fichier **`Dockerfile`** :

```dockerfile
FROM ubuntu:latest
CMD ["echo", "Hello", "World"]
```

Tester :

```bash
docker build -t demo-cmd .
docker run demo-cmd
docker run demo-cmd Bechir
```

> Le second échoue car `CMD` est **écrasé entièrement**.  
> Avec `ENTRYPOINT`, on peut **ajouter des arguments** au lieu d’écraser.

🧠 **Récapitulatif rapide :**

| Directive  | Exécutée quand ?  | Peut être écrasée ?        | Usage typique                       |
| ---------- | ----------------- | -------------------------- | ----------------------------------- |
| RUN        | À la construction | Non                        | Installer packages, copier fichiers |
| CMD        | Au lancement      | Oui (remplaçable)          | Commande par défaut                 |
| ENTRYPOINT | Au lancement      | Non (arguments ajoutables) | Comportement “fixe” du conteneur    |

---

## 🧹 Nettoyage

```bash
docker image prune -f
docker container prune -f
docker volume prune -f
```

# docker init

---

## 🎯 Objectif

Découvrir et utiliser la nouvelle commande **`docker init`** (introduite dans Docker 25.x),  
qui permet de **générer automatiquement un Dockerfile, un fichier `.dockerignore`, et un `compose.yaml`** à partir d’un projet existant.

L’atelier montre :

1. La préparation d’une petite application web locale (Python/Flask).

2. L’exécution interactive de `docker init`.

3. Le test et la vérification de l’image générée.

---

## 🧰 Pré-requis

- Docker ≥ 25.0

- Python 3 installé (pour l’application exemple)

- Accès sudo

---

## 🪜 Étape 1 — Préparation de l’application

Nous allons créer une petite application **Flask** minimaliste.

Créer le dossier :

```bash
mkdir ~/demo_docker_init && cd ~/demo_docker_init
```

Créer le fichier **`app.py`** :

```python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def index():
    return "✅ Hello from Docker Init!"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

Créer le fichier **`requirements.txt`** :

```
flask==3.0.2
```

Tester localement (optionnel) :

```bash
pip install -r requirements.txt
python app.py
# → accéder à http://127.0.0.1:5000
```

---

## 🪜 Étape 2 — Lancer l’assistant `docker init`

### 2.1 Exécution

Depuis le répertoire de ton application :

```bash
docker init
```

### 2.2 Dialogue interactif typique

L’assistant va poser plusieurs questions :

```
? What application platform does your project use? 
> Python

? What version of Python do you want to use?
> 3.11

? What port does your application listen on?
> 5000

? What is the command to run your app?
> python app.py

? What do you want to name your service?
> flask-demo
```

Docker va générer automatiquement :

```
Dockerfile
.dockerignore
compose.yaml
```

---

## 🪜 Étape 3 — Analyse du Dockerfile généré

Ouvre le fichier **`Dockerfile`** :

```bash
cat Dockerfile
```

Exemple généré :

```dockerfile
# syntax=docker/dockerfile:1

FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt

COPY . .
EXPOSE 5000

CMD ["python", "app.py"]
```

> 🧠 Remarques :
> 
> - `COPY` et `RUN` sont générés dans le bon ordre (optimisation du cache).
> 
> - `EXPOSE` documente le port d’écoute.
> 
> - `CMD` définit la commande par défaut.

---

## 🪜 Étape 4 — Construction et exécution du conteneur

Construire l’image :

```bash
docker build -t demo-init:latest .
```

Exécuter :

```bash
docker run -d -p 5000:5000 --name flask-demo demo-init
```

Tester :

```bash
curl http://localhost:5000
```

Résultat attendu :

```
✅ Hello from Docker Init!
```

---

## 🪜 Étape 5 — Utiliser le fichier `compose.yaml` généré

Inspecte le fichier **`compose.yaml`** :

```bash
cat compose.yaml
```

Exemple typique :

```yaml
services:
  flask-demo:
    build: .
    ports:
      - 5000:5000
```

Exécution via Compose :

```bash
docker compose up -d
```

Vérifie :

```bash
docker ps
curl http://localhost:5000
```

> 🧩 Avantage : `docker init` fournit directement une structure **multi-service prête pour Compose**.

---

## 🪜 Étape 6 — Vérification et exploration

Inspecter le conteneur :

```bash
docker inspect flask-demo
```

Voir les logs :

```bash
docker logs -f flask-demo
```

Ouvrir un shell à l’intérieur :

```bash
docker exec -it flask-demo bash
```

---

## 🧹 Étape 7 — Nettoyage du lab

```bash
docker compose down
docker rm -f flask-demo
docker rmi demo-init
docker system prune -f
```

---

## ✅ Résumé pédagogique

| Élément               | Fonction                                                       |
| --------------------- | -------------------------------------------------------------- |
| `docker init`         | Génère automatiquement la configuration Docker pour ton projet |
| `Dockerfile`          | Définit le build de ton application                            |
| `.dockerignore`       | Exclut les fichiers inutiles du contexte                       |
| `compose.yaml`        | Décrit le déploiement multi-service                            |
| `docker compose up`   | Lance le stack complet                                         |
| `docker system prune` | Nettoie ton environnement                                      |
