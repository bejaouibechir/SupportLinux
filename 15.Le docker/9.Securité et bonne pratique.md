

# Cas 1 — Éviter l’exécution en root dans le conteneur

**1) Problématique**  
Un process root dans le conteneur élève l’impact d’un escape ou d’une mauvaise configuration (montages, volumes, capabilities).

**2) Cas pratique (anomalie)**  
Créer une image qui tourne en root par défaut.

Créer le fichier **Dockerfile.bad** :

```Dockerfile
# Image basique volontairement non durcie
FROM alpine:3.20
RUN adduser -D appuser
# ⚠ On n'utilise PAS USER => root par défaut
CMD ["sh", "-c", "id && sleep 600"]
```

Construire et lancer :

```bash
# Construire l'image non durcie
docker build -t demo/root-bad -f Dockerfile.bad .

# Lancer et vérifier l'UID effectif (root = uid 0)
docker run --rm -it --name rootbad demo/root-bad
# Attendu (extrait): uid=0(root) gid=0(root) ...
```

**3) Cas pratique (correction)**  
Créer le fichier **Dockerfile.good** :

```Dockerfile
# Image durcie : exécution en utilisateur non-privilégié
FROM alpine:3.20

# 1) Créer un user dédié
RUN adduser -D -h /home/appuser -s /bin/sh appuser

# 2) Définir des répertoires de travail appartenant à appuser
RUN mkdir -p /app && chown -R appuser:appuser /app

# 3) Basculer en utilisateur non-root
USER appuser

WORKDIR /app
CMD ["sh", "-c", "id && sleep 600"]
```

Construire et lancer :

```bash
docker build -t demo/root-good -f Dockerfile.good .
docker run --rm -it --name rootgood demo/root-good
# Attendu (extrait): uid=1000(appuser) gid=1000(appuser) ...
```

**4) Nettoyage**

```bash
docker rm -f rootbad rootgood 2>/dev/null || true
docker rmi demo/root-bad demo/root-good 2>/dev/null || true
rm -f Dockerfile.bad Dockerfile.good
```

---

# Cas 2 — Supprimer les capacités Linux non nécessaires

**1) Problématique**  
Les conteneurs héritent d’un ensemble de **capabilities**. Trop de capacités = surface d’attaque plus large (ex: `NET_RAW`).

**2) Cas pratique (anomalie)**  
Exécuter un conteneur avec toutes les capacités (mauvaise pratique) :

```bash
# ⚠ --cap-add=ALL (anti-pattern)
docker run --rm -it --cap-add=ALL alpine:3.20 sh -c "capsh --print | sed -n '1,60p'; sleep 1"
```

**3) Cas pratique (correction)**  
Réduire drastiquement les capacités (drop all + add finement si besoin) :

```bash
# Supprimer toutes les capabilities, puis n'ajouter que ce qui est nécessaire (exemple sans ajout)
docker run --rm -it --cap-drop=ALL alpine:3.20 sh -c "capsh --print | sed -n '1,60p'; sleep 1"
```

> Si votre process a besoin d’une capability précise, ajoutez-la **explicitement** (`--cap-add=NET_BIND_SERVICE`, etc.).

**4) Nettoyage**

```bash
true   # Rien à nettoyer (conteneur --rm)
```

---

# Cas 3 — Interdire l’escalade de privilèges

**1) Problématique**  
Même un process non-root peut parfois élever ses privilèges via `setuid`/`setcap` si la chaîne le permet.

**2) Cas pratique (anomalie)**  
Lancer sans protection :

```bash
docker run --rm -it alpine:3.20 sh -c "echo test && sleep 1"
```

**3) Cas pratique (correction)**  
Forcer **no-new-privileges** :

```bash
docker run --rm -it --security-opt no-new-privileges:true alpine:3.20 sh -c "echo safe && sleep 1"
```

**4) Nettoyage**

```bash
true
```

---

# Cas 4 — Système de fichiers en lecture seule + répertoires volatils

**1) Problématique**  
Un FS en écriture facilite la persistance malveillante ou l’altération. Réduire l’écriture à l’essentiel.

**2) Cas pratique (anomalie)**  
FS mutable partout :

```bash
docker run --rm -it alpine:3.20 sh -c "touch /root/x && ls -l /root/x && sleep 1"
```

**3) Cas pratique (correction)**  
`--read-only` + `tmpfs` pour `/tmp` :

```bash
docker run --rm -it --read-only --tmpfs /tmp alpine:3.20 sh -c "touch /tmp/x && ls -l /tmp/x && sleep 1"
# Attendu: OK pour /tmp, KO pour /root
```

**4) Nettoyage**

```bash
true
```

---

# Cas 5 — Réseaux : isoler et contrôler la sortie

**1) Problématique**  
Le bridge par défaut autorise la sortie Internet. Pour des workloads sensibles, limiter/segmenter.

**2) Cas pratique (anomalie)**  
Conteneur sur le réseau par défaut avec sortie ouverte :

```bash
docker run --rm -it alpine:3.20 sh -c "wget -qO- https://example.com | head -n1 || true"
```

**3) Cas pratique (correction)**  
Créer un réseau **interne** (pas d’egress) + attacher le conteneur :

```bash
# Créer un réseau isolé "interne"
docker network create --driver bridge --internal secnet

# Lancer sur ce réseau interne (pas de sortie Internet)
docker run --rm -it --network secnet alpine:3.20 sh -c "wget -qO- https://example.com || echo 'Pas d\'egress: OK'"
```

**4) Nettoyage**

```bash
docker network rm secnet 2>/dev/null || true
```

---

# Cas 6 — Ne pas utiliser `--privileged` (et contrôler les devices)

**1) Problématique**  
`--privileged` donne presque tout… souvent inutile et dangereux.

**2) Cas pratique (anomalie)**

```bash
# ⚠ anti-pattern : --privileged
docker run --rm -it --privileged alpine:3.20 sh -c "echo 'Capacités étendues non nécessaires' && sleep 1"
```

**3) Cas pratique (correction)**  
N’autoriser **que** le device nécessaire (exemple: accès lecture seule à /dev/random) :

```bash
docker run --rm -it --device /dev/random:/dev/random:ro alpine:3.20 sh -c "dd if=/dev/random of=/dev/null bs=1 count=8 status=none && echo OK"
```

**4) Nettoyage**

```bash
true
```

---

# Cas 7 — Secrets : éviter les variables d’environnement

**1) Problématique**  
Les secrets en variables d’environnement fuient facilement (logs, `docker inspect`). Préférer fichiers montés en lecture seule.

**2) Cas pratique (anomalie)**  
Passage d’un secret en `-e DB_PASSWORD=...` :

```bash
# ⚠ Mauvaise pratique (le secret restera visible dans inspect / ps)
docker run --rm -e DB_PASSWORD='SuperSecret123!' alpine:3.20 sh -c 'echo "running"; sleep 1'
```

**3) Cas pratique (correction)**  
Monter un secret sous forme de fichier **en lecture seule** :

```bash
# Créer un dossier de secrets local avec permissions restrictives
mkdir -p ./secrets && chmod 700 ./secrets
echo 'SuperSecret123!' > ./secrets/db_password && chmod 600 ./secrets/db_password

# Monter le fichier secret en RO dans le conteneur
docker run --rm -it \
  -v "$(pwd)/secrets/db_password:/run/secret/db_password:ro" \
  alpine:3.20 sh -c 'PW=$(cat /run/secret/db_password); test -n "$PW" && echo "Secret lu en mémoire OK" && sleep 1'
```

**4) Nettoyage**

```bash
rm -rf ./secrets
```

---

# Cas 8 — Pinner les images (tags immuables / digests) et provenance

**1) Problématique**  
`latest` ou un tag mutable peut pointer demain vers autre chose. Risque d’empoisonnement supply-chain.

**2) Cas pratique (anomalie)**

```bash
# Tirer une image avec un tag mutable
docker pull nginx:latest
```

**3) Cas pratique (correction)**  
Utiliser un **digest** immuable :

```bash
# Exemple: récupérer le digest courant puis lancer avec @sha256:<digest>
# (ici démonstration générique: remplace <DIGEST> par une valeur réelle issue de `docker inspect`)
docker pull nginx:1.27-alpine
docker inspect --format='{{index .RepoDigests 0}}' nginx:1.27-alpine
# Exécution fixée sur le digest
# docker run --rm -p 8080:80 nginx@sha256:<DIGEST>
```

> Bonus (supply chain) : signature/attestation (ex: Cosign, Notation) côté CI (démonstration complète hors périmètre minimal de cet atelier).

**4) Nettoyage**

```bash
docker rmi nginx:latest nginx:1.27-alpine 2>/dev/null || true
```

---

# Cas 9 — Réduire la surface: images minimales + dépendances exactes

**1) Problématique**  
Images “lourdes” = plus d’outils inutiles exploitables.

**2) Cas pratique (anomalie)**  
Créer une image avec outils superflus.

Créer le fichier **Dockerfile.heavy** :

```Dockerfile
FROM alpine:3.20
RUN apk add --no-cache curl bash coreutils
CMD ["sh", "-c", "apk info -vv && sleep 600"]
```

```bash
docker build -t demo/heavy -f Dockerfile.heavy .
docker run --rm --name heavy demo/heavy sh -c "apk info | wc -l"
```

**3) Cas pratique (correction)**  
Créer le fichier **Dockerfile.slim** :

```Dockerfile
# Image allégée: dépendances minimales
FROM alpine:3.20
# Installer seulement ce qui est requis à l'exécution (ex: busybox est déjà présent)
CMD ["sh", "-c", "echo 'OK minimal' && sleep 600"]
```

```bash
docker build -t demo/slim -f Dockerfile.slim .
docker run --rm --name slim demo/slim
```

**4) Nettoyage**

```bash
docker rm -f heavy slim 2>/dev/null || true
docker rmi demo/heavy demo/slim 2>/dev/null || true
rm -f Dockerfile.heavy Dockerfile.slim
```

---

# Cas 10 — Limiter l’impact DoS: quotas & ulimits

**1) Problématique**  
Sans limites, un conteneur peut consommer CPU/RAM/FD et perturber l’hôte.

**2) Cas pratique (anomalie)**

```bash
# Lancer sans limites (mauvaise habitude)
docker run --rm -it alpine:3.20 sh -c "echo 'No limits'; sleep 1"
```

**3) Cas pratique (correction)**  
Définir limites mémoire/CPU + ulimits :

```bash
# Mémoire <= 256MiB, CPU ~ 0.5 core, limiter les descripteurs de fichiers
docker run --rm -it \
  --memory=256m --memory-swap=256m \
  --cpus="0.5" \
  --ulimit nofile=1024:1024 --ulimit nproc=256 \
  alpine:3.20 sh -c "echo 'Limites appliquées'; ulimit -n; ulimit -u; sleep 1"
```

**4) Nettoyage**

```bash
true
```

---

## (Bonus rapide) 3 réglages supplémentaires à combiner selon les cas

- **Seccomp personnalisé** : `--security-opt seccomp=/chemin/profil.json` pour interdire des syscalls inutiles.

- **Montages en lecture seule** : `-v /host/path:/container/path:ro` par défaut, et ne monter **que** ce qui est nécessaire.

- **Rootless Docker** : exécuter Docker rootless côté hôte pour réduire l’impact en cas de compromission (installation et contraintes à planifier).

---

# Résultats attendus & vérifications

- Les conteneurs **n’exécutent pas** de process root (voir `id`).

- Les **capabilities** sont **réduites** au strict nécessaire (`capsh --print`).

- **no-new-privileges** actif quand demandé.

- Le **FS** en lecture seule empêche l’écriture hors `tmpfs`.

- Les conteneurs sur réseau **interne** n’ont pas d’egress.

- Aucun usage de `--privileged`, devices ajoutés **au cas par cas**.

- Les **secrets** ne transitent plus par l’environnement, mais par fichiers montés en **RO**.

- Les images sont **pinnées** par digest, pas de `latest` implicite.

- Les images sont **minimales** (moins de paquets visibles).

- Des **limites** CPU/RAM/Fd sont en place (ulimits).

---

# Nettoyage global (optionnel)

```bash
# Supprimer réseaux, images de démo résiduelles
docker network rm secnet 2>/dev/null || true
docker image prune -f
docker container prune -f
```

---

## Conseils & pièges

- **Éviter `latest`** : versionnez et pinner par digest pour des déploiements reproductibles.

- **JAMAIS `--privileged`** sauf POC isolé et maîtrisé.

- **Éviter les secrets en env** : préférez fichiers montés RO; audit régulier de `docker inspect`.

- **Réduire la surface** : passez à des images minimales, supprimez les toolings debug en prod.

- **Cap-drop par défaut** : ajoutez finement si besoin.

- **Automatisez les contrôles** (CIS Docker Benchmark, `docker scout`, `trivy` en CI).

- **Documentez les profils seccomp/apparmor** et versionnez-les.

- **Testez vos limites** (stress test) pour vérifier qu’elles se déclenchent bien.

Si tu veux, je peux enchaîner avec un **atelier 100% pratique “audit & hardening automatisé”** (trivy + scout + profils seccomp/apparmor + policy autour des options `docker run`) dans le même format.
