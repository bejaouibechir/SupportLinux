\# Exercice APPROFONDI — \*\*“UserAudit+”\*\*



\## 🎯 Objectif



Écrire un script \*\*robuste\*\* `user\_audit.sh` qui :



1\. Parse des \*\*arguments\*\* avec `getopts` (fichier d’entrée CSV, dossier de sortie, mode verbose, dry-run).

2\. Valide les \*\*préconditions\*\* avec des \*\*tests de fichiers\*\* (`-f/-r`, `-d/-w`, `-x`).

3\. Lit des \*\*lignes CSV\*\* de façon sûre (IFS/`read -r`) et \*\*valide\*\* les champs par \*\*regex\*\* (email), \*\*entier\*\* (âge), et \*\*case\*\* (pays).

4\. Utilise des \*\*fonctions\*\* (paramètres, `return`/`$?`) et \*\*codes de sortie\*\*.

5\. Gère les \*\*signaux\*\* et le \*\*nettoyage\*\* via `trap` + répertoire \*\*temporaire\*\* `mktemp -d`.

6\. Produit un \*\*rapport\*\* (avec `tee`) et un \*\*résumé\*\* (tableau/compteurs), puis renvoie un \*\*code de retour\*\* cohérent.



\*\*Format CSV attendu\*\* (exemple) : `name;email;age;country`



\* `name` : chaîne non vide

\* `email` : doit matcher une regex d’email (simplifiée)

\* `age` : nombre entier ≥ 0

\* `country` : case-insensitive, on accepte {TN, FR, DE, ES, IT, US} (par exemple)



> ⚠️ Utiliser \*\*bash\*\* et un shebang portable : `#!/usr/bin/env bash`

> ⚠️ Sous Debian 12/13, `/bin/sh` → `dash`. Certaines features utilisées (ex. `\[\[ ]]`, `${var^^}`) exigent \*\*bash\*\*.



---



\## 🔧 Prérequis (à créer pour la démo)



Créez un dossier de travail et un fichier d’entrée de test :



```bash

mkdir -p ~/useraudit\_demo/in ~/useraudit\_demo/out

cat > ~/useraudit\_demo/in/users.csv <<'CSV'

Alice;a.l@example.com;28;TN

Bob;bob\[at]mail.com;34;FR

;no-name@example.org;22;US

Claire;claire@mail.net;xx;DE

Diego;diego@mail.es;41;ES

Ilaria;ilaria@mail.it;19;IT

Yuki;yuki@mail.jp;27;JP

CSV

```



---



\## ✅ Ce que votre script devra faire (check-list)



1\. \*\*Arguments (`getopts`)\*\*



&nbsp;  \* `-i <fichier>` : chemin du CSV \*\*d’entrée\*\* (obligatoire).

&nbsp;  \* `-o <dossier>` : dossier \*\*de sortie\*\* (obligatoire).

&nbsp;  \* `-n` : \*\*dry-run\*\* (ne pas écrire les fichiers finaux, mais afficher ce qui serait fait).

&nbsp;  \* `-v` : \*\*verbose\*\* (messages détaillés sur stderr).

&nbsp;  \* `-h` : aide/usage.



2\. \*\*Préconditions\*\*



&nbsp;  \* `-i` doit pointer vers un \*\*fichier lisible\*\* (`-f` et `-r`).

&nbsp;  \* `-o` doit être un \*\*dossier\*\* existant et \*\*inscriptible\*\* (`-d` et `-w`).

&nbsp;  \* Le script \*\*échoue\*\* (exit ≠ 0) si les préconditions ne sont pas remplies.



3\. \*\*Traitement\*\*



&nbsp;  \* Créer un \*\*répertoire temporaire\*\* `TMPDIR="$(mktemp -d)"` et le \*\*nettoyer\*\* avec `trap 'rm -rf "$TMPDIR"' EXIT INT TERM`.

&nbsp;  \* Lire le CSV \*\*ligne par ligne\*\* : `while IFS=';' read -r name email age country; do ... done`.

&nbsp;  \* \*\*Valider\*\* chaque champ :



&nbsp;    \* `name` non vide.

&nbsp;    \* `email` via `\[\[ "$email" =~ ^\[A-Za-z0-9.\_%+-]+@\[A-Za-z0-9.-]+\\.\[A-Za-z]{2,}$ ]]`.

&nbsp;    \* `age` : regex entier `^\[0-9]+$` puis cast en entier, refuser négatif.

&nbsp;    \* `country` : `case` insensible (normaliser `${country^^}`).

&nbsp;  \* \*\*Statistiques\*\* : compteurs `OK`, `KO`, par pays (array associative `declare -A`).

&nbsp;  \* \*\*Sorties\*\* :



&nbsp;    \* Générer un \*\*rapport détaillé\*\* `report.txt` (stdout \*\*et\*\* fichier via `tee`).

&nbsp;    \* Écrire un \*\*CSV nettoyé\*\* `clean.csv` (seulement les lignes valides, nom en MAJUSCULES).

&nbsp;    \* En \*\*dry-run\*\*, ne pas écrire `clean.csv` final (afficher uniquement les actions).



4\. \*\*Retour\*\*



&nbsp;  \* \*\*exit 0\*\* si au moins \*\*1 ligne valide\*\* traitée.

&nbsp;  \* \*\*exit 2\*\* si \*\*0 ligne valide\*\*.

&nbsp;  \* \*\*exit 1\*\* en cas d’erreur d’arguments ou de préconditions.



---



\## 🧪 Vérifications attendues



1\. \*\*Usage\*\* (manque d’arguments) :



```bash

./user\_audit.sh

\# --> affiche l’aide et exit 1

```



2\. \*\*Préconditions OK \& dry-run\*\* :



```bash

./user\_audit.sh -i ~/useraudit\_demo/in/users.csv -o ~/useraudit\_demo/out -n -v

\# --> log verbose sur stderr, rapport sur stdout, PAS de clean.csv final

\# --> code retour 0 si >=1 ligne valide (attendu ici : OK)

echo $?   # doit afficher 0

```



3\. \*\*Exécution réelle (écriture fichiers)\*\* :



```bash

./user\_audit.sh -i ~/useraudit\_demo/in/users.csv -o ~/useraudit\_demo/out -v

\# --> crée ~/useraudit\_demo/out/report.txt et ~/useraudit\_demo/out/clean.csv

\# --> report.txt contient le résumé, clean.csv les lignes valides

```



4\. \*\*Inspection rapide\*\* :



```bash

sed -n '1,50p' ~/useraudit\_demo/out/report.txt

sed -n '1,50p' ~/useraudit\_demo/out/clean.csv

```



---



\## 🧩 Corrigé proposé (référence)



> Copiez/collez dans `user\_audit.sh`, puis :

>

> ```bash

> chmod +x user\_audit.sh

> ./user\_audit.sh -i ~/useraudit\_demo/in/users.csv -o ~/useraudit\_demo/out -v

> ```



```bash

\#!/usr/bin/env bash

\# UserAudit+ — Exercice approfondi Shell Scripting (Debian 12/13)

\# Notions: getopts, tests fichiers, read/IFS, regex, case, fonctions, arrays, trap, tee, robustesse



set -euo pipefail



usage() {

&nbsp; cat <<'USAGE'

Usage: user\_audit.sh -i <input.csv> -o <outdir> \[-n] \[-v] \[-h]

&nbsp; -i  Chemin du fichier CSV d'entrée (name;email;age;country)

&nbsp; -o  Dossier de sortie (rapport et fichiers générés)

&nbsp; -n  Dry-run (n'écrit pas les fichiers finaux)

&nbsp; -v  Verbose (messages détaillés sur stderr)

&nbsp; -h  Aide

USAGE

}



INPUT=""

OUTDIR=""

DRYRUN=false

VERBOSE=false



\# ---- Parsing arguments (getopts) --------------------------------------------

while getopts ":i:o:nvh" opt; do

&nbsp; case "$opt" in

&nbsp;   i) INPUT="$OPTARG" ;;

&nbsp;   o) OUTDIR="$OPTARG" ;;

&nbsp;   n) DRYRUN=true ;;

&nbsp;   v) VERBOSE=true ;;

&nbsp;   h) usage; exit 0 ;;

&nbsp;   \\?) echo "Option invalide: -$OPTARG" >\&2; usage; exit 1 ;;

&nbsp;   :)  echo "Option requiert un argument: -$OPTARG" >\&2; usage; exit 1 ;;

&nbsp; esac

done



\# ---- Préconditions -----------------------------------------------------------

\[\[ -n "$INPUT" \&\& -f "$INPUT" \&\& -r "$INPUT" ]] || { echo "Erreur: -i doit cibler un fichier lisible." >\&2; usage; exit 1; }

\[\[ -n "$OUTDIR" \&\& -d "$OUTDIR" \&\& -w "$OUTDIR" ]] || { echo "Erreur: -o doit cibler un dossier inscriptible." >\&2; usage; exit 1; }



$VERBOSE \&\& echo "\[VERBOSE] INPUT=$INPUT OUTDIR=$OUTDIR DRYRUN=$DRYRUN" >\&2



TMPDIR="$(mktemp -d)"

cleanup() {

&nbsp; $VERBOSE \&\& echo "\[VERBOSE] Nettoyage $TMPDIR" >\&2

&nbsp; rm -rf -- "$TMPDIR"

}

trap cleanup EXIT INT TERM



REPORT="$TMPDIR/report.txt"

CLEAN="$TMPDIR/clean.csv"



\# ---- Outils de validation ----------------------------------------------------

is\_email() {

&nbsp; local s="$1"

&nbsp; \[\[ "$s" =~ ^\[A-Za-z0-9.\_%+-]+@\[A-Za-z0-9.-]+\\.\[A-Za-z]{2,}$ ]]

}



is\_uint() {

&nbsp; local s="$1"

&nbsp; \[\[ "$s" =~ ^\[0-9]+$ ]]

}



normalize\_country() {

&nbsp; local c="${1^^}"

&nbsp; case "$c" in

&nbsp;   TN|FR|DE|ES|IT|US) echo "$c"; return 0 ;;

&nbsp;   \*) echo "$c"; return 2 ;;  # 2 = inconnu/non supporté

&nbsp; esac

}



to\_upper() {

&nbsp; local s="$1"

&nbsp; echo "${s^^}"

}



\# ---- Stats -------------------------------------------------------------------

declare -i COUNT\_OK=0

declare -i COUNT\_KO=0

declare -A BY\_COUNTRY\_OK=()

declare -A BY\_COUNTRY\_KO=()



\# ---- Lecture et traitement ---------------------------------------------------

$VERBOSE \&\& echo "\[VERBOSE] Lecture CSV..." >\&2

{

&nbsp; echo "=== UserAudit+ Report ==="

&nbsp; echo "Input:  $INPUT"

&nbsp; echo "Outdir: $OUTDIR"

&nbsp; echo "Date:   $(date)"

&nbsp; echo

&nbsp; echo "Lignes invalides (raison):"

} > "$REPORT"



\# Lecture ligne par ligne, séparateur ; 

\# On tolère lignes vides/malfomées -> KO

while IFS=';' read -r name email age country; do

&nbsp; # ignorer lignes vides

&nbsp; if \[\[ -z "${name:-}" \&\& -z "${email:-}" \&\& -z "${age:-}" \&\& -z "${country:-}" ]]; then

&nbsp;   continue

&nbsp; fi



&nbsp; reason=""

&nbsp; # name non vide

&nbsp; \[\[ -n "${name:-}" ]] || reason+="name vide; "

&nbsp; # email

&nbsp; is\_email "${email:-}" || reason+="email invalide; "

&nbsp; # age

&nbsp; if is\_uint "${age:-}"; then

&nbsp;   if (( age < 0 )); then reason+="age negatif; "; fi

&nbsp; else

&nbsp;   reason+="age non entier; "

&nbsp; fi

&nbsp; # country normalisé

&nbsp; c\_norm="$(normalize\_country "${country:-}")"

&nbsp; rc=$?  # 0 = supporté ; 2 = inconnu

&nbsp; if (( rc != 0 )); then reason+="country non supporte (${country:-}); "; fi



&nbsp; if \[\[ -z "$reason" ]]; then

&nbsp;   # OK

&nbsp;   COUNT\_OK+=1

&nbsp;   BY\_COUNTRY\_OK\["$c\_norm"]=$(( ${BY\_COUNTRY\_OK\["$c\_norm"]:-0} + 1 ))

&nbsp;   name\_up="$(to\_upper "$name")"

&nbsp;   line="${name\_up};${email};${age};${c\_norm}"

&nbsp;   if $DRYRUN; then

&nbsp;     $VERBOSE \&\& echo "\[DRYRUN] + $line" >\&2

&nbsp;   else

&nbsp;     printf "%s\\n" "$line" >> "$CLEAN"

&nbsp;   fi

&nbsp; else

&nbsp;   # KO

&nbsp;   COUNT\_KO+=1

&nbsp;   BY\_COUNTRY\_KO\["$c\_norm"]=$(( ${BY\_COUNTRY\_KO\["$c\_norm"]:-0} + 1 ))

&nbsp;   printf "KO: name='%s' email='%s' age='%s' country='%s' -> %s\\n" \\

&nbsp;     "${name:-}" "${email:-}" "${age:-}" "${country:-}" "$reason" >> "$REPORT"

&nbsp; fi

done < "$INPUT"



{

&nbsp; echo

&nbsp; echo "=== Résumé ==="

&nbsp; echo "Valides : $COUNT\_OK"

&nbsp; echo "Invalides : $COUNT\_KO"

&nbsp; echo

&nbsp; echo "\[Par pays - OK]"

&nbsp; for k in "${!BY\_COUNTRY\_OK\[@]}"; do

&nbsp;   printf "%s: %d\\n" "$k" "${BY\_COUNTRY\_OK\[$k]}"

&nbsp; done | sort

&nbsp; echo

&nbsp; echo "\[Par pays - KO]"

&nbsp; for k in "${!BY\_COUNTRY\_KO\[@]}"; do

&nbsp;   printf "%s: %d\\n" "$k" "${BY\_COUNTRY\_KO\[$k]}"

&nbsp; done | sort

} >> "$REPORT"



\# ---- Sorties finales ---------------------------------------------------------

\# report.txt -> toujours écrit

if $DRYRUN; then

&nbsp; # Affiche sur stdout mais ne persiste pas CLEAN

&nbsp; cat "$REPORT" | tee "$OUTDIR/report.txt" >/dev/stdout

else

&nbsp; cat "$REPORT" | tee "$OUTDIR/report.txt" >/dev/stdout

&nbsp; mv -f -- "$CLEAN" "$OUTDIR/clean.csv"

fi



\# ---- Code de retour ----------------------------------------------------------

if (( COUNT\_OK > 0 )); then

&nbsp; exit 0

elif (( COUNT\_OK == 0 )); then

&nbsp; exit 2

else

&nbsp; exit 1

fi

```



---



\## 📝 Explications (très bref)



\* \*\*Robustesse\*\* : `set -euo pipefail` + quoting systématique.

\* \*\*Arg parsing\*\* : `getopts` avec gestion des erreurs `\\?` et `:`.

\* \*\*Fichiers\*\* : tests `-f/-r` (entrée), `-d/-w` (sortie).

\* \*\*Sécurité\*\* : `mktemp -d` + `trap` pour nettoyage, y compris si `Ctrl-C`.

\* \*\*Lecture CSV\*\* : `IFS=';' read -r` (préserve backslashes).

\* \*\*Regex\*\* : `\[\[ ... =~ ... ]]` pour l’email et l’entier.

\* \*\*Normalisation pays\*\* : `case` + `${var^^}` (uppercasing).

\* \*\*Statistiques\*\* : tableaux associatifs `declare -A`.

\* \*\*Sorties\*\* : `tee` pour voir le rapport à l’écran et générer `report.txt`.

\* \*\*Retour\*\* : 0 si ≥1 ligne valide, 2 si aucune, 1 pour erreurs d’arguments/prérequis.







