\# Exercice (BASIQUE) — “ContactCleaner”



\*\*Objectif.\*\* Écrire un script `contact\_cleaner.sh` qui :



1\. lit proprement des entrées utilisateur (`read`) ; 2) contrôle des nombres entiers (`declare -i`) ; 3) applique des conditions (`\[\[ … ]]`) ; 4) parcourt des fichiers (`for`) ; 5) utilise une fonction réutilisable (avec paramètres \& code retour) — en \*\*bash\*\* avec \*\*shebang portable\*\*.

&nbsp;  → Shebang recommandé : `#!/usr/bin/env bash`.\&#x20;

&nbsp;  → Démos `read` : invite, timeout, multi-variables.\&#x20;

&nbsp;  → Nombres entiers `declare -i`.\&#x20;

&nbsp;  → Structures conditionnelles.\&#x20;

&nbsp;  → Boucles `for/while/until`.\&#x20;

&nbsp;  → Fonctions \& passage d’arguments.\&#x20;



\## Consignes



1\. \*\*Création \& entête\*\*



&nbsp;  \* Créez `contact\_cleaner.sh` avec le shebang portable : `#!/usr/bin/env bash`.\&#x20;

2\. \*\*Lecture d’entrées\*\*



&nbsp;  \* Demandez un \*\*dossier de travail\*\* (où se trouvent des `.txt`) via `read -r -p`. Refusez si vide.\&#x20;

&nbsp;  \* Demandez un \*\*âge minimum\*\* pour filtrer des lignes (ex : `age>=N`) et stockez-le dans une \*\*variable entière\*\* (`declare -i`).\&#x20;

3\. \*\*Contrôles \& conditions\*\*



&nbsp;  \* Vérifiez que le \*\*dossier existe\*\* (`\[\[ -d … ]]`). Si non, `exit 1`.

&nbsp;  \* Vérifiez que l’\*\*âge\*\* est un entier numérique avant usage (condition + message d’erreur).\&#x20;

4\. \*\*Fonction utilitaire\*\*



&nbsp;  \* Implémentez une \*\*fonction\*\* `normalize\_name()` qui reçoit un \*\*nom\*\* et \*\*retourne\*\* (via `echo`) le nom en \*\*MAJUSCULES\*\*. Appelez-la depuis la boucle (passez-lui un argument).\&#x20;

5\. \*\*Boucle sur fichiers\*\*



&nbsp;  \* Pour chaque `\*.txt` du dossier, créez un fichier de sortie `.clean.txt`.

&nbsp;  \* Pour chaque ligne, si `age>=N`, écrivez `NOM\_NORMALISÉ;email;age` dans le fichier `.clean.txt`. (Utilisez une \*\*boucle\*\* `for file in \*.txt` + lecture ligne par ligne.)\&#x20;

6\. \*\*Sortie propre\*\*



&nbsp;  \* Affichez le \*\*nombre total\*\* de lignes retenues (variable entière cumulée).\&#x20;



\## Critères de réussite (checklist)



\* `bash -n contact\_cleaner.sh` ne signale \*\*aucune erreur de syntaxe\*\*.

\* Si le dossier n’existe pas → message clair + \*\*code retour ≠ 0\*\*.

\* Les fichiers `\*.clean.txt` sont générés ; chaque ligne est \*\*filtrée\*\* (âge) et \*\*normalisée\*\* (nom en MAJ).

\* Le cumul final (nombre de lignes retenues) est \*\*exact\*\*.



---



\## Corrigé proposé (référence)



```bash

\#!/usr/bin/env bash

\# ContactCleaner - Exercice basique LPIC/Debian

\# Requiert bash (shebang portable recommandé)  # :contentReference\[oaicite:13]{index=13}



set -euo pipefail



\# 1) Lecture du dossier et validation   # :contentReference\[oaicite:14]{index=14}

read -r -p "Dossier contenant des .txt : " WORKDIR

if \[\[ -z "${WORKDIR}" || ! -d "${WORKDIR}" ]]; then

&nbsp; echo "Erreur: dossier invalide."

&nbsp; exit 1

fi



\# 2) Lecture de l'âge minimal et typage entier  # :contentReference\[oaicite:15]{index=15}

read -r -p "Âge minimal (entier) : " AGE\_IN

\# validation numérique basique  # :contentReference\[oaicite:16]{index=16}

if \[\[ ! "${AGE\_IN}" =~ ^\[0-9]+$ ]]; then

&nbsp; echo "Erreur: veuillez saisir un entier."

&nbsp; exit 1

fi

declare -i AGE\_MIN="${AGE\_IN}"



\# 3) Fonction utilitaire - passage d'argument  # :contentReference\[oaicite:17]{index=17}

normalize\_name() {

&nbsp; # Retourner en MAJUSCULE via echo (utilisable dans une substitution de commande)

&nbsp; local in="$1"

&nbsp; echo "${in^^}"

}



\# 4) Traitement des fichiers  # :contentReference\[oaicite:18]{index=18}

declare -i TOTAL=0

shopt -s nullglob

cd -- "${WORKDIR}"



for file in \*.txt; do

&nbsp; out="${file%.txt}.clean.txt"

&nbsp; : > "${out}"   # tronque le fichier de sortie



&nbsp; # Lecture ligne par ligne: chaque ligne: "nom;email;age"

&nbsp; while IFS=';' read -r name email age; do

&nbsp;   # Skip lignes vides / mal formées

&nbsp;   \[\[ -z "${name:-}" || -z "${email:-}" || -z "${age:-}" ]] \&\& continue

&nbsp;   # Filtre âge (numérique)

&nbsp;   \[\[ ! "${age}" =~ ^\[0-9]+$ ]] \&\& continue

&nbsp;   if (( age >= AGE\_MIN )); then

&nbsp;     NAME\_UPPER="$(normalize\_name "${name}")"

&nbsp;     printf "%s;%s;%s\\n" "${NAME\_UPPER}" "${email}" "${age}" >> "${out}"

&nbsp;     TOTAL+=1

&nbsp;   fi

&nbsp; done < "${file}"



&nbsp; echo "=> ${out} généré."

done



echo "Lignes retenues (tous fichiers) : ${TOTAL}"





