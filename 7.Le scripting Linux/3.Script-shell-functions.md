En **Bash**, on peut écrire des fonctions de plusieurs styles, chacun avec sa syntaxe et ses particularités. Voici les principaux :

---

## 1. **Fonction avec le mot-clé `function`**

```bash
function ma_fonction {
  echo "Bonjour depuis une fonction avec 'function'"
}
```

* Style proche de certains langages comme JavaScript ou C.
* Les accolades `{ ... }` sont obligatoires.

---

## 2. **Fonction sans le mot-clé `function` (style POSIX)**

```bash
ma_fonction() {
  echo "Bonjour depuis une fonction POSIX"
}
```

* Syntaxe plus portable (compatible avec `sh`, `dash`, etc.).
* C’est la forme recommandée pour les scripts robustes et compatibles.

---

## 3. **Fonction en ligne (one-liner)**

```bash
salut() { echo "Ceci est une fonction en une ligne"; }
```

* Utile pour définir rapidement de petites fonctions utilitaires.
* Peut être mis dans `.bashrc` pour usage fréquent.

---

## 4. **Fonction avec retour de valeur (via `return`)**

```bash
carre() {
  local n=$1
  return $((n * n))
}
carre 6
echo "Résultat (code de retour) : $?"
```

* ⚠️ Limitation : `return` ne peut renvoyer qu’un entier compris entre 0 et 255 (code d’état).
* Utilisé surtout pour signaler succès/échec, pas pour transmettre des résultats complexes.

---

## 5. **Fonction avec sortie standard (style recommandé pour renvoyer des données)**

```bash
carre() {
  local n=$1
  echo $((n * n))
}
result=$(carre 6)
echo "Résultat : $result"
```

* Plus flexible : on peut récupérer la valeur dans une variable.
* C’est la manière la plus utilisée pour “retourner” des données.

---

## 6. **Fonction anonyme (via `eval` ou `alias`)** *(rare et non recommandé)*

On peut simuler une fonction “anonyme” en générant du code dynamique, mais c’est rarement utile :

```bash
eval '() { echo "Fonction dynamique"; }'
```

* Peu lisible et difficile à maintenir.
* Utilisé parfois dans des scripts avancés ou générateurs de code.

---

## 7. **Fonction avec paramètres implicites (`$1`, `$2`, …, `$@`)**

```bash
addition() {
  echo "Somme = $(($1 + $2))"
}
addition 4 7
```

* Les arguments sont accessibles directement avec `$1`, `$2`, etc.
* `$@` représente la liste complète des arguments.



# Partie II Des cas concret

Tu as raison. Passons à des **cas 100% “terrain”** qu’on rencontre vraiment en entreprise : fichiers/dossiers, permissions, utilisateurs/groupes, processus, logs, sauvegardes, rotation, etc.  
Chaque cas = **objectif**, **préparation (si besoin)**, **script** (fonctions Bash réutilisables), **scénario de test**.  
Tout est exécutable tel quel avec `bash`.

---

# 15 cas concrets de fonctions Bash (complexité ascendante)

## 1) Vérifier l’existence, les droits et la taille d’un fichier

**Objectif** : avant un traitement, s’assurer qu’un fichier existe, est lisible, et non vide.  
**Script :**

```bash
#!/usr/bin/env bash
die(){ echo "[ERR] $*" >&2; exit 1; }

check_file(){
  local f=$1
  [[ -e $f ]] || { echo "NOK: absent"; return 2; }
  [[ -r $f ]] || { echo "NOK: non lisible"; return 3; }
  [[ -s $f ]] || { echo "NOK: vide"; return 4; }
  echo "OK: $f ($(stat -c%s "$f") bytes)"
}

# Test
echo "demo" > demo.txt
check_file demo.txt
check_file /not/here || true
```

---

## 2) Création de répertoires “sécurisée” (idempotente + droits)

**Objectif** : créer un dossier avec `umask` et droits attendus, relancer sans casser.  
**Script :**

```bash
#!/usr/bin/env bash
safe_mkdir(){
  local dir=$1 mode=${2:-750}
  umask 027
  mkdir -p "$dir" && chmod "$mode" "$dir"
}

# Test
safe_mkdir /tmp/acme/data 750
ls -ld /tmp/acme/data
```

---

## 3) Nettoyage de fichiers temporaires plus vieux que N jours (dry-run)

**Objectif** : routine de housekeeping.  
**Préparation** : `mkdir -p /tmp/old && touch -d "5 days ago" /tmp/old/a.log`  
**Script :**

```bash
#!/usr/bin/env bash
cleanup_old(){
  local path=$1 days=$2 dry=${3:-1}
  [[ -d $path ]] || { echo "dossier introuvable"; return 2; }
  local list; list=$(find "$path" -type f -mtime +"$days")
  [[ -z $list ]] && { echo "rien à nettoyer"; return 0; }
  if (( dry )); then echo "Dry-run:\n$list"; else echo "$list" | xargs -r rm -f; fi
}

# Test
cleanup_old /tmp/old 2 1
cleanup_old /tmp/old 2 0
```

---

## 4) Sauvegarde incrémentale locale avec `rsync` + vérification checksum

**Objectif** : sync d’un répertoire de travail vers un dépôt de sauvegarde.  
**Préparation** : `mkdir -p /tmp/src /tmp/backup; echo "v1" > /tmp/src/f1.txt`  
**Script :**

```bash
#!/usr/bin/env bash
backup_rsync(){
  local src=$1 dst=$2
  [[ -d $src && -d $dst ]] || { echo "src/dst invalides"; return 2; }
  rsync -a --delete "$src"/ "$dst"/
}

verify_checksums(){
  local dir=$1
  (cd "$dir" && find . -type f -print0 | xargs -0 sha256sum) | sha256sum >/dev/null
}

# Test
backup_rsync /tmp/src /tmp/backup && echo "synchro ok"
verify_checksums /tmp/backup && echo "checksums ok"
```

---

## 5) Rotation simple de logs (log → log.1 → log.2)

**Objectif** : garder N générations d’un log sans logrotate.  
**Préparation** : `echo "L1" >> /tmp/app.log`  
**Script :**

```bash
#!/usr/bin/env bash
rotate_log(){
  local file=$1 keep=${2:-3}
  [[ -f $file ]] || { echo "pas de log à faire tourner"; return 0; }
  for ((i=keep-1;i>=1;i--)); do
    [[ -f ${file}.${i} ]] && mv -f "${file}.${i}" "${file}.$((i+1))"
  done
  mv -f "$file" "${file}.1"
  : > "$file"
}

# Test
rotate_log /tmp/app.log 3
ls -l /tmp/app.log*
```

---

## 6) Archive quotidienne datée (tar.gz) + purge anciennes archives

**Objectif** : snapshot quotidien d’un dossier + rétention.  
**Préparation** : `mkdir -p /tmp/data && echo x>/tmp/data/a`  
**Script :**

```bash
#!/usr/bin/env bash
archive_daily(){
  local src=$1 outdir=$2 keep=${3:-7}
  mkdir -p "$outdir"
  local ts; ts=$(date +%F)
  tar -C "$src" -czf "$outdir/archive-$ts.tgz" .
  find "$outdir" -name 'archive-*.tgz' -mtime +$keep -delete
}

# Test
archive_daily /tmp/data /tmp/archives 3
ls -1 /tmp/archives
```

---

## 7) Bulk renaming sûr (prévisualisation + commit)

**Objectif** : renommer des fichiers selon un pattern (préfixe/suffixe).  
**Préparation** : `mkdir -p /tmp/rename && cd /tmp/rename && touch a.txt b.txt`  
**Script :**

```bash
#!/usr/bin/env bash
bulk_rename(){
  local dir=$1 prefix=${2:-} suffix=${3:-} commit=${4:-0}
  mapfile -t files < <(find "$dir" -maxdepth 1 -type f)
  ((${#files[@]})) || { echo "rien à renommer"; return 0; }
  for f in "${files[@]}"; do
    base=$(basename "$f"); new="${prefix}${base}${suffix}"
    echo "$base -> $new"
    ((commit)) && mv -f "$f" "$dir/$new"
  done
}

# Test
bulk_rename /tmp/rename "PROD_" "" 0   # preview
bulk_rename /tmp/rename "PROD_" "" 1   # commit
```

---

## 8) Permissions/ownership en masse + ACL facultatives

**Objectif** : appliquer des droits homogènes (ex. déploiement d’app).  
**Préparation** : `mkdir -p /tmp/app && touch /tmp/app/{a,b}.conf`  
**Script :**

```bash
#!/usr/bin/env bash
set_tree_perms(){
  local path=$1 user=$2 group=$3 fmode=${4:-640} dmode=${5:-750}
  chown -R "$user:$group" "$path"
  find "$path" -type d -exec chmod "$dmode" {} +
  find "$path" -type f -exec chmod "$fmode" {} +
}

set_acl_optional(){
  local path=$1 user=$2 perms=${3:-r-x}
  command -v setfacl >/dev/null || { echo "ACL non dispo"; return 0; }
  setfacl -Rm "u:${user}:${perms}" "$path"
}

# Test (utiliser votre user/groupe)
set_tree_perms /tmp/app "$USER" "$USER" 640 750
set_acl_optional /tmp/app "$USER" rx
```

---

## 9) Vérifier qu’un utilisateur/groupe existe, sinon créer

**Objectif** : prérequis d’installation.  
**Script :**

```bash
#!/usr/bin/env bash
ensure_group(){ getent group "$1" >/dev/null || sudo groupadd "$1"; }
ensure_user(){
  local u=$1 g=$2
  id "$u" &>/dev/null || sudo useradd -m -g "$g" "$u"
}

# Test (choisissez des noms de test)
# ensure_group devops
# ensure_user deployer devops
# getent passwd deployer; getent group devops
```

---

## 10) Vérifier qu’un process tourne (PID file / nom) + relance basique

**Objectif** : healthcheck applicatif.  
**Préparation** : `echo $$ > /tmp/demo.pid` (ou adapter)  
**Script :**

```bash
#!/usr/bin/env bash
is_running_pid(){
  local pidfile=$1
  [[ -f $pidfile ]] || return 2
  local pid; pid=$(<"$pidfile")
  kill -0 "$pid" 2>/dev/null
}

is_running_name(){ pgrep -f "$1" >/dev/null; }

restart_cmd(){
  local name=$1; shift
  if is_running_name "$name"; then
    echo "$name actif"; return 0
  fi
  echo "Relance: $name"
  "$@" &
}

# Test
is_running_pid /tmp/demo.pid && echo "OK via PID"
is_running_name bash && echo "OK via nom"
restart_cmd "python -m http.server" python -m http.server
```

---

## 11) Maîtriser la priorité CPU (nice/renice) et la mémoire (ulimit)

**Objectif** : lancer un job gourmand en réduisant son impact.  
**Script :**

```bash
#!/usr/bin/env bash
run_low_priority(){
  local log=${1:-/tmp/lowprio.log}
  ulimit -v $((256*1024))  # 256MB
  exec nice -n 10 bash -c 'echo "job low-priority"; sleep 2' >> "$log" 2>&1
}

# Test
run_low_priority
tail -n 2 /tmp/lowprio.log
```

---

## 12) Attente active intelligente sur un port ou un fichier (polling)

**Objectif** : attendre qu’un service écoute, ou qu’un fichier arrive.  
**Script :**

```bash
#!/usr/bin/env bash
wait_port(){
  local host=$1 port=$2 timeout=${3:-15}
  for ((i=0;i<timeout;i++)); do
    (echo >/dev/tcp/$host/$port) &>/dev/null && { echo "up"; return 0; }
    sleep 1
  done
  echo "timeout"; return 1
}

wait_file(){
  local f=$1 timeout=${2:-20}
  for ((i=0;i<timeout;i++)); do
    [[ -s $f ]] && { echo "ready"; return 0; }
    sleep 1
  done
  echo "timeout"; return 1
}

# Test
wait_file /etc/passwd 1
# wait_port 127.0.0.1 5432 3   # à tester si Postgres tourne
```

---

## 13) Déploiement atomique d’un fichier (temp → checksum → move)

**Objectif** : éviter les lectures partielles par une autre appli.  
**Préparation** : `mkdir -p /tmp/publish`  
**Script :**

```bash
#!/usr/bin/env bash
publish_atomic(){
  local src=$1 dest_dir=$2 base=$(basename "$src")
  local tmp="$dest_dir/.tmp.$base.$$"
  cp -f "$src" "$tmp" || return 2
  sha256sum "$tmp" >/dev/null || return 3
  mv -f "$tmp" "$dest_dir/$base"
  echo "publié: $dest_dir/$base"
}

# Test
echo "payload" > /tmp/payload.json
publish_atomic /tmp/payload.json /tmp/publish
ls -l /tmp/publish
```

---

## 14) Traitement batch robuste avec verrou (lockfile) pour cron

**Objectif** : empêcher les exécutions concurrentes.  
**Script :**

```bash
#!/usr/bin/env bash
with_lock(){
  local lock=$1; shift
  exec 9>"$lock" || exit 2
  if ! flock -n 9; then echo "déjà en cours"; return 1; fi
  "$@"
}

batch_task(){
  echo "batch start"; sleep 2; echo "batch done"
}

# Test (lancer 2x rapidement dans 2 shells pour voir le lock)
with_lock /tmp/batch.lock batch_task
```

---

## 15) Consolidation de logs journaux (journalctl) + filtre + export

**Objectif** : extraire les erreurs d’un service systemd et archiver.  
**Script :**

```bash
#!/usr/bin/env bash
export_errors(){
  local unit=$1 out=${2:-/tmp/errors-$(date +%F).log}
  command -v journalctl >/dev/null || { echo "journalctl indisponible"; return 2; }
  journalctl -u "$unit" --since "today" -p err > "$out"
  echo "export: $out"
}

# Test (adapter UNIT à un service actif, ex: ssh.service)
# export_errors ssh.service /tmp/ssh-errors.log
```

---

## Notes & bonnes pratiques

- Séparer **fonctions utilitaires** dans `lib.sh` (ex: `die`, `log_info`, `with_lock`, `check_file`), puis `source ./lib.sh` dans tes scripts.

- Tous ces cas sont **idempotents** ou vérifient les prérequis (existence/droits), ce qui permet de les exécuter en **CI/cron** sans surprises.

- Quand c’est “destructif” (suppression/rotation), commence en **dry-run** et ajoute un flag `--commit` avant d’agir.
