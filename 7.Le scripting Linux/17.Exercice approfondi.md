\# Exercice approfondi (court) — \*\*LogFilterPro\*\*



\## objectif



Écrire `logfilter.sh` qui lit un \*\*fichier de logs\*\* au format :



```

YYYY-MM-DD HH:MM:SS LEVEL message...

```



…et permet de \*\*garder seulement\*\* les lignes qui respectent :



\* une \*\*fenêtre temporelle\*\* : `-A "2025-09-10 00:00:00"` (after, inclus) et/ou `-B "2025-09-11 23:59:59"` (before, inclus)

\* des \*\*niveaux\*\* : `-L "ERROR,WARN"` (liste séparée par virgules)

\* un \*\*motif\*\* (regex) : `-P "database|timeout"`

\* options : sortie fichier `-o`, simulation `-n`, verbeux `-v`



codes retour : `0` ok / `1` erreur arguments / `2` aucun résultat.



---



\## script (copier-coller tel quel)



```bash

\#!/usr/bin/env bash

\# LogFilterPro - Filtre des logs (fenêtre temporelle, niveaux, motif)

\# Format de ligne attendu: "YYYY-MM-DD HH:MM:SS LEVEL message..."

\# Exemples:

\#   2025-09-11 10:15:00 INFO  Server started

\#   2025-09-11 10:16:02 WARN  Slow query

\#   2025-09-11 10:16:45 ERROR DB timeout



set -euo pipefail



usage() {

&nbsp; cat <<'USAGE'

Usage: logfilter.sh -i <input.log> \[-o <output.log>] \[-A "YYYY-MM-DD HH:MM:SS"] \[-B "YYYY-MM-DD HH:MM:SS"] \[-L "ERROR,WARN"] \[-P "regex"] \[-n] \[-v]

&nbsp; -i  Fichier log d'entrée (obligatoire)

&nbsp; -o  Fichier de sortie (sinon stdout)

&nbsp; -A  Filtre: après (inclus)  cette date/heure

&nbsp; -B  Filtre: avant  (inclus) cette date/heure

&nbsp; -L  Niveaux à garder (liste séparée par virgules), ex: "ERROR,WARN,INFO"

&nbsp; -P  Motif (regex) à garder dans le message complet

&nbsp; -n  Dry-run (n'écrit rien, affiche seulement)

&nbsp; -v  Verbose

&nbsp; -h  Aide

Codes retour: 0=OK, 1=erreur args, 2=aucun résultat

USAGE

}



IN="" OUT="" AFTER="" BEFORE="" LEVELS="" PATTERN=""

DRY=false VERB=false



\# -------- Parsing arguments

while getopts ":i:o:A:B:L:P:nvh" opt; do

&nbsp; case "$opt" in

&nbsp;   i) IN="$OPTARG" ;;

&nbsp;   o) OUT="$OPTARG" ;;

&nbsp;   A) AFTER="$OPTARG" ;;

&nbsp;   B) BEFORE="$OPTARG" ;;

&nbsp;   L) LEVELS="$OPTARG" ;;

&nbsp;   P) PATTERN="$OPTARG" ;;

&nbsp;   n) DRY=true ;;

&nbsp;   v) VERB=true ;;

&nbsp;   h) usage; exit 0 ;;

&nbsp;   \\?) echo "Option invalide: -$OPTARG" >\&2; usage; exit 1 ;;

&nbsp;   :)  echo "Option requiert un argument: -$OPTARG" >\&2; usage; exit 1 ;;

&nbsp; esac

done



\# -------- Vérifs de base

\[\[ -n "$IN" \&\& -f "$IN" \&\& -r "$IN" ]] || { echo "Erreur: -i fichier lisible requis." >\&2; usage; exit 1; }

if \[\[ -n "${OUT:-}" ]]; then

&nbsp; # Crée le dossier si nécessaire

&nbsp; mkdir -p -- "$(dirname -- "$OUT")"

fi



\# Pré-calcul des bornes temporelles en epoch (si fournies)

to\_epoch() { date -d "$1" +%s 2>/dev/null || return 1; }

AFTER\_E=0

BEFORE\_E=0

if \[\[ -n "$AFTER" ]]; then

&nbsp; AFTER\_E="$(to\_epoch "$AFTER")" || { echo "Erreur: date -A invalide." >\&2; exit 1; }

fi

if \[\[ -n "$BEFORE" ]]; then

&nbsp; BEFORE\_E="$(to\_epoch "$BEFORE")" || { echo "Erreur: date -B invalide." >\&2; exit 1; }

fi



\# Convertit "ERROR,WARN,INFO" -> regex "^(ERROR|WARN|INFO)$"

LEVELS\_RX=""

if \[\[ -n "$LEVELS" ]]; then

&nbsp; LEVELS\_RX="^($(echo "$LEVELS" | tr ',' '|' | sed 's/\[\[:space:]]//g'))$"

fi



$VERB \&\& {

&nbsp; echo "\[VERBOSE] IN=$IN OUT=${OUT:-<stdout>} AFTER='${AFTER:-}' BEFORE='${BEFORE:-}'" >\&2

&nbsp; echo "\[VERBOSE] LEVELS='${LEVELS:-<all>}' PATTERN='${PATTERN:-<none>}' DRY=$DRY" >\&2

}



\# -------- Filtrage avec awk

\# NB: pour chaque ligne on extrait:

\#  - ts (horodatage)   : colonnes 1 et 2

\#  - level             : colonne 3

\#  - message complet   : $0

\# On valide le format "YYYY-MM-DD HH:MM:SS" par regex, puis on compare en epoch.

run\_filter() {

&nbsp; local target="$1"  # fichier sortie ou /dev/stdout

&nbsp; awk -v after\_e="$AFTER\_E" -v before\_e="$BEFORE\_E" \\

&nbsp;     -v has\_after="$(\[\[ -n "$AFTER" ]] \&\& echo 1 || echo 0)" \\

&nbsp;     -v has\_before="$(\[\[ -n "$BEFORE" ]] \&\& echo 1 || echo 0)" \\

&nbsp;     -v levels\_rx="$LEVELS\_RX" -v has\_levels="$(\[\[ -n "$LEVELS\_RX" ]] \&\& echo 1 || echo 0)" \\

&nbsp;     -v pattern="$PATTERN" -v has\_pattern="$(\[\[ -n "$PATTERN" ]] \&\& echo 1 || echo 0)" '

&nbsp; BEGIN{

&nbsp;   count=0

&nbsp; }

&nbsp; # Format attendu:

&nbsp; # $1 = YYYY-MM-DD, $2 = HH:MM:SS, $3 = LEVEL, reste = message

&nbsp; # On vérifie rapidement la forme (sans valider calendrier)

&nbsp; /^\[0-9]{4}-\[0-9]{2}-\[0-9]{2}\[ \\t]\[0-9]{2}:\[0-9]{2}:\[0-9]{2}\[ \\t]/ {

&nbsp;   ts\_date=$1; ts\_time=$2; level=$3

&nbsp;   # Contrôle niveaux

&nbsp;   if (has\_levels==1 \&\& level !~ levels\_rx) next



&nbsp;   # Contrôle pattern global

&nbsp;   if (has\_pattern==1 \&\& $0 !~ pattern) next



&nbsp;   # Fenêtre temporelle (via `date -d` externe pour convertir la ligne en epoch)

&nbsp;   ts=ts\_date " " ts\_time

&nbsp;   cmd="date -d \\"" ts "\\" +%s"

&nbsp;   cmd | getline ep

&nbsp;   close(cmd)

&nbsp;   if (ep=="") next



&nbsp;   if (has\_after==1  \&\& ep <  after\_e)  next

&nbsp;   if (has\_before==1 \&\& ep >  before\_e) next



&nbsp;   print $0

&nbsp;   count++

&nbsp;   next

&nbsp; }

&nbsp; # Lignes hors format minimal -> on ignore silencieusement

&nbsp; END{

&nbsp;   # compteur écrit sur stderr (pas dans le flux filtré)

&nbsp;   printf("\[VERBOSE] lignes retenues: %d\\n", count) > "/dev/stderr"

&nbsp;   if (count==0) { exit 2 } else { exit 0 }

&nbsp; }' "$IN" > "$target"

}



\# Cible: stdout ou fichier (sauf dry-run)

TARGET="/dev/stdout"

if ! $DRY \&\& \[\[ -n "${OUT:-}" ]]; then

&nbsp; TARGET="$OUT"

fi



\# Exécution

if $DRY; then

&nbsp; $VERB \&\& echo "\[VERBOSE] DRY-RUN: affichage en stdout, aucun fichier écrit." >\&2

&nbsp; if run\_filter "/dev/stdout"; then exit 0; else rc=$?; \[\[ $rc -eq 2 ]] \&\& exit 2 || exit 1; fi

else

&nbsp; if run\_filter "$TARGET";  then

&nbsp;   $VERB \&\& echo "\[VERBOSE] Sortie -> $TARGET" >\&2

&nbsp;   exit 0

&nbsp; else

&nbsp;   rc=$?

&nbsp;   $VERB \&\& echo "\[VERBOSE] run\_filter exit=$rc" >\&2

&nbsp;   \[\[ $rc -eq 2 ]] \&\& exit 2 || exit 1

&nbsp; fi

fi

```



---



\## mode d’emploi (pas-à-pas)



1\. \*\*bac à sable\*\*



```bash

mkdir -p ~/logfilter\_demo

cat > ~/logfilter\_demo/app.log <<'LOG'

2025-09-11 10:15:00 INFO  Server started

2025-09-11 10:16:02 WARN  Slow query on /api/v1/items

2025-09-11 10:16:45 ERROR DB timeout while connecting to database

2025-09-10 22:59:59 INFO  Nightly job done

2025-09-12 00:00:01 ERROR Unhandled exception

LOG

```



2\. \*\*sauvegarder le script\*\* puis le rendre exécutable



```bash

chmod +x logfilter.sh

```



3\. \*\*voir l’aide\*\*



```bash

./logfilter.sh -h

```



4\. \*\*exemple 1 — filtrer par niveaux (ERROR,WARN)\*\*

&nbsp;  afficher seulement les erreurs/avertissements :



```bash

./logfilter.sh -i ~/logfilter\_demo/app.log -L "ERROR,WARN"

```



5\. \*\*exemple 2 — fenêtre temporelle\*\*

&nbsp;  garder ce qui est \*\*après\*\* 2025-09-11 00:00:00 et \*\*avant\*\* 2025-09-11 23:59:59 :



```bash

./logfilter.sh \\

&nbsp; -i ~/logfilter\_demo/app.log \\

&nbsp; -A "2025-09-11 00:00:00" \\

&nbsp; -B "2025-09-11 23:59:59"

```



6\. \*\*exemple 3 — motif “database” + niveaux\*\*

&nbsp;  simuler (dry-run) ce qui matche `database` et niveaux `ERROR,WARN`, et écrire dans un fichier :



```bash

./logfilter.sh \\

&nbsp; -i ~/logfilter\_demo/app.log \\

&nbsp; -L "ERROR,WARN" \\

&nbsp; -P "database" \\

&nbsp; -o ~/logfilter\_demo/filtered.log \\

&nbsp; -n -v

\# DRY-RUN: affiche en stdout, ne crée pas filtered.log

```



puis exécuter vraiment :



```bash

./logfilter.sh \\

&nbsp; -i ~/logfilter\_demo/app.log \\

&nbsp; -L "ERROR,WARN" \\

&nbsp; -P "database" \\

&nbsp; -o ~/logfilter\_demo/filtered.log \\

&nbsp; -v

sed -n '1,50p' ~/logfilter\_demo/filtered.log

```



7\. \*\*codes retour\*\*



```bash

./logfilter.sh -i ~/logfilter\_demo/app.log -P "no-such-pattern" || echo "RC=$?"

\# RC=2 (aucun résultat)

```



---



\## points pédagogiques (très bref)



\* \*\*getopts\*\* propre + messages clairs.

\* \*\*pré-calcul\*\* des bornes temporelles en epoch (\*\*date -d\*\*).

\* \*\*awk\*\* : extraction \*\*ts/level\*\* et tests successifs (niveaux, regex, temps).

\* \*\*dry-run / verbose\*\* : comprendre avant d’écrire.

\* \*\*retours\*\* : 0/1/2 pour scripting de CI ou automatisations futures.



si tu veux, je peux proposer une \*\*variante syslog\*\* (timestamps `MMM dd HH:MM:SS`) ou ajouter une \*\*option `--format`\*\* pour sélectionner le parseur (iso vs syslog).

f\*\* (regex).



> compatible Debian 12/13. pas de dépendances exotiques (bash, gawk/awk, coreutils).



\# Exercice approfondi (court) — \*\*LogFilterPro\*\*



\## objectif



Écrire `logfilter.sh` qui lit un \*\*fichier de logs\*\* au format :



```

YYYY-MM-DD HH:MM:SS LEVEL message...

```



…et permet de \*\*garder seulement\*\* les lignes qui respectent :



\* une \*\*fenêtre temporelle\*\* : `-A "2025-09-10 00:00:00"` (after, inclus) et/ou `-B "2025-09-11 23:59:59"` (before, inclus)

\* des \*\*niveaux\*\* : `-L "ERROR,WARN"` (liste séparée par virgules)

\* un \*\*motif\*\* (regex) : `-P "database|timeout"`

\* options : sortie fichier `-o`, simulation `-n`, verbeux `-v`



codes retour : `0` ok / `1` erreur arguments / `2` aucun résultat.



---



\## script (copier-coller tel quel)



```bash

\#!/usr/bin/env bash

\# LogFilterPro - Filtre des logs (fenêtre temporelle, niveaux, motif)

\# Format de ligne attendu: "YYYY-MM-DD HH:MM:SS LEVEL message..."

\# Exemples:

\#   2025-09-11 10:15:00 INFO  Server started

\#   2025-09-11 10:16:02 WARN  Slow query

\#   2025-09-11 10:16:45 ERROR DB timeout



set -euo pipefail



usage() {

&nbsp; cat <<'USAGE'

Usage: logfilter.sh -i <input.log> \[-o <output.log>] \[-A "YYYY-MM-DD HH:MM:SS"] \[-B "YYYY-MM-DD HH:MM:SS"] \[-L "ERROR,WARN"] \[-P "regex"] \[-n] \[-v]

&nbsp; -i  Fichier log d'entrée (obligatoire)

&nbsp; -o  Fichier de sortie (sinon stdout)

&nbsp; -A  Filtre: après (inclus)  cette date/heure

&nbsp; -B  Filtre: avant  (inclus) cette date/heure

&nbsp; -L  Niveaux à garder (liste séparée par virgules), ex: "ERROR,WARN,INFO"

&nbsp; -P  Motif (regex) à garder dans le message complet

&nbsp; -n  Dry-run (n'écrit rien, affiche seulement)

&nbsp; -v  Verbose

&nbsp; -h  Aide

Codes retour: 0=OK, 1=erreur args, 2=aucun résultat

USAGE

}



IN="" OUT="" AFTER="" BEFORE="" LEVELS="" PATTERN=""

DRY=false VERB=false



\# -------- Parsing arguments

while getopts ":i:o:A:B:L:P:nvh" opt; do

&nbsp; case "$opt" in

&nbsp;   i) IN="$OPTARG" ;;

&nbsp;   o) OUT="$OPTARG" ;;

&nbsp;   A) AFTER="$OPTARG" ;;

&nbsp;   B) BEFORE="$OPTARG" ;;

&nbsp;   L) LEVELS="$OPTARG" ;;

&nbsp;   P) PATTERN="$OPTARG" ;;

&nbsp;   n) DRY=true ;;

&nbsp;   v) VERB=true ;;

&nbsp;   h) usage; exit 0 ;;

&nbsp;   \\?) echo "Option invalide: -$OPTARG" >\&2; usage; exit 1 ;;

&nbsp;   :)  echo "Option requiert un argument: -$OPTARG" >\&2; usage; exit 1 ;;

&nbsp; esac

done



\# -------- Vérifs de base

\[\[ -n "$IN" \&\& -f "$IN" \&\& -r "$IN" ]] || { echo "Erreur: -i fichier lisible requis." >\&2; usage; exit 1; }

if \[\[ -n "${OUT:-}" ]]; then

&nbsp; # Crée le dossier si nécessaire

&nbsp; mkdir -p -- "$(dirname -- "$OUT")"

fi



\# Pré-calcul des bornes temporelles en epoch (si fournies)

to\_epoch() { date -d "$1" +%s 2>/dev/null || return 1; }

AFTER\_E=0

BEFORE\_E=0

if \[\[ -n "$AFTER" ]]; then

&nbsp; AFTER\_E="$(to\_epoch "$AFTER")" || { echo "Erreur: date -A invalide." >\&2; exit 1; }

fi

if \[\[ -n "$BEFORE" ]]; then

&nbsp; BEFORE\_E="$(to\_epoch "$BEFORE")" || { echo "Erreur: date -B invalide." >\&2; exit 1; }

fi



\# Convertit "ERROR,WARN,INFO" -> regex "^(ERROR|WARN|INFO)$"

LEVELS\_RX=""

if \[\[ -n "$LEVELS" ]]; then

&nbsp; LEVELS\_RX="^($(echo "$LEVELS" | tr ',' '|' | sed 's/\[\[:space:]]//g'))$"

fi



$VERB \&\& {

&nbsp; echo "\[VERBOSE] IN=$IN OUT=${OUT:-<stdout>} AFTER='${AFTER:-}' BEFORE='${BEFORE:-}'" >\&2

&nbsp; echo "\[VERBOSE] LEVELS='${LEVELS:-<all>}' PATTERN='${PATTERN:-<none>}' DRY=$DRY" >\&2

}



\# -------- Filtrage avec awk

\# NB: pour chaque ligne on extrait:

\#  - ts (horodatage)   : colonnes 1 et 2

\#  - level             : colonne 3

\#  - message complet   : $0

\# On valide le format "YYYY-MM-DD HH:MM:SS" par regex, puis on compare en epoch.

run\_filter() {

&nbsp; local target="$1"  # fichier sortie ou /dev/stdout

&nbsp; awk -v after\_e="$AFTER\_E" -v before\_e="$BEFORE\_E" \\

&nbsp;     -v has\_after="$(\[\[ -n "$AFTER" ]] \&\& echo 1 || echo 0)" \\

&nbsp;     -v has\_before="$(\[\[ -n "$BEFORE" ]] \&\& echo 1 || echo 0)" \\

&nbsp;     -v levels\_rx="$LEVELS\_RX" -v has\_levels="$(\[\[ -n "$LEVELS\_RX" ]] \&\& echo 1 || echo 0)" \\

&nbsp;     -v pattern="$PATTERN" -v has\_pattern="$(\[\[ -n "$PATTERN" ]] \&\& echo 1 || echo 0)" '

&nbsp; BEGIN{

&nbsp;   count=0

&nbsp; }

&nbsp; # Format attendu:

&nbsp; # $1 = YYYY-MM-DD, $2 = HH:MM:SS, $3 = LEVEL, reste = message

&nbsp; # On vérifie rapidement la forme (sans valider calendrier)

&nbsp; /^\[0-9]{4}-\[0-9]{2}-\[0-9]{2}\[ \\t]\[0-9]{2}:\[0-9]{2}:\[0-9]{2}\[ \\t]/ {

&nbsp;   ts\_date=$1; ts\_time=$2; level=$3

&nbsp;   # Contrôle niveaux

&nbsp;   if (has\_levels==1 \&\& level !~ levels\_rx) next



&nbsp;   # Contrôle pattern global

&nbsp;   if (has\_pattern==1 \&\& $0 !~ pattern) next



&nbsp;   # Fenêtre temporelle (via `date -d` externe pour convertir la ligne en epoch)

&nbsp;   ts=ts\_date " " ts\_time

&nbsp;   cmd="date -d \\"" ts "\\" +%s"

&nbsp;   cmd | getline ep

&nbsp;   close(cmd)

&nbsp;   if (ep=="") next



&nbsp;   if (has\_after==1  \&\& ep <  after\_e)  next

&nbsp;   if (has\_before==1 \&\& ep >  before\_e) next



&nbsp;   print $0

&nbsp;   count++

&nbsp;   next

&nbsp; }

&nbsp; # Lignes hors format minimal -> on ignore silencieusement

&nbsp; END{

&nbsp;   # compteur écrit sur stderr (pas dans le flux filtré)

&nbsp;   printf("\[VERBOSE] lignes retenues: %d\\n", count) > "/dev/stderr"

&nbsp;   if (count==0) { exit 2 } else { exit 0 }

&nbsp; }' "$IN" > "$target"

}



\# Cible: stdout ou fichier (sauf dry-run)

TARGET="/dev/stdout"

if ! $DRY \&\& \[\[ -n "${OUT:-}" ]]; then

&nbsp; TARGET="$OUT"

fi



\# Exécution

if $DRY; then

&nbsp; $VERB \&\& echo "\[VERBOSE] DRY-RUN: affichage en stdout, aucun fichier écrit." >\&2

&nbsp; if run\_filter "/dev/stdout"; then exit 0; else rc=$?; \[\[ $rc -eq 2 ]] \&\& exit 2 || exit 1; fi

else

&nbsp; if run\_filter "$TARGET";  then

&nbsp;   $VERB \&\& echo "\[VERBOSE] Sortie -> $TARGET" >\&2

&nbsp;   exit 0

&nbsp; else

&nbsp;   rc=$?

&nbsp;   $VERB \&\& echo "\[VERBOSE] run\_filter exit=$rc" >\&2

&nbsp;   \[\[ $rc -eq 2 ]] \&\& exit 2 || exit 1

&nbsp; fi

fi

```



---



\## mode d’emploi (pas-à-pas)



1\. \*\*bac à sable\*\*



```bash

mkdir -p ~/logfilter\_demo

cat > ~/logfilter\_demo/app.log <<'LOG'

2025-09-11 10:15:00 INFO  Server started

2025-09-11 10:16:02 WARN  Slow query on /api/v1/items

2025-09-11 10:16:45 ERROR DB timeout while connecting to database

2025-09-10 22:59:59 INFO  Nightly job done

2025-09-12 00:00:01 ERROR Unhandled exception

LOG

```



2\. \*\*sauvegarder le script\*\* puis le rendre exécutable



```bash

chmod +x logfilter.sh

```



3\. \*\*voir l’aide\*\*



```bash

./logfilter.sh -h

```



4\. \*\*exemple 1 — filtrer par niveaux (ERROR,WARN)\*\*

&nbsp;  afficher seulement les erreurs/avertissements :



```bash

./logfilter.sh -i ~/logfilter\_demo/app.log -L "ERROR,WARN"

```



5\. \*\*exemple 2 — fenêtre temporelle\*\*

&nbsp;  garder ce qui est \*\*après\*\* 2025-09-11 00:00:00 et \*\*avant\*\* 2025-09-11 23:59:59 :



```bash

./logfilter.sh \\

&nbsp; -i ~/logfilter\_demo/app.log \\

&nbsp; -A "2025-09-11 00:00:00" \\

&nbsp; -B "2025-09-11 23:59:59"

```



6\. \*\*exemple 3 — motif “database” + niveaux\*\*

&nbsp;  simuler (dry-run) ce qui matche `database` et niveaux `ERROR,WARN`, et écrire dans un fichier :



```bash

./logfilter.sh \\

&nbsp; -i ~/logfilter\_demo/app.log \\

&nbsp; -L "ERROR,WARN" \\

&nbsp; -P "database" \\

&nbsp; -o ~/logfilter\_demo/filtered.log \\

&nbsp; -n -v

\# DRY-RUN: affiche en stdout, ne crée pas filtered.log

```



puis exécuter vraiment :



```bash

./logfilter.sh \\

&nbsp; -i ~/logfilter\_demo/app.log \\

&nbsp; -L "ERROR,WARN" \\

&nbsp; -P "database" \\

&nbsp; -o ~/logfilter\_demo/filtered.log \\

&nbsp; -v

sed -n '1,50p' ~/logfilter\_demo/filtered.log

```



7\. \*\*codes retour\*\*



```bash

./logfilter.sh -i ~/logfilter\_demo/app.log -P "no-such-pattern" || echo "RC=$?"

\# RC=2 (aucun résultat)

```



---



\## points pédagogiques (très bref)



\* \*\*getopts\*\* propre + messages clairs.

\* \*\*pré-calcul\*\* des bornes temporelles en epoch (\*\*date -d\*\*).

\* \*\*awk\*\* : extraction \*\*ts/level\*\* et tests successifs (niveaux, regex, temps).

\* \*\*dry-run / verbose\*\* : comprendre avant d’écrire.

\* \*\*retours\*\* : 0/1/2 pour scripting de CI ou automatisations futures.





