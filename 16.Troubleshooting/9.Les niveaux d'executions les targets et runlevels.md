# 🧠 Atelier 10 (version démonstrative)

**Exploration progressive des *targets systemd* et réparations concrètes – Debian 13**

---

## 🎯 Objectif général

Passer **progressivement de `emergency.target` à `graphical.target`**,  
et à chaque niveau :

- observer **ce qui est lancé**,

- confirmer **ce qui est désactivé**,

- exécuter **une réparation typique** réalisable à ce stade.

---

## 🧩 1. Préparation initiale

Avant de commencer :

```bash
sudo systemctl get-default
```

🗨️ **Exemple de sortie** :

```
graphical.target
```

➡️ Cela indique que Debian démarre normalement en mode graphique.  
Nous allons maintenant isoler chaque target successivement.

---

## 🔸 Phase 1 : emergency.target

*(niveau minimal absolu – aucun service, aucun montage secondaire)*

### 1.1 – Entrer dans le mode

```bash
sudo systemctl isolate emergency.target
```

Tu obtiens une console root directe, sans authentification, sans couleur, souvent sans message de bienvenue.

---

### 1.2 – Vérification concrète

```bash
whoami
ps -p 1 -o comm=
systemctl list-units --type=service --state=running
ip link
```

🗨️ **Analyse des résultats attendus** :

- `whoami` → `root`

- `ps -p 1 -o comm=` → `systemd`

- `systemctl list-units ...` → très peu de services (souvent `systemd-journald`, `systemd-udevd`, `emergency.service`)

- `ip link` → interface `lo` seulement (aucun `enp0s3` ou `eth0` actif)

---

### 1.3 – Cas concret : réparer `/etc/fstab`

```bash
mount -o remount,rw /
nano /etc/fstab
mount -a
```

🗨️ **Observation** :

- Avant la correction, `mount -a` générait une erreur sur un UUID invalide.

- Après correction, aucun message d’erreur.

👉 **Tu viens de restaurer la capacité du système à atteindre `rescue.target`.**

---

## 🔸 Phase 2 : rescue.target

*(équivalent runlevel 1 – mono-utilisateur, système monté, pas de réseau)*

### 2.1 – Passage

```bash
sudo systemctl isolate rescue.target
```

Tu verras un message du type :

```
You are in rescue mode. Press Ctrl-D to continue or enter root password for maintenance.
```

---

### 2.2 – Vérification concrète

```bash
whoami
systemctl list-units --type=service --state=running | grep -E "sshd|NetworkManager|gdm"
ip a
lsmod | grep e1000
```

🗨️ **Analyse** :

- `sshd`, `NetworkManager`, `gdm` n’apparaissent pas → **pas de réseau ni interface graphique**.

- `ip a` → `lo` actif uniquement.

- `lsmod | grep e1000` → le module du pilote réseau n’est même pas chargé.

---

### 2.3 – Cas concret : régénérer un initramfs manquant

```bash
update-initramfs -u -k all
ls -lh /boot/initrd.img*
```

🗨️ **Observation** : tu vois maintenant une image initrd recréée.  
➡️ Cela corrige les pannes de boot signalées à l’étape `initramfs shell`.

---

## 🔸 Phase 3 : multi-user.target

*(équivalent runlevel 3 – mode texte, réseau et services actifs)*

### 3.1 – Passage

```bash
sudo systemctl isolate multi-user.target
```

---

### 3.2 – Vérifications concrètes

```bash
systemctl list-units --type=service --state=running | head -n 10
systemctl is-active ssh
systemctl is-active NetworkManager
ip -br addr
ss -tlnp
```

🗨️ **Analyse :**

- `sshd.service` et `NetworkManager.service` doivent être **actifs**.

- `ip -br addr` → tu verras une adresse IP attribuée (`enp0s3 UP 192.168.x.x`).

- `ss -tlnp` → port 22 ouvert (SSH).

👉 **On peut désormais intervenir à distance.**

---

### 3.3 – Cas concret : corriger un service bloqué

```bash
systemctl --failed
systemctl status rsyslog
journalctl -u rsyslog | tail -n 5
systemctl restart rsyslog
```

🗨️ **Observation :**  
Tu détectes, inspectes puis redémarres un service critique, par exemple `rsyslog`.

---

## 🔸 Phase 4 : graphical.target

*(équivalent runlevel 5 – interface graphique complète)*

### 4.1 – Passage

```bash
sudo systemctl isolate graphical.target
```

---

### 4.2 – Vérifications concrètes

```bash
systemctl is-active gdm
systemctl list-units --type=target | grep graphical
ps aux | grep Xorg
loginctl list-sessions
```

🗨️ **Analyse** :

- `gdm.service` → actif.

- `Xorg` ou `Wayland` présent dans `ps aux`.

- `loginctl list-sessions` → affiche la session utilisateur connectée (`seat0`).

---

### 4.3 – Cas concret : réparation graphique

```bash
lspci | grep VGA
apt reinstall firmware-misc-nonfree
systemctl restart gdm
```

🗨️ **Observation** :

- Après réinstallation du firmware, la session graphique redémarre correctement.

- Les logs de `journalctl -xe` ne contiennent plus d’erreur GPU.

---

## 🔸 Phase 5 : reboot.target & poweroff.target

### Vérification

```bash
systemctl isolate reboot.target
```

🗨️ **Observation :**  
Le système redémarre proprement, sans redémarrage brutal (pas de `fsck` au boot suivant).

---

## 🔸 Phase 6 : synthèse des niveaux et tests

| Target       | Services visibles                     | Commande de test         | Exemple de panne traitée |
| ------------ | ------------------------------------- | ------------------------ | ------------------------ |
| `emergency`  | `systemd-journald`, `udevd`           | `ip link` → `lo` seul    | `/etc/fstab` invalide    |
| `rescue`     | `journald`, `udevd`, `systemd-logind` | `systemctl list-units`   | initramfs / GRUB         |
| `multi-user` | + `NetworkManager`, `sshd`, `cron`    | `ip -br addr`            | service bloqué, DNS      |
| `graphical`  | + `gdm`, `Xorg`, `cups`               | `loginctl list-sessions` | pilote graphique         |

---

## ✅ Résumé de la démarche

1. **Isoler un target** pour travailler dans un contexte propre.

2. **Observer les processus réellement chargés** (`systemctl list-units`, `ps -p 1 -o comm=`).

3. **Confirmer ce qui est arrêté** (`systemctl is-active ...`).

4. **Effectuer des réparations adaptées au niveau courant**.

5. **Remonter progressivement vers `graphical.target`** après validation.


