

# ğŸŸ¢ Exercice 1 â€” Premier handler (redÃ©marrage de service)

## Contexte & objectif

On installe `nginx`. Si un changement est fait (installation rÃ©ussie), Ansible doit **redÃ©marrer nginx automatiquement** grÃ¢ce Ã  un handler.

## OÃ¹ sont dÃ©finies les variables ?

Dans `group_vars/web.yml` :

```
project/
 â”œâ”€ group_vars/
 â”‚   â””â”€ web.yml
 â”œâ”€ ex01_handler.yml
 â””â”€ ex01_cleanup.yml
```

**Contenu `group_vars/web.yml`**

```yaml
package_name: nginx
```

## Playbook principal â€” `ex01_handler.yml`

```yaml
---
- name: Install and restart nginx with handler
  hosts: web
  become: yes
  tasks:
    - name: Install nginx
      apt:
        name: "{{ package_name }}"   # variable dÃ©finie dans group_vars/web.yml
        state: present
        update_cache: yes
      notify: restart nginx          # notifie le handler

  handlers:
    - name: restart nginx
      service:
        name: nginx
        state: restarted
```

## Playbook de nettoyage â€” `ex01_cleanup.yml`

```yaml
---
- name: Cleanup ex01
  hosts: web
  become: yes
  tasks:
    - name: Remove nginx
      apt:
        name: nginx
        state: absent
```

## Commandes

```bash
ansible-playbook ex01_handler.yml -i /etc/ansible/hosts
ansible-playbook ex01_cleanup.yml -i /etc/ansible/hosts
```

## VÃ©rification

```bash
ansible web -m service -a "name=nginx state=started"
```

## Lecture pas-Ã -pas

1. Ansible installe `nginx`.

2. Comme lâ€™Ã©tat change (`absent` â†’ `present`), la tÃ¢che notifie le handler.

3. Le handler `restart nginx` est exÃ©cutÃ© **Ã  la fin du playbook**.

## Astuces & piÃ¨ges

- Un handler **ne sâ€™exÃ©cute que si un changement se produit**.

- Il est exÃ©cutÃ© **une seule fois** mÃªme si plusieurs tÃ¢ches le notifient.

---

# ğŸŸ¢ Exercice 2 â€” Plusieurs handlers pour un mÃªme service

## Contexte & objectif

On installe `apache2`. Selon le cas, on veut **soit redÃ©marrer, soit recharger** le service.

## OÃ¹ ?

`group_vars/web.yml`

```yaml
package_name: apache2
```

## Playbook principal â€” `ex02_handler.yml`

```yaml
---
- name: Install Apache and notify multiple handlers
  hosts: web
  become: yes
  tasks:
    - name: Install apache2
      apt:
        name: "{{ package_name }}"
        state: present
      notify:
        - restart apache
        - reload apache

  handlers:
    - name: restart apache
      service:
        name: apache2
        state: restarted

    - name: reload apache
      service:
        name: apache2
        state: reloaded
```

## Cleanup â€” `ex02_cleanup.yml`

```yaml
---
- name: Cleanup ex02
  hosts: web
  become: yes
  tasks:
    - apt:
        name: apache2
        state: absent
```

## VÃ©rification

```bash
ansible web -m service -a "name=apache2 state=started"
```

## Lecture pas-Ã -pas

- Lâ€™installation dÃ©clenche **les deux handlers**.

- Ã€ la fin du playbook, `apache2` est dâ€™abord redÃ©marrÃ© puis rechargÃ©.

## Astuces & piÃ¨ges

- On peut notifier plusieurs handlers.

- Attention : **ordre non garanti** si plusieurs handlers â†’ regroupez la logique.

---

# ğŸŸ¢ Exercice 3 â€” Notifier uniquement si un fichier est modifiÃ©

## Contexte & objectif

On veut modifier `/etc/motd`. Le service ne doit redÃ©marrer **que si le fichier a changÃ©**.

## OÃ¹ ?

`group_vars/all.yml`

```yaml
motd_text: "Bienvenue sur ce serveur gÃ©rÃ© par Ansible"
```

## Playbook principal â€” `ex03_handler.yml`

```yaml
---
- name: Update MOTD and restart service only if changed
  hosts: all
  become: yes
  tasks:
    - name: Update MOTD
      copy:
        dest: /etc/motd
        content: "{{ motd_text }}"
      notify: restart ssh

  handlers:
    - name: restart ssh
      service:
        name: ssh
        state: restarted
```

## Cleanup â€” `ex03_cleanup.yml`

```yaml
---
- name: Cleanup ex03
  hosts: all
  become: yes
  tasks:
    - file:
        path: /etc/motd
        state: absent
```

## VÃ©rification

```bash
ansible all -m command -a "cat /etc/motd"
```

## Lecture pas-Ã -pas

1. Si `/etc/motd` a dÃ©jÃ  ce contenu â†’ pas de changement â†’ handler non dÃ©clenchÃ©.

2. Si modifiÃ© â†’ handler `restart ssh` sâ€™exÃ©cute.

## Astuces & piÃ¨ges

- Les handlers permettent dâ€™Ã©viter les **redÃ©marrages inutiles**.

- TrÃ¨s utilisÃ© pour des fichiers de conf (`nginx.conf`, `sshd_config`).

---

# ğŸŸ¢ Exercice 4 â€” Un handler appelÃ© par plusieurs tÃ¢ches

## Contexte & objectif

Plusieurs tÃ¢ches modifient la config dâ€™`nginx`. On veut **un seul restart final**.

## Playbook â€” `ex04_handler.yml`

```yaml
---
- name: Multiple tasks notify one handler
  hosts: web
  become: yes
  tasks:
    - name: Install nginx
      apt:
        name: nginx
        state: present
      notify: restart nginx

    - name: Deploy nginx config
      copy:
        dest: /etc/nginx/nginx.conf
        content: "worker_processes 1;"
      notify: restart nginx

  handlers:
    - name: restart nginx
      service:
        name: nginx
        state: restarted
```

## Cleanup â€” `ex04_cleanup.yml`

```yaml
---
- name: Cleanup ex04
  hosts: web
  become: yes
  tasks:
    - apt:
        name: nginx
        state: absent
```

## Lecture pas-Ã -pas

- Les 2 tÃ¢ches notifient le mÃªme handler.

- Handler exÃ©cutÃ© **une seule fois** Ã  la fin â†’ restart unique.

## Astuces & piÃ¨ges

- Câ€™est **le vrai intÃ©rÃªt des handlers** â†’ Ã©viter les redÃ©marrages multiples.

---

# ğŸŸ¢ Exercice 5 â€” Handler pour exÃ©cuter une commande custom

## Contexte & objectif

AprÃ¨s un dÃ©ploiement, exÃ©cuter une commande `systemctl daemon-reload`.

## Playbook â€” `ex05_handler.yml`

```yaml
---
- name: Custom handler with command
  hosts: all
  become: yes
  tasks:
    - name: Deploy systemd unit file
      copy:
        dest: /etc/systemd/system/demo.service
        content: |
          [Service]
          ExecStart=/bin/true
      notify: reload systemd

  handlers:
    - name: reload systemd
      command: systemctl daemon-reexec
```

## Cleanup â€” `ex05_cleanup.yml`

```yaml
---
- name: Cleanup ex05
  hosts: all
  become: yes
  tasks:
    - file:
        path: /etc/systemd/system/demo.service
        state: absent
```

## Astuces & piÃ¨ges

- On peut utiliser nâ€™importe quel module (`command`, `shell`, `script`).

- Mais prÃ©fÃ©rez `service` quand câ€™est possible (idempotent).

---

# ğŸŸ¢ Exercice 6 â€” Notifier conditionnellement avec `when`

## Contexte & objectif

On ne redÃ©marre `ssh` que sur Debian.

## Playbook â€” `ex06_handler.yml`

```yaml
---
- name: Conditional notify
  hosts: all
  gather_facts: true
  become: yes
  tasks:
    - name: Change MOTD only on Debian
      copy:
        dest: /etc/motd
        content: "Debian system"
      when: ansible_facts['distribution'] == "Debian"
      notify: restart ssh

  handlers:
    - name: restart ssh
      service:
        name: ssh
        state: restarted
```

## Astuces & piÃ¨ges

- Le `notify` se dÃ©clenche uniquement si la tÃ¢che sâ€™exÃ©cute ET fait un changement.

---

# ğŸŸ¢ Exercice 7 â€” Plusieurs plays rÃ©utilisant les mÃªmes handlers

## Contexte & objectif

Centraliser des handlers communs dans plusieurs plays.

## Playbook â€” `ex07_handler.yml`

```yaml
---
- name: Play 1
  hosts: web
  become: yes
  tasks:
    - name: Update nginx conf
      copy:
        dest: /etc/nginx/nginx.conf
        content: "worker_processes 1;"
      notify: restart nginx

- name: Play 2
  hosts: app
  become: yes
  tasks:
    - name: Update Apache conf
      copy:
        dest: /etc/apache2/apache2.conf
        content: "Timeout 300"
      notify: restart apache

  handlers:
    - name: restart nginx
      service:
        name: nginx
        state: restarted

    - name: restart apache
      service:
        name: apache2
        state: restarted
```

## Astuces & piÃ¨ges

- Les handlers peuvent Ãªtre dÃ©finis **par play**.

- Pour factoriser, utilisez un rÃ´le avec `handlers/main.yml`.

---

# ğŸŸ¢ Exercice 8 â€” Utiliser `listen:` pour grouper des handlers

## Contexte & objectif

Un mÃªme handler doit Ãªtre dÃ©clenchÃ© sous plusieurs noms.

## Playbook â€” `ex08_handler.yml`

```yaml
---
- name: Handler with listen
  hosts: web
  become: yes
  tasks:
    - name: Update config
      copy:
        dest: /etc/nginx/conf.d/demo.conf
        content: "test"
      notify:
        - restart webserver

  handlers:
    - name: restart nginx
      listen: restart webserver   # alias
      service:
        name: nginx
        state: restarted
```

## Astuces & piÃ¨ges

- `listen:` permet de donner **plusieurs alias** au mÃªme handler.

---

# ğŸŸ¢ Exercice 9 â€” Handler dÃ©clenchÃ© par un rÃ´le

## Contexte & objectif

Un rÃ´le dÃ©ploie `nginx` et notifie un handler global.

**Arborescence** :

```
roles/web/tasks/main.yml
roles/web/handlers/main.yml
```

**`roles/web/tasks/main.yml`**

```yaml
- name: Install nginx
  apt:
    name: nginx
    state: present
  notify: restart nginx
```

**`roles/web/handlers/main.yml`**

```yaml
- name: restart nginx
  service:
    name: nginx
    state: restarted
```

**Playbook `ex09_role.yml`**

```yaml
---
- name: Use role with handlers
  hosts: web
  roles:
    - web
```

## Astuces & piÃ¨ges

- Les handlers sont souvent placÃ©s dans les rÃ´les (`handlers/main.yml`).

---

# ğŸŸ¢ Exercice 10 â€” Forcer un handler immÃ©diatement (`meta: flush_handlers`)

## Contexte & objectif

Par dÃ©faut, un handler sâ€™exÃ©cute **Ã  la fin**. Ici, on veut quâ€™il sâ€™exÃ©cute **tout de suite**.

## Playbook â€” `ex10_handler.yml`

```yaml
---
- name: Immediate handler execution
  hosts: web
  become: yes
  tasks:
    - name: Deploy nginx conf
      copy:
        dest: /etc/nginx/nginx.conf
        content: "worker_processes 4;"
      notify: restart nginx

    - meta: flush_handlers   # force lâ€™exÃ©cution immÃ©diate

    - name: Continue with other tasks
      debug:
        msg: "Handlers already executed!"
  handlers:
    - name: restart nginx
      service:
        name: nginx
        state: restarted
```

## Astuces & piÃ¨ges

- `flush_handlers` est trÃ¨s puissant mais Ã  utiliser **rarement** â†’ casse la logique habituelle.
