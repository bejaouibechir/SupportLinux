# Les variables

# Exercice 1 — Host vars dans l’inventaire (par hôte)

## Contexte

Chaque serveur web écoute un **port HTTP différent**. On veut lire ce port depuis l’inventaire.

## Objectif

Créer un fichier marqueur propre à **chaque hôte** contenant sa valeur `http_port`.

## Où sont définies les variables ?

Dans l’inventaire INI : **/etc/ansible/hosts**

```ini
[web]
web1 ansible_host=10.0.0.11 http_port=8080
web2 ansible_host=10.0.0.12 http_port=8081
```

## Playbook principal — `ex01_hostvar.yml`

```yaml
---
- name: Use host var from inventory
  hosts: web                  # cible le groupe [web]
  gather_facts: false         # pas besoin de facts ici
  tasks:
    - name: Create host-specific marker
      copy:
        dest: "/tmp/host_port_{{ inventory_hostname }}.txt"   # fichier distinct par hôte
        content: "http_port={{ http_port }}"                  # <-- VIENT de l'inventaire (host var)
```

## Playbook de nettoyage — `ex01_cleanup.yml`

```yaml
---
- name: Cleanup ex01
  hosts: web
  tasks:
    - file:
        path: "/tmp/host_port_{{ inventory_hostname }}.txt"
        state: absent
```

## Commandes

```bash
ansible-playbook -i /etc/ansible/hosts ex01_hostvar.yml
ansible-playbook -i /etc/ansible/hosts ex01_cleanup.yml
```

## Vérification

```bash
ansible web -i /etc/ansible/hosts -m command -a "cat /tmp/host_port_$(hostname) 2>/dev/null || true"
```

## Lecture pas-à-pas

1. Ansible lit l’inventaire, associe `http_port` à chaque hôte.

2. La tâche `copy` écrit `http_port=<valeur>` dans un fichier différent par hôte (grâce à `inventory_hostname`).

## Astuces & pièges

- Gardez les **différences machine par machine** en **host vars** (ports, chemins).

- Évitez de dupliquer la même variable dans 10 endroits : **une seule source de vérité**.

---

# Exercice 2 — Group vars dans l’inventaire (par groupe)

## Contexte

Toutes les machines d’application partagent la même **variable d’environnement**.

## Objectif

Écrire un fichier `/tmp/app_env.txt` avec `app_env` pour **tous les hôtes du groupe**.

## Où ?

Dans **/etc/ansible/hosts** (section `[app:vars]`)

```ini
[app]
app1 ansible_host=10.0.1.11
app2 ansible_host=10.0.1.12

[app:vars]
app_env=staging
```

## Playbook principal — `ex02_groupvar.yml`

```yaml
---
- name: Use group vars from inventory
  hosts: app
  gather_facts: false
  tasks:
    - name: Save group env to file
      copy:
        dest: /tmp/app_env.txt
        content: "env={{ app_env }}"    # <-- vient de [app:vars]
```

## Cleanup — `ex02_cleanup.yml`

```yaml
---
- name: Cleanup ex02
  hosts: app
  tasks:
    - file:
        path: /tmp/app_env.txt
        state: absent
```

## Lecture pas-à-pas

- Le groupe `app` reçoit `app_env=staging`. La tâche `copy` écrit cette valeur partout sur `app`.

## Astuces & pièges

- Ça marche, mais pour des projets, **préférez `group_vars/`** (mieux organisé/versionné).

---

# Exercice 3 — `group_vars/` **auto-chargé** (aucune référence dans le playbook)

## Contexte

Vous voulez définir une version `nginx_version` commune aux **web** sans toucher le playbook.

## Objectif

Écrire `/tmp/nginx_version.txt` en récupérant **automatiquement** `nginx_version`.

## Où ? (arborescence)

```
project/
 ├─ group_vars/
 │   └─ web.yml                # le NOM du fichier = NOM du groupe
 └─ ex03_groupvars_dir.yml
```

**Contenu** `group_vars/web.yml`

```yaml
nginx_version: "1.24"
```

> ✅ **Rien à indiquer dans le playbook** : Ansible charge `group_vars/web.yml` tout seul.

## Playbook principal — `ex03_groupvars_dir.yml`

```yaml
---
- name: Use group_vars/web.yml (auto-loaded)
  hosts: web
  gather_facts: false
  tasks:
    - name: Write nginx_version from group_vars
      copy:
        dest: /tmp/nginx_version.txt
        content: "nginx_version={{ nginx_version }}" # <-- auto depuis group_vars/web.yml
```

## Cleanup — `ex03_cleanup.yml`

```yaml
---
- name: Cleanup ex03
  hosts: web
  tasks:
    - file:
        path: /tmp/nginx_version.txt
        state: absent
```

## Lecture pas-à-pas

1. Ansible voit un groupe `web` → charge automatiquement `group_vars/web.yml`.

2. La tâche `copy` consomme `nginx_version` sans `vars_files:` ni `include_vars`.

## Astuces & pièges

- **Respectez les noms** : `group_vars/<nom_du_groupe>.yml`.

- C’est **la** méthode recommandée pour les paramètres partagés d’un groupe.

---

# Exercice 4 — `host_vars/` **auto-chargé** (aucune référence dans le playbook)

## Contexte

L’hôte `web1` a un `site_name` spécifique.

## Objectif

Écrire `/tmp/site_name.txt` avec la valeur propre à `web1`.

## Où ? (arborescence)

```
project/
 ├─ host_vars/
 │   └─ web1.yml               # le NOM du fichier = NOM de l'hôte
 └─ ex04_hostvars_dir.yml
```

**Contenu** `host_vars/web1.yml`

```yaml
site_name: "frontend-A"
```

> ✅ **Rien à indiquer dans le playbook** : Ansible charge `host_vars/web1.yml` tout seul.

## Playbook principal — `ex04_hostvars_dir.yml`

```yaml
---
- name: Use host_vars/web1.yml (auto-loaded)
  hosts: web1
  gather_facts: false
  tasks:
    - name: Write site_name from host_vars
      copy:
        dest: /tmp/site_name.txt
        content: "site_name={{ site_name }}"   # <-- auto depuis host_vars/web1.yml
```

## Cleanup — `ex04_cleanup.yml`

```yaml
---
- name: Cleanup ex04
  hosts: web1
  tasks:
    - file:
        path: /tmp/site_name.txt
        state: absent
```

## Lecture pas-à-pas

1. Ansible cible `web1` → charge automatiquement `host_vars/web1.yml`.

2. La tâche `copy` écrit la valeur chargée.

## Astuces & pièges

- **host_vars** l’emporte sur **group_vars** (priorité supérieure).

- Gardez **host_vars** pour les **exceptions**, pas comme règle générale.

---

# Exercice 5 — Variables **dans le playbook** (`vars:` du play)

## Contexte

Définir des variables “globales au play” visibles par toutes les tâches.

## Objectif

Écrire `/tmp/play_scope.txt` avec `company` et `tier`.

## Playbook principal — `ex05_play_vars.yml`

```yaml
---
- name: Vars inside the play (play scope)
  hosts: all
  gather_facts: false

  # Définition DANS le playbook (visibles dans tout le play)
  vars:
    company: "AcmeCorp"
    tier: "backend"

  tasks:
    - name: Save play vars
      copy:
        dest: /tmp/play_scope.txt
        content: "company={{ company }}, tier={{ tier }}"
```

## Cleanup — `ex05_cleanup.yml`

```yaml
---
- name: Cleanup ex05
  hosts: all
  tasks:
    - file:
        path: /tmp/play_scope.txt
        state: absent
```

## Lecture pas-à-pas

- `vars:` au niveau du play → accessible partout dans ce play.

## Astuces & pièges

- Lisible et pratique, mais **attention aux conflits** avec d’autres sources.

---

# Exercice 6 — `vars_files:` (charger YAML externe)

## Contexte

Vous centralisez les variables DB dans un fichier.

## Objectif

Écrire `/tmp/db_info.txt` avec `db_name` et `db_user`.

## Où ? (arborescence)

```
project/
 ├─ vars/
 │   └─ db.yml
 └─ ex06_vars_files.yml
```

**Contenu** `vars/db.yml`

```yaml
db_name: shop
db_user: appuser
```

## Playbook principal — `ex06_vars_files.yml`

```yaml
---
- name: Load variables from vars_files
  hosts: db
  gather_facts: false

  # On charge explicitement un fichier de variables
  vars_files:
    - vars/db.yml

  tasks:
    - name: Use DB vars from file
      copy:
        dest: /tmp/db_info.txt
        content: "db={{ db_name }} user={{ db_user }}"
```

## Cleanup — `ex06_cleanup.yml`

```yaml
---
- name: Cleanup ex06
  hosts: db
  tasks:
    - file:
        path: /tmp/db_info.txt
        state: absent
```

## Astuces & pièges

- Idéal pour **gros blocs** de variables (pensez à **Vault** si sensibles).

- Le chemin est **relatif au playbook** (ou absolu).

---

# Exercice 7 — `vars_prompt:` (saisie interactive)

## Contexte

Demander un paramètre au moment de l’exécution (démo).

## Objectif

Créer `/tmp/admin_email.txt` avec la valeur saisie.

## Playbook principal — `ex07_vars_prompt.yml`

```yaml
---
- name: Ask at runtime (prompt)
  hosts: all
  gather_facts: false

  vars_prompt:
    - name: admin_email              # variable créée via prompt
      prompt: "Enter admin email"
      private: no                    # pour voir ce qu'on tape (démo); en vrai: yes

  tasks:
    - name: Save admin email
      copy:
        dest: /tmp/admin_email.txt
        content: "admin_email={{ admin_email }}"
```

## Cleanup — `ex07_cleanup.yml`

```yaml
---
- name: Cleanup ex07
  hosts: all
  tasks:
    - file:
        path: /tmp/admin_email.txt
        state: absent
```

## Astuces & pièges

- Bien pour une démo. En **CI/CD**, évitez l’interactif → préférez fichiers/vars.

---

# Exercice 8 — `set_fact` (variable **dynamique** à l’exécution)

## Contexte

Décider dynamiquement si la machine a assez de RAM.

## Objectif

Créer `/tmp/ram_flag.txt` avec `has_2gb_ram=true/false`.

## Playbook principal — `ex08_set_fact.yml`

```yaml
---
- name: Dynamic vars with set_fact
  hosts: all
  gather_facts: true     # on a besoin de ansible_facts.memtotal_mb
  tasks:
    - name: Compute flag from facts
      set_fact:
        has_2gb_ram: "{{ (ansible_facts.memtotal_mb | int) >= 2048 }}"  # booléen

    - name: Save flag
      copy:
        dest: /tmp/ram_flag.txt
        content: "has_2gb_ram={{ has_2gb_ram }}"
```

## Cleanup — `ex08_cleanup.yml`

```yaml
---
- name: Cleanup ex08
  hosts: all
  tasks:
    - file:
        path: /tmp/ram_flag.txt
        state: absent
```

## Lecture pas-à-pas

1. `gather_facts` collecte la RAM totale.

2. `set_fact` crée un **booléen** réutilisable dans le play.

3. `copy` écrit le résultat.

## Astuces & pièges

- Très utile pour des **conditions lisibles** (`when: has_2gb_ram`).

---

# Exercice 9 — Rôle : `defaults/main.yml` (priorité la plus faible)

## Contexte

Un rôle `web` fournit des valeurs par défaut faciles à surcharger.

## Objectif

Écrire `/tmp/role_default_port.txt` avec `http_port` (par défaut 80).

## Où ? (arborescence)

```
roles/
 └─ web/
    └─ defaults/
       └─ main.yml
```

**Contenu** `roles/web/defaults/main.yml`

```yaml
http_port: 80
```

## Playbook principal — `ex09_role_defaults.yml`

```yaml
---
- name: Use role defaults
  hosts: web
  roles:
    - role: web                 # apporte http_port: 80 (facile à surcharger ailleurs)
  tasks:
    - name: Write default http_port
      copy:
        dest: /tmp/role_default_port.txt
        content: "http_port={{ http_port }}"
```

## Cleanup — `ex09_cleanup.yml`

```yaml
---
- name: Cleanup ex09
  hosts: web
  tasks:
    - file:
        path: /tmp/role_default_port.txt
        state: absent
```

## Astuces & pièges

- Mettez ici ce que vous **voulez permettre de surcharger** (ex. par `group_vars`).

---

# Exercice 10 — Rôle : `vars/main.yml` (priorité très forte)

## Contexte

Un rôle `api` impose une valeur `api_timeout` qu’on ne veut **pas** surcharger.

## Objectif

Écrire `/tmp/api_timeout.txt` avec `api_timeout=5`.

## Où ? (arborescence)

```
roles/
 └─ api/
    └─ vars/
       └─ main.yml
```

**Contenu** `roles/api/vars/main.yml`

```yaml
api_timeout: 5
```

## Playbook principal — `ex10_role_vars.yml`

```yaml
---
- name: Use role vars (high priority, hard to override)
  hosts: all
  roles:
    - role: api                  # apporte api_timeout: 5
  tasks:
    - name: Save api_timeout
      copy:
        dest: /tmp/api_timeout.txt
        content: "api_timeout={{ api_timeout }}"
```

## Cleanup — `ex10_cleanup.yml`

```yaml
---
- name: Cleanup ex10
  hosts: all
  tasks:
    - file:
        path: /tmp/api_timeout.txt
        state: absent
```

## Astuces & pièges

- `vars/main.yml` **écrase** presque tout. À éviter pour des valeurs qu’on doit personnaliser.

# Exercice 11 — Utiliser les **facts** (`gather_facts`)

## Contexte

Ansible peut collecter automatiquement des **informations système** (distribution, mémoire, interfaces).

## Objectif

Créer un fichier `/tmp/facts.txt` contenant l’OS et la mémoire totale.

## Où ?

Pas besoin de fichiers externes : les facts viennent de l’option `gather_facts: true`.

## Playbook principal — `ex11_facts.yml`

```yaml
---
- name: Use gathered facts
  hosts: all
  gather_facts: true    # collecte automatique des facts système
  tasks:
    - name: Save OS and RAM
      copy:
        dest: /tmp/facts.txt
        content: "os={{ ansible_facts.distribution }}, ram={{ ansible_facts.memtotal_mb }}MB"
```

## Cleanup — `ex11_cleanup.yml`

```yaml
---
- name: Cleanup ex11
  hosts: all
  tasks:
    - file:
        path: /tmp/facts.txt
        state: absent
```

## Lecture pas-à-pas

1. Ansible collecte les facts.

2. On récupère `ansible_facts.distribution` et `ansible_facts.memtotal_mb`.

3. On écrit les valeurs dans un fichier.

## Astuces & pièges

- Les facts ont une **faible priorité** (facilement écrasés).

- Très utiles pour conditions (`when`) ou templates.

---

# Exercice 12 — Variables **au niveau d’une tâche**

## Contexte

On veut définir une variable **juste pour une tâche**, sans polluer le play.

## Objectif

Écrire `/tmp/task_var.txt` avec la couleur définie dans la tâche.

## Playbook principal — `ex12_task_vars.yml`

```yaml
---
- name: Task-level vars
  hosts: all
  gather_facts: false
  tasks:
    - name: Save color (task-specific var)
      copy:
        dest: /tmp/task_var.txt
        content: "color={{ color }}"
      vars:                # <— portée spécifique à cette tâche
        color: "blue"
```

## Cleanup — `ex12_cleanup.yml`

```yaml
---
- name: Cleanup ex12
  hosts: all
  tasks:
    - file:
        path: /tmp/task_var.txt
        state: absent
```

## Lecture pas-à-pas

1. La variable `color` n’existe que pour cette tâche.

2. Ansible écrit `color=blue`.

## Astuces & pièges

- Idéal pour **petites variations locales**.

- N’abusez pas → ça peut nuire à la lisibilité.

---

# Exercice 13 — Priorité : `defaults` vs `group_vars` vs `-e`

## Contexte

On veut démontrer **qui gagne** si une variable existe à plusieurs endroits.

## Objectif

Écrire `/tmp/precedence.txt` avec la valeur finale de `http_port`.

## Où ?

- `roles/web/defaults/main.yml` → `http_port: 80`

- `group_vars/web.yml` → `http_port: 8080`

## Playbook principal — `ex13_precedence.yml`

```yaml
---
- name: Variable precedence demo
  hosts: web
  roles:
    - role: web          # apporte http_port: 80 (defaults)
  tasks:
    - name: Write http_port
      copy:
        dest: /tmp/precedence.txt
        content: "http_port={{ http_port }}"
```

## Commandes

```bash
ansible-playbook ex13_precedence.yml -i /etc/ansible/hosts
# => écrit 8080 car group_vars > defaults

ansible-playbook ex13_precedence.yml -i /etc/ansible/hosts -e "http_port=9090"
# => écrit 9090 car -e > tout le reste
```

## Cleanup — `ex13_cleanup.yml`

```yaml
---
- name: Cleanup ex13
  hosts: web
  tasks:
    - file:
        path: /tmp/precedence.txt
        state: absent
```

## Astuces & pièges

- La hiérarchie est cruciale : `-e` **gagne toujours**.

- Documentez les overrides autorisés pour éviter les surprises.

---

# Exercice 14 — Contextes **dev / prod / staging**

## Contexte

On veut un seul playbook, mais des variables différentes selon l’environnement.

## Objectif

Écrire `/tmp/env_info.txt` avec `app_env` et `db_host`.

## Où ?

`group_vars/dev.yml`

```yaml
app_env: dev
db_host: 10.10.0.10
```

`group_vars/prod.yml`

```yaml
app_env: prod
db_host: 10.20.0.20
```

## Structure

ex14/
├─ inventory.ini
├─ group_vars/
│  ├─ dev.yml
│  ├─ prod.yml
│  └─ staging.yml
├─ ex14_envs.yml
└─ ex14_cleanup.yml

Configurer le fichier **hosts** :

```bash
# Inventaire minimal : on définit explicitement les groupes
[dev]
dev1 ansible_host=192.168.56.11

[prod]
prod1 ansible_host=192.168.56.21

[staging]
stg1 ansible_host=192.168.56.31
```

 Créer le fichier **group_vars/dev.yml** :

```bash
# Variables propres à l'environnement dev
app_env: dev
db_host: 10.10.0.10
```

Créer le fichier **group_vars/prod.yml** :

```bash
# Variables propres à l'environnement prod
app_env: prod
db_host: 10.20.0.20
```

## Playbook principal — `ex14_envs.yml`

```yaml
---
- name: Environment-specific vars
  hosts: "{{ target_group }}"   # choisi à l’exécution
  gather_facts: false
  tasks:
    - name: Save env info
      copy:
        dest: /tmp/env_info.txt
        content: "env={{ app_env }}, db={{ db_host }}"
```

## Commandes

```bash
ansible-playbook ex14_envs.yml -e "target_group=dev"
ansible-playbook ex14_envs.yml -e "target_group=prod"
```

## Cleanup — `ex14_cleanup.yml`

```yaml
---
- name: Cleanup ex14
  hosts: "dev:prod:staging"
  tasks:
    - file:
        path: /tmp/env_info.txt
        state: absent
```

## Astuces & pièges

- Meilleure pratique pour **multi-environnements**.

- Pas besoin de multiplier les playbooks.

---

# Exercice 15 — Override avec `--extra-vars` (`-e`)

## Contexte

On veut tester un **feature flag** activable à l’exécution.

## Objectif

Écrire `/tmp/feature.txt` avec `feature_flag`.

## Playbook principal — `ex15_extra_vars.yml`

```yaml
---
- name: Extra-vars override
  hosts: all
  gather_facts: false
  vars:
    feature_flag: false     # valeur par défaut
  tasks:
    - name: Save feature flag
      copy:
        dest: /tmp/feature.txt
        content: "feature_flag={{ feature_flag }}"
```

## Commandes

```bash
ansible-playbook ex15_extra_vars.yml
# => écrit false

ansible-playbook ex15_extra_vars.yml -e "feature_flag=true"
# => écrit true
```

## Cleanup — `ex15_cleanup.yml`

```yaml
---
- name: Cleanup ex15
  hosts: all
  tasks:
    - file:
        path: /tmp/feature.txt
        state: absent
```

## Astuces & pièges

- `-e` est le **roi**.

- Ne passez jamais de **secrets en clair** avec `-e`.

---

# Exercice 16 — Extra-vars depuis un fichier JSON

## Contexte

Vous recevez des variables via un fichier JSON/YAML (CI/CD).

## Objectif

Écrire `/tmp/release.txt` avec `release` et `replicas`.

## Où ?

`vars/deploy.json`

```json
{ "release": "2.3.1", "replicas": 3 }
```

## Playbook principal — `ex16_extra_vars_file.yml`

```yaml
---
- name: Extra-vars from file
  hosts: all
  gather_facts: false
  tasks:
    - name: Save release info
      copy:
        dest: /tmp/release.txt
        content: "release={{ release }}, replicas={{ replicas }}"
```

## Commande

```bash
ansible-playbook ex16_extra_vars_file.yml -e "@vars/deploy.json"
```

## Cleanup — `ex16_cleanup.yml`

```yaml
---
- name: Cleanup ex16
  hosts: all
  tasks:
    - file:
        path: /tmp/release.txt
        state: absent
```

## Astuces & pièges

- Plus sûr et lisible que `-e "key=val"`.

- Les fichiers JSON/YAML sont versionnables.

---

# Exercice 17 — Conflit `group_vars` vs `host_vars`

## Contexte

Une timezone par défaut (UTC), mais `web1` doit avoir une exception.

## Objectif

Écrire `/tmp/tz_<hostname>.txt` avec la timezone effective.

## Où ?

`group_vars/web.yml`

```yaml
timezone: "UTC"
```

`host_vars/web1.yml`

```yaml
timezone: "Africa/Tunis"
```

## Playbook principal — `ex17_host_overrides_group.yml`

```yaml
---
- name: Host overrides group
  hosts: web
  gather_facts: false
  tasks:
    - name: Save timezone
      copy:
        dest: "/tmp/tz_{{ inventory_hostname }}.txt"
        content: "timezone={{ timezone }}"
```

## Cleanup — `ex17_cleanup.yml`

```yaml
---
- name: Cleanup ex17
  hosts: web
  tasks:
    - file:
        path: "/tmp/tz_{{ inventory_hostname }}.txt"
        state: absent
```

## Lecture pas-à-pas

- Les hôtes du groupe `web` reçoivent `UTC`.

- Mais `web1` (host_vars) l’emporte et reçoit `Africa/Tunis`.

## Astuces & pièges

- **host_vars** > **group_vars**.

- N’utilisez host_vars que pour les **exceptions réelles**.

---

# Exercice 18 — Mixer facts, set_fact et group_vars

## Contexte

On veut savoir si chaque machine a assez de RAM par rapport au minimum demandé par le groupe.

## Objectif

Écrire `/tmp/ram_check.txt` avec `mem`, `min`, `ok`.

## Où ?

`group_vars/app.yml`

```yaml
min_ram_mb: 1024
```

## Playbook principal — `ex18_mix.yml`

```yaml
---
- name: Mix facts + group_vars + set_fact
  hosts: app
  gather_facts: true
  tasks:
    - name: Compute RAM check
      set_fact:
        ram_ok: "{{ (ansible_facts.memtotal_mb | int) >= (min_ram_mb | int) }}"

    - name: Save RAM info
      copy:
        dest: /tmp/ram_check.txt
        content: "mem={{ ansible_facts.memtotal_mb }}MB, min={{ min_ram_mb }}, ok={{ ram_ok }}"
```

## Cleanup — `ex18_cleanup.yml`

```yaml
---
- name: Cleanup ex18
  hosts: app
  tasks:
    - file:
        path: /tmp/ram_check.txt
        state: absent
```

## Astuces & pièges

- Très utile de **composer des drapeaux** (`ram_ok`) avec `set_fact`.

---

# Exercice 19 — Rôle defaults surchargé par vars_files

## Contexte

Un rôle définit des `replicas: 1`, mais vous voulez surcharger depuis un fichier YAML.

## Objectif

Écrire `/tmp/replicas.txt` avec la valeur surchargée.

## Où ?

`roles/app/defaults/main.yml`

```yaml
replicas: 1
```

`vars/scale.yml`

```yaml
replicas: 3
```

## Playbook principal — `ex19_role_defaults_override.yml`

```yaml
---
- name: Override role defaults with vars_files
  hosts: app
  vars_files:
    - vars/scale.yml    # surcharge la valeur par défaut
  roles:
    - role: app
  tasks:
    - name: Save replicas
      copy:
        dest: /tmp/replicas.txt
        content: "replicas={{ replicas }}"
```

## Cleanup — `ex19_cleanup.yml`

```yaml
---
- name: Cleanup ex19
  hosts: app
  tasks:
    - file:
        path: /tmp/replicas.txt
        state: absent
```

## Astuces & pièges

- Préférez cette méthode structurée → `defaults` (base) + `vars_files` (override).

---

# Exercice 20 — Chaîne complète : env + rôle + -e

## Contexte

Un déploiement doit varier selon :

- l’environnement (`group_vars/dev.yml` ou `prod.yml`)

- les defaults du rôle

- une surcharge ponctuelle en `-e`

## Objectif

Écrire `/tmp/deploy_info.txt` avec toutes ces infos.

## Où ?

`group_vars/dev.yml`

```yaml
app_env: dev
image_tag: "dev-1.0"
```

`group_vars/prod.yml`

```yaml
app_env: prod
image_tag: "2025-09-30"
```

`roles/deploy/defaults/main.yml`

```yaml
replicas: 2
```

## Playbook principal — `ex20_flexible_pipeline.yml`

```yaml
---
- name: Flexible deployment chain
  hosts: "{{ target_env }}"   # choisi avec -e target_env=dev/prod
  roles:
    - role: deploy
  vars:
    service_name: "myapp"     # défini directement dans le play
  tasks:
    - name: Save deploy info
      copy:
        dest: /tmp/deploy_info.txt
        content: |
          env={{ app_env }}
          image_tag={{ image_tag }}
          replicas={{ replicas }}
          service={{ service_name }}
```

## Commandes

```bash
ansible-playbook ex20_flexible_pipeline.yml -e "target_env=dev"
ansible-playbook ex20_flexible_pipeline.yml -e "target_env=prod replicas=5"
```

## Cleanup — `ex20_cleanup.yml`

```yaml
---
- name: Cleanup ex20
  hosts: "dev:prod"
  tasks:
    - file:
        path: /tmp/deploy_info.txt
        state: absent
```

## Astuces & pièges

- Combinez intelligemment **group_vars** (contextes), **defaults** (base), et `-e` (surcharge ponctuelle).

- C’est la recette pour des **playbooks flexibles et réutilisables**.
