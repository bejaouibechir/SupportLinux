# Atelier — Orchestration Docker avec Ansible (install • compose up • compose down • rôle global)

## 1) Contexte & objectif

Mettre en place une **chaîne de déploiement simple** avec Ansible autour de Docker :

1. **Vérifier/installer Docker** si absent

2. **Lancer** un projet via `docker compose up -d --build`

3. **Détruire** les conteneurs via `docker compose down`

4. **Orchestrer** ces étapes avec un **playbook principal**

5. **Factoriser** en **rôle** réutilisable

> Hypothèses : cibles **Debian/Ubuntu** (APT), `docker compose` disponible comme **sous-commande** (`docker compose …`).  
> Variables clés (modifiables) : `project_dir` (répertoire du projet) et `compose_file` (nom du fichier compose).

---

## 2) Préparation de l’environnement

- Une **machine de contrôle** avec Ansible (`ansible`, `openssh-client`).

- Des **hôtes cibles** accessibles en SSH (avec sudo).

- Un **projet Docker Compose** déjà présent sur les cibles **ou** copié au préalable dans `{{ project_dir }}` (par ex. `/opt/projet`).

---

## 3) Fichiers — 4 playbooks commentés

Créer le fichier **inventory/hosts.ini** :

```ini
[targets]
srv1 ansible_host=IP_OU_DNS ansible_user=deploy
```

Créer le fichier **group_vars/targets.yml** :

```yaml
# Répertoire du projet Docker Compose sur la machine cible
project_dir: "/opt/projet"

# Nom du fichier docker compose (dans project_dir)
compose_file: "docker-compose.yml"
```

Créer le fichier **playbooks/01-docker-install.yml** :

```yaml
---
# Playbook 1 : Vérifie si Docker est installé ; installe et démarre si absent
- name: Ensure Docker is present and running
  hosts: targets
  become: true
  gather_facts: true

  tasks:
    - name: Check if docker cli is available
      # On teste la présence de la commande 'docker' sans échouer le play
      command: docker --version
      register: docker_check
      changed_when: false
      failed_when: false

    - name: Install prerequisites (APT index + deps)
      # Prépare l'installation sur Debian/Ubuntu
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
        state: present
        update_cache: true
      when: docker_check.rc != 0

    - name: Install docker using distro package (simple path)
      # Chemin simple: installe le paquet docker.io depuis la distribution
      apt:
        name: docker.io
        state: present
        update_cache: true
      when: docker_check.rc != 0

    - name: Ensure docker service is enabled and running
      # S'assure que le service Docker démarre et reste actif
      service:
        name: docker
        state: started
        enabled: true

    - name: Check docker compose subcommand availability
      # Vérifie que 'docker compose' fonctionne (plugin intégré)
      command: docker compose version
      register: compose_check
      changed_when: false
      failed_when: false

    - name: Install docker compose plugin if missing (Debian/Ubuntu)
      # Fallback minimal : paquet docker-compose-plugin (pour 'docker compose')
      apt:
        name: docker-compose-plugin
        state: present
        update_cache: true
      when: compose_check.rc != 0

    - name: Final check — report versions
      # Affiche les versions pour vérification
      shell: |
        set -e
        docker --version
        docker compose version
      register: versions
      changed_when: false

    - name: Show versions
      debug:
        var: versions.stdout_lines
```

Créer le fichier **playbooks/02-compose-up.yml** :

```yaml
---
# Playbook 2 : Lance "docker compose up -d --build" dans project_dir
- name: Docker Compose Up (build & start)
  hosts: targets
  become: true
  vars:
    project_dir: "{{ project_dir | default('/opt/projet') }}"
    compose_file: "{{ compose_file | default('docker-compose.yml') }}"

  tasks:
    - name: Verify project_dir exists
      # On vérifie la présence du répertoire projet
      stat:
        path: "{{ project_dir }}"
      register: p

    - name: Fail early if project_dir is missing
      # Erreur claire si le répertoire n'existe pas
      fail:
        msg: "Le répertoire {{ project_dir }} n'existe pas sur la cible."
      when: not p.stat.exists

    - name: Verify compose file exists
      # On vérifie le fichier compose
      stat:
        path: "{{ project_dir }}/{{ compose_file }}"
      register: cf

    - name: Fail early if compose file is missing
      fail:
        msg: "Le fichier {{ project_dir }}/{{ compose_file }} est introuvable."
      when: not cf.stat.exists

    - name: docker compose up -d --build
      # Démarre/Met à jour les conteneurs en mode détaché
      command: docker compose -f "{{ compose_file }}" up -d --build
      args:
        chdir: "{{ project_dir }}"

    - name: Show running containers
      # Affiche l'état des conteneurs
      command: docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'
      register: ps
      changed_when: false

    - name: Print docker ps
      debug:
        var: ps.stdout_lines
```

Créer le fichier **playbooks/03-compose-down.yml** :

```yaml
---
# Playbook 3 : Exécute "docker compose down" pour détruire les conteneurs
- name: Docker Compose Down (stop & remove)
  hosts: targets
  become: true
  vars:
    project_dir: "{{ project_dir | default('/opt/projet') }}"
    compose_file: "{{ compose_file | default('docker-compose.yml') }}"

  tasks:
    - name: Verify project_dir exists
      stat:
        path: "{{ project_dir }}"
      register: p

    - name: Skip if project_dir missing (nothing to stop)
      debug:
        msg: "Aucun down : {{ project_dir }} absent."
      when: not p.stat.exists

    - name: docker compose down
      # Arrête et supprime conteneurs/réseaux (du projet)
      command: docker compose -f "{{ compose_file }}" down
      args:
        chdir: "{{ project_dir }}"
      when: p.stat.exists
```

Créer le fichier **playbooks/00-site.yml** (playbook principal « orchestrateur ») :

```yaml
---
# Playbook 4 : Orchestration des 3 précédents
# Exécution typique :
#   ansible-playbook -i inventory/hosts.ini playbooks/00-site.yml
# Possibles tags :
#   -e "run_step=install|up|down" pour cibler une phase

- name: Orchestrate Docker lifecycle
  hosts: targets
  gather_facts: false

  vars:
    run_step: "all"   # all|install|up|down

  tasks:
    - name: Include Docker install
      import_playbook: "01-docker-install.yml"
      when: run_step in ['all','install']

    - name: Include Compose Up
      import_playbook: "02-compose-up.yml"
      when: run_step in ['all','up']

    - name: Include Compose Down
      import_playbook: "03-compose-down.yml"
      when: run_step in ['down']
```

### Exécution type

```bash
# Installation Docker + Up + (pas de Down)
ansible-playbook -i inventory/hosts.ini playbooks/00-site.yml

# Seulement l'installation
ansible-playbook -i inventory/hosts.ini playbooks/00-site.yml -e "run_step=install"

# Seulement le Up
ansible-playbook -i inventory/hosts.ini playbooks/00-site.yml -e "run_step=up"

# Seulement le Down
ansible-playbook -i inventory/hosts.ini playbooks/00-site.yml -e "run_step=down"
```

---

## 4) Conversion en **rôle global** réutilisable

### 4.1. Arborescence du rôle

```
roles/
└── docker_orchestrator/
    ├── defaults/
    │   └── main.yml
    ├── tasks/
    │   ├── install_docker.yml
    │   ├── compose_up.yml
    │   ├── compose_down.yml
    │   └── main.yml
    └── README.md  (optionnel)
```

Créer le fichier **roles/docker_orchestrator/defaults/main.yml** :

```yaml
# Variables par défaut du rôle
project_dir: "/opt/projet"
compose_file: "docker-compose.yml"

# Phase à exécuter : all|install|up|down
docker_orchestrator_run_step: "all"
```

Créer le fichier **roles/docker_orchestrator/tasks/install_docker.yml** :

```yaml
---
# Tâches d'installation/activation de Docker
- name: Check if docker cli is available
  command: docker --version
  register: docker_check
  changed_when: false
  failed_when: false

- name: Install prerequisites (APT index + deps)
  apt:
    name:
      - apt-transport-https
      - ca-certificates
      - curl
      - gnupg
      - lsb-release
    state: present
    update_cache: true
  when: docker_check.rc != 0

- name: Install docker (distro package)
  apt:
    name: docker.io
    state: present
    update_cache: true
  when: docker_check.rc != 0

- name: Ensure docker service is enabled and running
  service:
    name: docker
    state: started
    enabled: true

- name: Check docker compose subcommand availability
  command: docker compose version
  register: compose_check
  changed_when: false
  failed_when: false

- name: Install docker compose plugin if missing
  apt:
    name: docker-compose-plugin
    state: present
    update_cache: true
  when: compose_check.rc != 0
```

Créer le fichier **roles/docker_orchestrator/tasks/compose_up.yml** :

```yaml
---
# Tâches pour "docker compose up -d --build"
- name: Verify project_dir exists
  stat:
    path: "{{ project_dir }}"
  register: p

- name: Fail early if project_dir missing
  fail:
    msg: "Le répertoire {{ project_dir }} n'existe pas sur la cible."
  when: not p.stat.exists

- name: Verify compose file exists
  stat:
    path: "{{ project_dir }}/{{ compose_file }}"
  register: cf

- name: Fail early if compose file missing
  fail:
    msg: "Le fichier {{ project_dir }}/{{ compose_file }} est introuvable."
  when: not cf.stat.exists

- name: docker compose up -d --build
  command: docker compose -f "{{ compose_file }}" up -d --build
  args:
    chdir: "{{ project_dir }}"

- name: Show running containers
  command: docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'
  register: ps
  changed_when: false

- name: Print docker ps
  debug:
    var: ps.stdout_lines
```

Créer le fichier **roles/docker_orchestrator/tasks/compose_down.yml** :

```yaml
---
# Tâches pour "docker compose down"
- name: Verify project_dir exists
  stat:
    path: "{{ project_dir }}"
  register: p

- name: docker compose down (skip if missing)
  command: docker compose -f "{{ compose_file }}" down
  args:
    chdir: "{{ project_dir }}"
  when: p.stat.exists
```

Créer le fichier **roles/docker_orchestrator/tasks/main.yml** :

```yaml
---
# Point d'entrée du rôle : route selon docker_orchestrator_run_step
- name: Run install only
  include_tasks: install_docker.yml
  when: docker_orchestrator_run_step in ['all','install']

- name: Run compose up
  include_tasks: compose_up.yml
  when: docker_orchestrator_run_step in ['all','up']

- name: Run compose down
  include_tasks: compose_down.yml
  when: docker_orchestrator_run_step in ['down']
```

Créer le fichier **playbooks/site-role.yml** (utilisation du rôle) :

```yaml
---
# Exemple d'utilisation du rôle global
- name: Orchestrate Docker with role
  hosts: targets
  become: true

  vars:
    # Surcharges possibles à l'exécution :
    # -e "docker_orchestrator_run_step=install"
    # -e "docker_orchestrator_run_step=up"
    # -e "docker_orchestrator_run_step=down"
    docker_orchestrator_run_step: "all"
    project_dir: "/opt/projet"
    compose_file: "docker-compose.yml"

  roles:
    - role: docker_orchestrator
```

### Exemples d’exécution (rôle)

```bash
# Tout (install + up)
ansible-playbook -i inventory/hosts.ini playbooks/site-role.yml

# Uniquement install
ansible-playbook -i inventory/hosts.ini playbooks/site-role.yml -e "docker_orchestrator_run_step=install"

# Uniquement up
ansible-playbook -i inventory/hosts.ini playbooks/site-role.yml -e "docker_orchestrator_run_step=up"

# Down
ansible-playbook -i inventory/hosts.ini playbooks/site-role.yml -e "docker_orchestrator_run_step=down"
```

---

## 5) Vérifications & Résultats attendus

- `docker --version` et `docker compose version` **affichent des versions** valides.

- `docker ps` **liste** vos conteneurs après le **up**.

- `docker compose down` **retire** les conteneurs/réseaux du projet.

---

## 6) Nettoyage / Rollback

- Arrêt et suppression des conteneurs :

```bash
ansible-playbook -i inventory/hosts.ini playbooks/03-compose-down.yml
```

- (Optionnel) Suppression du répertoire projet sur la cible si c’était un test :

```bash
ansible -i inventory/hosts.ini targets -b -m file -a "path=/opt/projet state=absent"
```

---

## 7) Conseils & pièges

- **Droits** : l’utilisateur Ansible doit avoir **sudo**.

- **Compose v1 vs v2** : ce guide utilise `docker compose` (v2). Si vous n’avez que `docker-compose` binaire, adaptez la commande.

- **Project dir** : assurez-vous que `{{ project_dir }}` contient bien your `{{ compose_file }}` et tous les artefacts requis (env, Dockerfile, etc.).

- **Multi-OS** : pour RHEL/CentOS/AlmaLinux, remplacez l’installation APT par `dnf/yum` et le paquet `docker-ce` si nécessaire.

Souhaitez-vous une **variante multi-distribution** (Debian/Ubuntu + RHEL-like), ou l’intégration d’un **pull d’images** privé (auth `docker login`) avant le `compose up` ?
