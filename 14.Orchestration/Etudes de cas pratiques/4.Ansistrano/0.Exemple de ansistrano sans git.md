# Atelier complet — Déploiement & **versioning (v1 → v2 → v3)** d’une appli **Flask** avec **Ansistrano**, **sans Git** (via **rsync**) + **rollback**

## 1) Contexte & objectif

Mettre en place un **déploiement versionné** d’une application **Flask** simple **sans utiliser Git**.  
Nous utiliserons **Ansistrano** en mode **`rsync`** pour pousser le **contenu local** d’un dossier source vers le serveur, avec la structure **`releases/`**, **`current/`**, **`shared/`** et la capacité de **rollback** immédiat.

Objectifs pédagogiques :

- Déployer **v1**, **v2**, **v3** d’une même appli Flask **en switchant la source rsync**.

- Automatiser l’installation (venv + pip) et le (re)démarrage d’un service **systemd + gunicorn** via les **hooks Ansistrano**.

- **Revenir en arrière** en une commande avec `ansistrano.rollback`.

---

## 2) Préparation de l’environnement

### 2.1. Côté machine **de déploiement** (votre poste Ansible)

- OS Linux (Debian/Ubuntu ou équivalent) avec `ansible`, `ssh`, `rsync`, `python3`, `python3-venv` installés.

- Installation des rôles Ansistrano :

```bash
ansible-galaxy install ansistrano.deploy ansistrano.rollback
```

### 2.2. Côté **serveur cible** (VM “web”)

- Un utilisateur SSH (ex. `deploy`) avec `sudo`.

- Paquets requis : `python3`, `python3-venv`, `rsync`, `systemd` (natif sur Debian/Ubuntu).

- Firewall : ouvrir le port **8000** (si nécessaire).

> Nous supposerons l’hôte cible `web1` joignable via SSH.

---

## 3) Exécution pas à pas (avec explications)

### 3.1. Arborescence de travail

```bash
mkdir -p ansistrano-flask-rsync/{inventory,group_vars,playbooks,my-hooks,service,app-src}
mkdir -p ansistrano-flask-rsync/app-src/{v1,v2,v3}
```

### 3.2. Préparer **l’application Flask** (v1, v2, v3) — **sans Git**

Créer le fichier **ansistrano-flask-rsync/app-src/v1/app.py** :

```bash
# app.py (v1) — application Flask minimale + endpoint /version
# But : fournir un contenu de test pour déploiement rsync via Ansistrano.

from flask import Flask, jsonify
app = Flask(__name__)

@app.get("/")
def home():
    # Message visible pour vérifier la version en prod
    return "Hello from Flask demo v1!"

@app.get("/version")
def version():
    # API simple pour vérifier la version déployée
    return jsonify({"version": "v1"})

if __name__ == "__main__":
    # Exécution locale éventuelle (en prod on utilisera systemd + gunicorn)
    app.run(host="0.0.0.0", port=8000)
```

Créer le fichier **ansistrano-flask-rsync/app-src/v1/requirements.txt** :

```bash
# Dépendances Python de l'app
Flask==3.0.3
gunicorn==22.0.0
```

Créer le fichier **ansistrano-flask-rsync/app-src/v2/app.py** :

```bash
# app.py (v2) — même logique, message et version mis à jour

from flask import Flask, jsonify
app = Flask(__name__)

@app.get("/")
def home():
    return "Hello from Flask demo v2!"

@app.get("/version")
def version():
    return jsonify({"version": "v2"})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)
```

Créer le fichier **ansistrano-flask-rsync/app-src/v2/requirements.txt** :

```bash
Flask==3.0.3
gunicorn==22.0.0
```

Créer le fichier **ansistrano-flask-rsync/app-src/v3/app.py** :

```bash
# app.py (v3) — nouvelle itération avec petit changement de texte

from flask import Flask, jsonify
app = Flask(__name__)

@app.get("/")
def home():
    return "Hello from Flask demo v3 (rsync edition)!"

@app.get("/version")
def version():
    return jsonify({"version": "v3"})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)
```

Créer le fichier **ansistrano-flask-rsync/app-src/v3/requirements.txt** :

```bash
Flask==3.0.3
gunicorn==22.0.0
```

> Chaque sous-dossier `v1/`, `v2/`, `v3/` est **une “source” distincte**. On choisira la version à déployer en pointant **rsync** vers l’un de ces dossiers.

---

### 3.3. Inventaire Ansible

Créer le fichier **ansistrano-flask-rsync/inventory/hosts.ini** :

```bash
[web]
web1 ansible_host=VOTRE_IP ansible_user=deploy
```

> `ansible_user=deploy` est l’utilisateur SSH. Adaptez `VOTRE_IP`.

---

### 3.4. Variables communes (mode rsync, chemin source, hooks)

Créer le fichier **ansistrano-flask-rsync/group_vars/web.yml** :

```bash
# Dossier “racine” du déploiement sur le serveur
ansistrano_deploy_to: "/opt/flask-demo"
# Nombre de releases à conserver
ansistrano_keep_releases: 5

# On déploie via rsync (sans Git)
ansistrano_deploy_via: "rsync"

# Version applicative à déployer (correspond au sous-dossier local dans app-src/)
# On pourra surcharger à l'exécution: -e "app_src_version=v2"
app_src_version: "v1"

# Chemin source côté machine Ansible (local) — on synchronise ce dossier
# vers la release en cours de création sur le serveur.
ansistrano_rsync_src: "{{ playbook_dir }}/../app-src/{{ app_src_version }}/"

# Options rsync (conservatrices + rapides)
ansistrano_rsync_extra_params: "--archive --delete --compress --human-readable"

# Répertoires/chemins partagés entre releases (ici le venv Python persistant)
ansistrano_shared_paths:
  - "venv"

# Hook post-symlink: (re)démarre service + installe deps dans le venv
ansistrano_after_symlink_tasks_file: "{{ playbook_dir }}/../my-hooks/after-symlink.yml"
```

> Explications :
> 
> - `ansistrano_deploy_via: rsync` → Ansistrano copie **depuis le poste** Ansible.
> 
> - `ansistrano_rsync_src` pointe **dynamiquement** sur `app-src/{{ app_src_version }}/`.
> 
> - On gère la **version** à déployer en appelant le playbook avec `-e "app_src_version=v2"` ou `v3`.

---

### 3.5. Playbook de **déploiement** (rsync)

Créer le fichier **ansistrano-flask-rsync/playbooks/deploy.yml** :

```bash
# Playbook de déploiement via Ansistrano (mode rsync)
# Étapes clés:
#  1) Préparer les paquets
#  2) Créer le dossier de base /opt/flask-demo
#  3) Appeler ansistrano.deploy (crée release, rsync depuis src local, bascule "current", puis hooks)

- name: Deploy Flask demo via rsync (no Git)
  hosts: web
  become: yes

  pre_tasks:
    - name: Install OS packages needed for Python app and rsync
      # Installe Python, venv, rsync (utile au rôle) et met à jour l'index
      apt:
        name:
          - python3
          - python3-venv
          - rsync
        state: present
        update_cache: yes

    - name: Create base deployment directory
      # Assure l'existence du répertoire de base
      file:
        path: "{{ ansistrano_deploy_to }}"
        state: directory
        owner: "{{ ansible_user | default('deploy') }}"
        group: "{{ ansible_user | default('deploy') }}"
        mode: "0755"

  roles:
    - role: ansistrano.deploy
      # Le rôle va:
      # - créer une nouvelle release dans releases/
      # - rsync depuis ansistrano_rsync_src vers la nouvelle release
      # - basculer le lien "current" sur cette release
      # - exécuter les hooks (after-symlink etc.)
```

---

### 3.6. Hook **after-symlink** : venv + deps + service systemd

Créer le fichier **ansistrano-flask-rsync/my-hooks/after-symlink.yml** :

```bash
# Ce hook s'exécute après la bascule du lien "current" vers la nouvelle release.
# Objectif :
#  1) Créer (si besoin) un venv Python dans "shared/venv"
#  2) Installer les dépendances de la release active
#  3) (Ré)installer l'unité systemd et redémarrer le service

- name: Ensure shared venv directory exists
  file:
    path: "{{ ansistrano_shared_path }}/venv"
    state: directory

- name: Create virtualenv if missing
  # Crée le venv une seule fois (persistant entre releases)
  command: "python3 -m venv {{ ansistrano_shared_path }}/venv"
  args:
    creates: "{{ ansistrano_shared_path }}/venv/bin/activate"

- name: Install requirements inside venv
  # Installe/Met à jour les deps de la release active dans le venv partagé
  command: >
    {{ ansistrano_shared_path }}/venv/bin/pip install -r {{ ansistrano_release_path }}/requirements.txt

- name: Install/Refresh systemd unit for gunicorn
  # Déploie ou met à jour l'unité systemd (service Flask)
  template:
    src: "{{ playbook_dir }}/../service/flask-demo.service.j2"
    dest: /etc/systemd/system/flask-demo.service
    mode: "0644"

- name: Reload systemd daemon
  command: systemctl daemon-reload

- name: Enable and restart service
  # Active au boot + redémarre le service sur la release "current"
  service:
    name: flask-demo
    state: restarted
    enabled: true
```

> Remarque : ici nous utilisons `{{ ansistrano_release_path }}` (variabile fournie par le rôle) sans `.stdout`.

---

### 3.7. Unité **systemd** (gunicorn → app:app)

Créer le fichier **ansistrano-flask-rsync/service/flask-demo.service.j2** :

```bash
# Service systemd pour lancer l'application Flask via gunicorn
# On s'appuie sur:
#  - venv persistant dans {{ ansistrano_shared_path }}/venv
#  - code en cours dans {{ ansistrano_deploy_to }}/current

[Unit]
Description=Flask demo served by gunicorn (rsync/ansistrano)
After=network.target

[Service]
# Utilise le venv partagé
Environment="PATH={{ ansistrano_shared_path }}/venv/bin"
# Répertoire actif: la release pointée par "current"
WorkingDirectory={{ ansistrano_deploy_to }}/current
# Démarre gunicorn en exposant app:app (défini dans app.py)
ExecStart={{ ansistrano_shared_path }}/venv/bin/gunicorn -w 2 -b 0.0.0.0:8000 app:app
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
```

---

## 4) Vérifications / Résultats attendus

### 4.1. Déploiement **v1**

```bash
cd ansistrano-flask-rsync
ansible-playbook -i inventory/hosts.ini playbooks/deploy.yml -e "app_src_version=v1"
```

Vérifications :

```bash
# Côté serveur
ls -l /opt/flask-demo
# Attendu: dossiers releases/, shared/ et lien current -> releases/<timestamp>

systemctl status flask-demo
# Attendu: service "active (running)"

ss -lntp | grep 8000
# Attendu: gunicorn à l'écoute sur 0.0.0.0:8000

# Depuis votre poste (ou sur le serveur)
curl http://VOTRE_IP:8000/
# -> Hello from Flask demo v1!
curl http://VOTRE_IP:8000/version
# -> {"version":"v1"}
```

### 4.2. Déployer **v2** puis **v3**

```bash
# v2
ansible-playbook -i inventory/hosts.ini playbooks/deploy.yml -e "app_src_version=v2"
curl http://VOTRE_IP:8000/        # -> Hello from Flask demo v2!
curl http://VOTRE_IP:8000/version # -> {"version":"v2"}

# v3
ansible-playbook -i inventory/hosts.ini playbooks/deploy.yml -e "app_src_version=v3"
curl http://VOTRE_IP:8000/        # -> Hello from Flask demo v3 (rsync edition)!
curl http://VOTRE_IP:8000/version # -> {"version":"v3"}
```

---

## 5) **Rollback** (retour en arrière) sans Git

Le rôle `ansistrano.rollback` **rebascule le lien `current`** vers la **release précédente** (ou vers un **timestamp ciblé**).

Créer le fichier **ansistrano-flask-rsync/playbooks/rollback.yml** :

```bash
# Playbook de rollback — sans Git (le mécanisme est le même)
# Il suffit d'indiquer ansistrano_deploy_to et, si souhaité, une release précise.

- name: Rollback Flask demo
  hosts: web
  become: yes

  vars:
    ansistrano_deploy_to: "/opt/flask-demo"
    # Optionnel: cibler une release précise (répertoire dans releases/)
    # ansistrano_rollback_to_release: "20251022093015"

  roles:
    - role: ansistrano.rollback
```

Utilisation :

```bash
# Rollback à la release précédente
ansible-playbook -i inventory/hosts.ini playbooks/rollback.yml

# Vérifier
curl http://VOTRE_IP:8000/version
# -> repasse de v3 à v2 (ou v1 selon l'historique)

# Rollback ciblé (après listing des timestamps disponibles)
ls -1 /opt/flask-demo/releases/
ansible-playbook -i inventory/hosts.ini playbooks/rollback.yml -e "ansistrano_rollback_to_release=TIMESTAMP"
```

---

## 6) Nettoyage / Rollback d’atelier

```bash
# Stop + disable service
sudo systemctl disable --now flask-demo

# Supprimer l'arborescence de déploiement
sudo rm -rf /opt/flask-demo
```

Optionnel (si VM dédiée à l’atelier) :

```bash
sudo apt remove -y rsync python3-venv && sudo apt autoremove -y
```

---

## 7) Conseils & pièges

- **Choix du mode** : `rsync` est idéal pour **pousser un build local** sans Git. Pour des équipes, Git reste pratique, mais ici on prouve que Git **n’est pas requis**.

- **Performances rsync** : `--archive --delete --compress` est un bon point de départ. Évitez de synchroniser des **gros dossiers inutiles** (node_modules, .venv local, etc.).

- **Shared venv** : conservez le venv dans `shared/venv` pour éviter un recréation totale à chaque release (gain de temps).

- **Hooks** : placez vos migrations DB, purge de cache, warm-up dans un hook `after-symlink` ou `before/after-update-code` selon le cas.

- **Rollback** : ne “supprime” pas forcément la release (selon options). Servez-vous du rollback pour revenir vite à un état stable, puis **inspectez** la release fautive.

---

# Récapitulatif des fichiers à créer (tous **commentés / explicites**)

Créer le fichier **ansistrano-flask-rsync/inventory/hosts.ini** :

```bash
[web]
web1 ansible_host=VOTRE_IP ansible_user=deploy
```

Créer le fichier **ansistrano-flask-rsync/group_vars/web.yml** :

```bash
ansistrano_deploy_to: "/opt/flask-demo"
ansistrano_keep_releases: 5
ansistrano_deploy_via: "rsync"

# Version source à déployer (v1, v2, v3)
app_src_version: "v1"

# Dossier source local à synchroniser
ansistrano_rsync_src: "{{ playbook_dir }}/../app-src/{{ app_src_version }}/"
ansistrano_rsync_extra_params: "--archive --delete --compress --human-readable"

# Chemins partagés (persistants entre releases)
ansistrano_shared_paths:
  - "venv"

# Hook post-symlink: venv + deps + service
ansistrano_after_symlink_tasks_file: "{{ playbook_dir }}/../my-hooks/after-symlink.yml"
```

Créer le fichier **ansistrano-flask-rsync/playbooks/deploy.yml** :

```bash
- name: Deploy Flask demo via rsync (no Git)
  hosts: web
  become: yes

  pre_tasks:
    - name: Install OS packages needed for Python app and rsync
      apt:
        name:
          - python3
          - python3-venv
          - rsync
        state: present
        update_cache: yes

    - name: Create base deployment directory
      file:
        path: "{{ ansistrano_deploy_to }}"
        state: directory
        owner: "{{ ansible_user | default('deploy') }}"
        group: "{{ ansible_user | default('deploy') }}"
        mode: "0755"

  roles:
    - role: ansistrano.deploy
```

Créer le fichier **ansistrano-flask-rsync/my-hooks/after-symlink.yml** :

```bash
- name: Ensure shared venv directory exists
  file:
    path: "{{ ansistrano_shared_path }}/venv"
    state: directory

- name: Create virtualenv if missing
  command: "python3 -m venv {{ ansistrano_shared_path }}/venv"
  args:
    creates: "{{ ansistrano_shared_path }}/venv/bin/activate"

- name: Install requirements inside venv
  command: >
    {{ ansistrano_shared_path }}/venv/bin/pip install -r {{ ansistrano_release_path }}/requirements.txt

- name: Install/Refresh systemd unit for gunicorn
  template:
    src: "{{ playbook_dir }}/../service/flask-demo.service.j2"
    dest: /etc/systemd/system/flask-demo.service
    mode: "0644"

- name: Reload systemd daemon
  command: systemctl daemon-reload

- name: Enable and restart service
  service:
    name: flask-demo
    state: restarted
    enabled: true
```

Créer le fichier **ansistrano-flask-rsync/service/flask-demo.service.j2** :

```bash
[Unit]
Description=Flask demo served by gunicorn (rsync/ansistrano)
After=network.target

[Service]
Environment="PATH={{ ansistrano_shared_path }}/venv/bin"
WorkingDirectory={{ ansistrano_deploy_to }}/current
ExecStart={{ ansistrano_shared_path }}/venv/bin/gunicorn -w 2 -b 0.0.0.0:8000 app:app
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
```

Créer le fichier **ansistrano-flask-rsync/playbooks/rollback.yml** :

```bash
- name: Rollback Flask demo
  hosts: web
  become: yes

  vars:
    ansistrano_deploy_to: "/opt/flask-demo"
    # ansistrano_rollback_to_release: "TIMESTAMP_OPTIONNEL"

  roles:
    - role: ansistrano.rollback
```

Créer le fichier **ansistrano-flask-rsync/app-src/v1/app.py** :

```bash
from flask import Flask, jsonify
app = Flask(__name__)

@app.get("/")
def home():
    return "Hello from Flask demo v1!"

@app.get("/version")
def version():
    return jsonify({"version": "v1"})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)
```

Créer le fichier **ansistrano-flask-rsync/app-src/v1/requirements.txt** :

```bash
Flask==3.0.3
gunicorn==22.0.0
```

Créer le fichier **ansistrano-flask-rsync/app-src/v2/app.py** :

```bash
from flask import Flask, jsonify
app = Flask(__name__)

@app.get("/")
def home():
    return "Hello from Flask demo v2!"

@app.get("/version")
def version():
    return jsonify({"version": "v2"})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)
```

Créer le fichier **ansistrano-flask-rsync/app-src/v2/requirements.txt** :

```bash
Flask==3.0.3
gunicorn==22.0.0
```

Créer le fichier **ansistrano-flask-rsync/app-src/v3/app.py** :

```bash
from flask import Flask, jsonify
app = Flask(__name__)

@app.get("/")
def home():
    return "Hello from Flask demo v3 (rsync edition)!"

@app.get("/version")
def version():
    return jsonify({"version": "v3"})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)
```

Créer le fichier **ansistrano-flask-rsync/app-src/v3/requirements.txt** :

```bash
Flask==3.0.3
gunicorn==22.0.0
```

---

## Exécution **résumée**

```bash
# Déployer v1
ansible-playbook -i inventory/hosts.ini playbooks/deploy.yml -e "app_src_version=v1"
curl http://VOTRE_IP:8000/version   # -> {"version":"v1"}

# Déployer v2
ansible-playbook -i inventory/hosts.ini playbooks/deploy.yml -e "app_src_version=v2"
curl http://VOTRE_IP:8000/version   # -> {"version":"v2"}

# Déployer v3
ansible-playbook -i inventory/hosts.ini playbooks/deploy.yml -e "app_src_version=v3"
curl http://VOTRE_IP:8000/version   # -> {"version":"v3"}

# Rollback (release précédente)
ansible-playbook -i inventory/hosts.ini playbooks/rollback.yml
curl http://VOTRE_IP:8000/version   # -> version précédente

# Rollback ciblé
ls -1 /opt/flask-demo/releases/
ansible-playbook -i inventory/hosts.ini playbooks/rollback.yml -e "ansistrano_rollback_to_release=TIMESTAMP"
```


