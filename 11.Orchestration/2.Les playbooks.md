# Les playbooks ansible

# Exercice 1 — **Options de base : -i, -u, -k, -b**

**But :** comprendre l’usage d’une inventory différente, d’un user ssh (`-u`), demande de mot de passe SSH (`-k`) et élévation de privilèges (`-b`) lors de l’exécution d’un playbook.

### Contexte

Créer un utilisateur système `audituser` sur les hôtes du groupe `app`, puis le supprimer.

### Playbook principal (`create_user.yml`)

```yaml
---
- name: Create audit user on app hosts
  hosts: app
  become: true
  tasks:
    - name: Ensure audituser exists
      user:
        name: audituser
        shell: /bin/bash
        state: present
        create_home: yes
```

### Playbook cleanup (`cleanup_user.yml`)

```yaml
---
- name: Remove audit user on app hosts
  hosts: app
  become: true
  tasks:
    - name: Remove audituser and home
      user:
        name: audituser
        state: absent
        remove: yes
```

### Commandes à tester

- Exécution classique avec inventory et user :

```bash
ansible-playbook -i inventory.ini -u deployer -b create_user.yml
```

- Si SSH demande un mot de passe (pas de clé) :

```bash
ansible-playbook -i inventory.ini -u deployer -k -b create_user.yml
```

### Vérification

```bash
ansible app -i inventory.ini -m command -a "id audituser" -u deployer -b
```

### Débogage et conseils

- `-u` : précise l’utilisateur SSH. Utile si le contrôleur n’utilise pas la même identité.

- `-k` : demande le mot de passe SSH interactif ; **éviter en CI**.

- `-b` ou `become: true` dans le playbook : élévation (sudo). **Mettre `become` dans le playbook** pour la reproductibilité.

- Si l’opération échoue : relancer avec `-vvv` pour voir la négociation SSH et l’erreur sudo.

---

# Exercice 2 — **Syntax check & list-tasks & list-hosts**

**But :** apprendre à valider syntaxe et lister tâches avant exécution.

### Contexte

On va déployer un fichier de configuration `/tmp/demo.conf`.

### Playbook principal (`deploy_conf.yml`)

```yaml
---
- name: Deploy demo conf
  hosts: all
  become: true
  tasks:
    - name: Create config file
      copy:
        dest: /tmp/demo.conf
        content: "demo=1\n"
        mode: "0644"
```

### Cleanup (`cleanup_conf.yml`)

```yaml
---
- name: Cleanup demo conf
  hosts: all
  become: true
  tasks:
    - name: Remove config file
      file:
        path: /tmp/demo.conf
        state: absent
```

### Commandes à tester

- Vérifier la syntaxe :

```bash
ansible-playbook --syntax-check -i inventory.ini deploy_conf.yml
```

- Lister les hôtes cibles :

```bash
ansible-playbook --list-hosts -i inventory.ini deploy_conf.yml
```

- Lister les tâches sans exécution :

```bash
ansible-playbook --list-tasks -i inventory.ini deploy_conf.yml
```

### Vérification

```bash
ansible all -i inventory.ini -m stat -a "path=/tmp/demo.conf"
```

### Débogage & conseils

- `--syntax-check` détecte erreurs YAML et structurelles. Toujours l’exécuter avant `--check`/prod.

- `--list-tasks` et `--list-hosts` aident à valider la portée du playbook avant de l’appliquer. Utile pour éviter les erreurs de targeting.

---

# Exercice 3 — **--check (dry-run) et --diff**

**But :** simuler les changements et visualiser les modifications attendues.

### Contexte

Modifier `/etc/motd` pour afficher un message de maintenance, mais d’abord simuler.

### Playbook principal (`motd.yml`)

```yaml
---
- name: Set maintenance motd
  hosts: web
  become: true
  tasks:
    - name: Update /etc/motd
      lineinfile:
        path: /etc/motd
        line: "MAINTENANCE WINDOW"
        create: yes
```

### Cleanup (`cleanup_motd.yml`)

```yaml
---
- name: Remove maintenance motd
  hosts: web
  become: true
  tasks:
    - name: Remove line from /etc/motd if present
      lineinfile:
        path: /etc/motd
        regexp: '^MAINTENANCE WINDOW$'
        state: absent
```

### Commandes à tester

- Simulation (dry-run) :

```bash
ansible-playbook -i inventory.ini --check --diff motd.yml
```

- Application réelle (avec diff) :

```bash
ansible-playbook -i inventory.ini --diff motd.yml
```

### Vérification

```bash
ansible web -i inventory.ini -m command -a "grep -n 'MAINTENANCE WINDOW' /etc/motd || true"
```

### Débogage & conseils

- `--check` indique `changed` potentiels **sans** modifier ; parfait avant une maintenance.

- `--diff` montre la différence, ligne par ligne. Très utile pour fichiers de config lourds.

- Attention : certains modules ne supportent pas complètement `--check` (ex : modules qui génèrent un résultat externe). En cas de doute, testez d’abord sur un hôte non productif.

---

# Exercice 4 — **-v / -vv / -vvv : verbosité pour diagnostiquer**

**But :** utiliser la verbosité pour tracer les échecs.

### Contexte

Installer un paquet et diagnostiquer une erreur d’installation.

### Playbook principal (`install_nginx.yml`)

```yaml
---
- name: Install nginx (example)
  hosts: web
  become: true
  tasks:
    - name: Ensure nginx is present
      apt:
        name: nginx
        state: present
        update_cache: yes
```

### Cleanup (`cleanup_nginx.yml`)

```yaml
---
- name: Remove nginx
  hosts: web
  become: true
  tasks:
    - name: Purge nginx package
      apt:
        name: nginx
        state: absent
        purge: yes
```

### Commandes à tester

- Exécution normale :

```bash
ansible-playbook -i inventory.ini install_nginx.yml
```

- Exécution avec trace détaillée :

```bash
ansible-playbook -i inventory.ini install_nginx.yml -vvv
```

### Vérification

```bash
ansible web -i inventory.ini -m command -a "nginx -v" || true
```

### Débogage & conseils

- `-vvv` affiche les échanges SSH, les variables passées et sorties des modules. Utile pour erreurs `permission denied`, timeouts, ou échecs d’installation.

- En cas d’erreur apt : vérifier les logs apt (`/var/log/apt/term.log`) via `ansible -m command`.

---

# Exercice 5 — **start-at-task & --step (reprendre / pas-à-pas)**

**But :** apprendre à reprendre un playbook au niveau d’une tâche spécifique et à exécuter pas à pas.

### Contexte

Playbook multi-tâches : créer répertoire, déployer fichier, redémarrer service.

### Playbook principal (`multi_task.yml`)

```yaml
---
- name: Multi-step demo
  hosts: all
  become: true
  tasks:
    - name: Create dir
      file:
        path: /tmp/demo_app
        state: directory
        mode: "0755"

    - name: Copy app file
      copy:
        dest: /tmp/demo_app/app.txt
        content: "app version 1"

    - name: Restart dummy service (simulate)
      command: /bin/true
```

### Cleanup (`cleanup_multi_task.yml`)

```yaml
---
- name: Cleanup demo app
  hosts: all
  become: true
  tasks:
    - name: Remove demo dir
      file:
        path: /tmp/demo_app
        state: absent
```

### Commandes à tester

- Reprendre à la tâche `Copy app file` :

```bash
ansible-playbook -i inventory.ini --start-at-task="Copy app file" multi_task.yml
```

- Exécuter en mode pas-à-pas (confirmez chaque tâche) :

```bash
ansible-playbook -i inventory.ini --step multi_task.yml
```

### Vérification

```bash
ansible all -i inventory.ini -m command -a "ls -l /tmp/demo_app || true"
```

### Débogage & conseils

- `--start-at-task` est pratique si un playbook a échoué après une longue série d’étapes — on ne recommence pas depuis le début.

- `--step` permet d’inspecter chaque tâche avant exécution — très pratique en formation, mais pénible en production.

---

# Exercice 6 — **--tags / --skip-tags / --list-tags**

**But :** exécuter une partie d’un playbook via tags.

### Contexte

Playbook avec tâches taggées : `setup`, `deploy`, `notify`.

### Playbook principal (`tagged_play.yml`)

```yaml
---
- name: Tagged play
  hosts: all
  become: true
  tasks:
    - name: System setup
      apt:
        name: git
        state: present
      tags: setup

    - name: Deploy sample file
      copy:
        dest: /tmp/tagged.txt
        content: "tagged"
      tags: deploy

    - name: Notify admin (simulate)
      debug:
        msg: "Notified"
      tags: notify
```

### Cleanup (`cleanup_tagged.yml`)

```yaml
---
- name: Cleanup tagged
  hosts: all
  become: true
  tasks:
    - name: Remove tagged file
      file:
        path: /tmp/tagged.txt
        state: absent
```

### Commandes à tester

- Lister les tags disponibles :

```bash
ansible-playbook -i inventory.ini --list-tags tagged_play.yml
```

- Exécuter uniquement la partie `deploy` :

```bash
ansible-playbook -i inventory.ini --tags deploy tagged_play.yml
```

- Exécuter tout sauf `notify` :

```bash
ansible-playbook -i inventory.ini --skip-tags notify tagged_play.yml
```

### Vérification

```bash
ansible all -i inventory.ini -m command -a "test -f /tmp/tagged.txt && echo ok || echo missing"
```

### Débogage & conseils

- Tags = excellent pour séparer `setup` (pré-requis) et `deploy` (action).

- `--list-tags` vous montre la carte des tags du playbook avant exécution. Utilisez `--tags` en CI pour exécuter seulement ce que vous voulez.

---

# Exercice 7 — **--limit, -f (forks) et performance control**

**But :** cibler un sous-ensemble et tester le parallélisme.

### Contexte

Copier un petit fichier simultanément sur beaucoup d’hôtes ; limiter l’impact réseau.

### Playbook principal (`parallel_copy.yml`)

```yaml
---
- name: Parallel copy demo
  hosts: all
  become: true
  tasks:
    - name: Copy a small file
      copy:
        dest: /tmp/parallel.txt
        content: "parallel"
```

### Cleanup (`cleanup_parallel.yml`)

```yaml
---
- name: Cleanup parallel file
  hosts: all
  become: true
  tasks:
    - name: Remove file
      file:
        path: /tmp/parallel.txt
        state: absent
```

### Commandes à tester

- Limiter à `web` groupe uniquement et forks=10 :

```bash
ansible-playbook -i inventory.ini --limit web -f 10 parallel_copy.yml
```

- Limiter à une machine précise :

```bash
ansible-playbook -i inventory.ini --limit web01 -f 2 parallel_copy.yml
```

### Vérification

```bash
ansible all -i inventory.ini -m command -a "test -f /tmp/parallel.txt && echo ok || echo missing"
```

### Débogage & conseils

- `--limit` restreint les hôtes ciblés (utile en test).

- `-f` contrôle la parallélisation. Augmenter `-f` accélère mais consomme plus de ressources côté contrôleur et réseau. Ajustez selon l’infrastructure.

---

# Exercice 8 — **--extra-vars (-e) pour passer des paramètres**

**But :** injecter des variables au runtime et rendre le playbook réutilisable.

### Contexte

Déployer une application versionnée à `/opt/app-VERSION`.

### Playbook principal (`deploy_version.yml`)

```yaml
---
- name: Deploy versioned app
  hosts: all
  become: true
  vars:
    version: "1.0"
  tasks:
    - name: Create versioned directory
      file:
        path: "/opt/app-{{ version }}"
        state: directory
        mode: "0755"

    - name: Create version file
      copy:
        dest: "/opt/app-{{ version }}/VERSION"
        content: "{{ version }}"
```

### Cleanup (`cleanup_version.yml`)

```yaml
---
- name: Cleanup versioned app
  hosts: all
  become: true
  tasks:
    - name: Remove versioned dir
      file:
        path: "/opt/app-{{ version }}"
        state: absent
```

### Commandes à tester

- Lancer avec variable passée en ligne :

```bash
ansible-playbook -i inventory.ini -e "version=2.5" deploy_version.yml
```

- Vérifier sans changer le playbook (réutilisable).

### Vérification

```bash
ansible all -i inventory.ini -m command -a "cat /opt/app-2.5/VERSION || true"
```

### Débogage & conseils

- `-e` permet de surcharger variables ; excellent pour pipelines qui génèrent la version.

- Pour des variables sensibles, **évitez** `-e` dans l’historique des shells ; préférez `--extra-vars @file.json` ou Ansible Vault.

---

# Exercice 9 — **Rescue/always blocks + failed_when + register : techniques de contrôle d’erreur**

**But :** apprendre à capturer l’échec d’une tâche, réagir et garantir nettoyage/rollback.

### Contexte

Simuler une commande qui peut échouer (commande qui retourne exit code != 0). On capture la sortie et, en cas d’échec, on restaure état.

### Playbook principal (`safe_command.yml`)

```yaml
---
- name: Safe command with rescue
  hosts: all
  become: true
  tasks:
    - name: Run a command that may fail
      command: /bin/false
      register: cmd_result
      ignore_errors: yes

    - name: Fail if command failed (explicit)
      fail:
        msg: "The critical command failed"
      when: cmd_result.rc != 0
      failed_when: false
      ignore_errors: no

    - name: This will not run if previous fail triggered
      debug:
        msg: "This will be skipped if failed"
```

> Variante plus propre : utiliser `block` / `rescue` / `always` (ci-dessous).

```yaml
- name: Block with rescue example
  hosts: all
  become: true
  tasks:
    - block:
        - name: Run risky command
          command: /bin/false
      rescue:
        - name: Recovery action
          debug:
            msg: "Recovery: create sentinel file"
        - name: Create rollback marker
          file:
            path: /tmp/recovery_marker
            state: touch
      always:
        - name: Always run this
          debug:
            msg: "Always executed"
```

### Cleanup (`cleanup_safe.yml`)

```yaml
---
- name: Cleanup recovery marker
  hosts: all
  become: true
  tasks:
    - name: Remove recovery marker
      file:
        path: /tmp/recovery_marker
        state: absent
```

### Commandes à tester

```bash
ansible-playbook -i inventory.ini safe_command.yml -vv
```

### Débogage & conseils

- `register` enregistre sortie (`stdout`, `stderr`, `rc`) ; utile pour logiques conditionnelles.

- `block`/`rescue`/`always` = mécanisme de gestion d’erreur similaire à try/catch/finally. À utiliser pour rollback contrôlé.

- Ne pas abuser de `ignore_errors` : cache les problèmes si mal utilisé.

---

# Exercice 10 — **Stratégies de debug avancées : --start-at-task, --step, -C, -D, -vvv, --flush-cache, --list-hosts** (synthèse)

**But :** combiner plusieurs options de diagnostic lors d’un playbook complexe.

### Contexte

Playbook complet : prérequis → déploiement → validation. On veut pouvoir : tester en dry-run, voir diff, afficher tâches, faire step-by-step et reprendre à une tâche précise.

### Playbook (`complex.yml`)

```yaml
---
- name: Complex demo
  hosts: all
  become: true
  tasks:
    - name: Pre-req install
      apt:
        name: curl
        state: present
        update_cache: yes
      tags: prereq

    - name: Deploy app file
      copy:
        dest: /opt/complex/app.txt
        content: "complex"
      tags: deploy

    - name: Validate app
      command: test -f /opt/complex/app.txt
      register: validate
      failed_when: validate.rc != 0
      tags: validate
```

### Cleanup (`cleanup_complex.yml`)

```yaml
---
- name: Cleanup complex
  hosts: all
  become: true
  tasks:
    - name: Remove app dir
      file:
        path: /opt/complex
        state: absent
```

### Commandes/démos à exécuter (ordre suggéré)

1. Lister hôtes / tâches / tags :

```bash
ansible-playbook -i inventory.ini --list-hosts --list-tasks --list-tags complex.yml
```

2. Dry-run diff sur la partie `deploy` seulement :

```bash
ansible-playbook -i inventory.ini -C --diff --tags deploy complex.yml
```

3. Exécution pas-à-pas pour inspecter :

```bash
ansible-playbook -i inventory.ini --step complex.yml
```

4. Reprendre à la tâche de validation :

```bash
ansible-playbook -i inventory.ini --start-at-task "Validate app" complex.yml
```

5. Trace détaillée en cas d’échec :

```bash
ansible-playbook -i inventory.ini complex.yml -vvv
```

6. Forcer rafraîchissement des facts si vous suspectez des facts obsolètes :

```bash
ansible all -m setup --flush-cache -i inventory.ini
```

### Vérification

```bash
ansible all -i inventory.ini -m stat -a "path=/opt/complex/app.txt"
```

### Débogage & conseils finaux

- Combinez `--check` + `--diff` pour valider les changements sans risquer de casser la prod.

- `--start-at-task` vous évite de relancer les étapes déjà passées.

- `--step` est didactique — indispensable en formation ; évitez en prod.

- `-vvv` révèle tout (valeurs des variables, modules invoqués). Ne partagez pas cette sortie en clair (contient parfois des chemins/variables sensibles).

- `--flush-cache` rafraîchit facts (utile si vous avez modifié l’OS récemment et les facts sont stale).

- Toujours avoir un **playbook cleanup** prêt : en cas de tests répétitifs, vous pourrez revenir à un état propre.

---

## Techniques générales de débogage (résumé humain et utile)

1. **`--syntax-check`** : vérifier la validité YAML/structure avant d’exécuter.

2. **`--list-hosts`, `--list-tasks`, `--list-tags`** : comprendre la cible et le plan sans exécution.

3. **`--check` + `--diff`** : simuler + voir modifications prévues.

4. **`-vvv`** : obtenir toutes les informations ; utile pour SSH/sudo/variables.

5. **`register` + `debug`** : inspecter la sortie d’un module dans le playbook lui-même (par ex. `debug: var=cmd_result`).

6. **`block/rescue/always`** et `failed_when`** : gérer les erreurs de façon programmée.

7. **`--start-at-task` / `--step`** : reprendre et faire pas à pas.

8. **Tester d’abord sur `--limit` à un hôte de recette** avant de cibler `all`.

9. **Consignez les sorties** (log) et utilisez `-v` régulier pour les runs automatisés (jeton/CI).

10. **Ne mettez jamais de secrets en clair** dans `-e` listés dans l’historique du shell ; utilisez Vault.
