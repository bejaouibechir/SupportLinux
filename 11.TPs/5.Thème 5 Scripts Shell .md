 # üß† Th√®me 5 ‚Äî Scripts Shell (40 exercices pratiques)

---

 ### 1) Shebang, droits, ex√©cution

**√ânonc√© :** Cr√©ez un script `hello.sh` qui affiche ‚ÄúBonjour   $USER‚Äù et ex√©cutez-le correctement.

**D√©marche :**

1 . `printf '#!/usr/bin/env bash  nprintf "Bonjour %s  n" "$USER"  n' > hello.sh`

2 . `chmod +x hello.sh  & & ./hello.sh`

&nbsp;  **Validation :** sortie contient votre login.

&nbsp;  **Conseils :** utiliser `#!/usr/bin/env bash` est plus portable que `#!/bin/bash`.

&nbsp;  **Astuces :** `bash -x ./hello.sh` pour tracer.

&nbsp;  **Pi√®ges :** oublier `chmod +x`; ex√©cuter avec `sh` au lieu de `bash` si syntaxe Bash.

---

 ### 2) Variables et quoting correct

**√ânonc√© :** √âcrire `vars.sh` qui lit un nom et l‚Äôaffiche sans expansion ind√©sirable.

**D√©marche :**

```bash
 #!/usr/bin/env bash

read -r -p "Votre nom: " nom

printf "Salut, %s!  n" "$nom"
```

**Validation :** espaces/accents pr√©serv√©s.

**Conseils :** toujours **quotter** les variables `"${var}"`.

**Astuces :** `read -r` √©vite l‚Äôinterpr√©tation des backslashes.

**Pi√®ges :** oublier les guillemets ‚Üí mots scind√©s.

---

 ### 3) Param√®tres positionnels et `$@`

**√ânonc√© :** `args.sh` affiche chaque argument sur sa ligne.

**D√©marche :**

```bash
 #!/usr/bin/env bash

for arg in "$@"; do printf '%s  n' "$arg"; done
```

**Validation :** `./args.sh "a b" c` ‚Üí 2 lignes correctes.

**Conseils :** utilisez `"$@"` (pas `$ *`).

**Astuces :** `shift` pour consommer les arguments.

**Pi√®ges :** ne pas prot√©ger `"$@"` casse les espaces.

---

 ### 4) Codes de retour  & `set -e`

**√ânonc√© :** `robuste.sh` s‚Äôarr√™te si une commande √©choue.

**D√©marche :**

```bash
 #!/usr/bin/env bash

set -e

cp /fichier/inexistant /tmp/  # doit provoquer l‚Äôarr√™t

echo "Jamais affich√©"
```

**Validation :** script stoppe avant le echo.

**Conseils :** pr√©f√©rez `set -Eeuo pipefail` pour robustesse.

**Astuces :** `|| true` pour ignorer une erreur voulue.

**Pi√®ges :** `set -e` + pipelines ‚Üí d‚Äôo√π `pipefail`.

---

 ### 5) Redirections  & fichiers log

**√ânonc√© :** `log.sh` redirige la sortie standard et erreur dans deux fichiers.

**D√©marche :**

```bash
 #!/usr/bin/env bash

{ echo "OK"; echo "ERR" > &2; } 1>out.log 2>err.log
```

**Validation :** `out.log` contient ‚ÄúOK‚Äù, `err.log` ‚ÄúERR‚Äù.

**Conseils :** structurer vos logs d√®s le d√©but.

**Astuces :** ` &>` redirige stdout+stderr ensemble.

**Pi√®ges :** √©craser par d√©faut (`>`), utilisez `>>` si append.

---

 ### 6) Pipes  & filtres

**√ânonc√© :** `compte.sh` compte les fichiers ‚Äú.conf‚Äù dans `/etc`.

**D√©marche :**

```bash
 #!/usr/bin/env bash

find /etc -maxdepth 1 -type f -name " *.conf" -print | wc -l
```

**Validation :** sortie enti√®re ‚â• 0.

**Conseils :** combinez find/grep/awk pour pipelines efficaces.

**Astuces :** `set -o pipefail` pour d√©tecter erreurs early.

**Pi√®ges :** `grep foo  *` peut d√©velopper ` *` via shell.

---

 ### 7) Tests conditionnels ` [ [ ... ]]`

**√ânonc√© :** `checkfile.sh` v√©rifie si un fichier existe et est lisible.

**D√©marche :**

```bash
 #!/usr/bin/env bash

f="$1"

if  [ [ -r "$f" ]]; then echo "OK lecture"; else echo "Pas lisible"; fi
```

**Validation :** tester sur `/etc/passwd`.

**Conseils :** pr√©f√©rez ` [ [` √† ` [` (meilleure s√©mantique).

**Astuces :** ` [ [ "$s" =~ ^ [0-9]+$ ]]` pour regex.

**Pi√®ges :** regex avec ` [ [` ne requiert pas guillemets autour du pattern.

---

 ### 8) `case` pour menus

**√ânonc√© :** `menu.sh` propose `start|stop|status`.

**D√©marche :**

```bash
 #!/usr/bin/env bash

case "$1" in

  start) echo "Start";;

  stop) echo "Stop";;

  status) echo "Status";;

   *) echo "Usage: $0 {start|stop|status}"; exit 2;;

esac
```

**Validation :** `./menu.sh start`‚Ä¶

**Conseils :** `case` est plus lisible que `if` en s√©rie.

**Astuces :** utiliser des patterns (` *.log`).

**Pi√®ges :** oublier le ` *)` pour d√©faut.

---

 ### 9) Boucles `for/while`

**√ânonc√© :** `scan.sh` lit un fichier ligne par ligne sans casser les espaces.

**D√©marche :**

```bash
 #!/usr/bin/env bash

while IFS= read -r line; do

  printf 'LIGNE: %s  n' "$line"

done < "$1"
```

**Validation :** tester avec un fichier contenant espaces.

**Conseils :** fixez `IFS` localement.

**Astuces :** `mapfile -t arr < file` (bash ‚â•4).

**Pi√®ges :** `for l in $(cat file)` casse aux espaces.

---

 ### 10) Fonctions  & `return`/`$?`

**√ânonc√© :** `func.sh` d√©finit `ping _ok host` (0 si OK).

**D√©marche :**

```bash
 #!/usr/bin/env bash

ping _ok(){ ping -c1 -W1 "$1"  &>/dev/null; }

if ping _ok 8.8.8.8; then echo "UP"; else echo "DOWN"; fi
```

**Validation :** ‚ÄúUP‚Äù si internet OK.

**Conseils :** nommez vos fonctions avec verbes clairs.

**Astuces :** `local var=...` dans fonctions.

**Pi√®ges :** oublier `local` ‚Üí variables globales pollu√©es.

---

 ### 11) Tableaux index√©s

**√ânonc√© :** `arr.sh` parcourt `("dev" "stage" "prod")` et ping chaque host `srv-$env`.

**D√©marche :**

```bash
 #!/usr/bin/env bash

envs=(dev stage prod)

for e in "${envs [@]}"; do echo "ping srv-$e"; done
```

**Validation :** 3 lignes affich√©es.

**Conseils :** toujours ` [@]` pour expansion safe.

**Astuces :** `${#envs [@]}` taille du tableau.

**Pi√®ges :** `${envs}` (sans index) ‚Üí 1er √©l√©ment uniquement.

---

 ### 12) Tableaux associatifs (bash ‚â•4)

**√ânonc√© :** `assoc.sh` mappe `service‚Üíport` et affiche `nginx‚Üí80`.

**D√©marche :**

```bash
 #!/usr/bin/env bash

declare -A ports=( [nginx]=80  [redis]=6379)

echo "nginx: ${ports [nginx]}"
```

**Validation :** affiche 80.

**Conseils :** `declare -A` indispensable.

**Astuces :** `for k in "${!ports [@]}"; do ...; done`

**Pi√®ges :** oublier de d√©clarer `-A` ‚Üí tableau index√©.

---

 ### 13) `getopts` pour options robustes

**√ânonc√© :** `backup.sh -s /src -d /dst -v`

**D√©marche :**

```bash
 #!/usr/bin/env bash

set -euo pipefail

src= dst= verbose=false

while getopts ":s:d:v" opt; do

  case "$opt" in

    s) src="$OPTARG";;

    d) dst="$OPTARG";;

    v) verbose=true;;

    :) echo "Option -$OPTARG n√©cessite un argument"; exit 2;;

      ?) echo "Option invalide: -$OPTARG"; exit 2;;

  esac

done

"$verbose"  & & set -x

rsync -a -- "$src/" "$dst/"
```

**Validation :** copier un dossier test.

**Conseils :** toujours valider les arguments.

**Astuces :** `:s:d:v` met `:` pour d√©tecter arg manquant.

**Pi√®ges :** confondre `getopt` (diff√©rent) vs `getopts`.

---

 ### 14) `trap`  & nettoyage (`mktemp`)

**√ânonc√© :** `tmp.sh` cr√©e un tempdir, s‚Äôassure qu‚Äôil est supprim√© m√™me si Ctrl+C.

**D√©marche :**

```bash
 #!/usr/bin/env bash

set -euo pipefail

tmp="$(mktemp -d)"

cleanup(){ rm -rf -- "$tmp"; }

trap cleanup EXIT INT TERM

 # ‚Ä¶ travail ‚Ä¶

sleep 2
```

**Validation :** dossier supprim√© apr√®s ex√©cution.

**Conseils :** toujours nettoyer les temporaires.

**Astuces :** utilisez `--` avant chemins pour s√©curit√©.

**Pi√®ges :** `rm -rf "$tmp"` dangereux si `$tmp` vide ‚Üí `set -u` aide.

---

 ### 15) `set -Eeuo pipefail` en pratique

**√ânonc√© :** `strict.sh` d√©montre les b√©n√©fices de mode strict.

**D√©marche :**

```bash
 #!/usr/bin/env bash

set -Eeuo pipefail

foo(){ false; }

foo | cat

echo "Non atteint gr√¢ce √† pipefail"
```

**Validation :** script s‚Äôarr√™te avant le echo.

**Conseils :** activez-le par d√©faut dans vos scripts.

**Astuces :** `trap 'echo "Erreur √† la ligne $LINENO"' ERR`

**Pi√®ges :** certains scripts tiers ne supportent pas le mode strict.

---

 ### 16) Here-doc pour g√©n√©rer un fichier config

**√ânonc√© :** `genconf.sh` √©crit un fichier avec variables interpol√©es.

**D√©marche :**

```bash
 #!/usr/bin/env bash

name="app1"

cat > app.conf <<EOF

 [app]

name=$name

log=/var/log/$name.log

EOF
```

**Validation :** `cat app.conf` montre les valeurs.

**Conseils :** utilisez `<<'EOF'` pour **d√©sactiver** l‚Äôexpansion.

**Astuces :** indenter avec `<<-EOF` + tabs.

**Pi√®ges :** mauvais d√©limiteur ‚Üí EOF non reconnu.

---

 ### 17) Here-string  & substitutions

**√ânonc√© :** `hs.sh` passe une cha√Æne directe √† une commande.

**D√©marche :**

```bash
 #!/usr/bin/env bash

wc -c <<< "Bonjour"
```

**Validation :** compte = 8 (ou selon locale).

**Conseils :** utile pour √©viter `echo | cmd`.

**Astuces :** combiner avec expansions `${var^^}` (majuscules).

**Pi√®ges :** attention aux locales pour compte d‚Äôoctets.

---

 ### 18) Expansions de param√®tres (substitutions)

**√ânonc√© :** `sub.sh` extrait l‚Äôextension d‚Äôun fichier et le nom sans extension.

**D√©marche :**

```bash
 #!/usr/bin/env bash

f="$1"

echo "ext=${f## *.}"

echo "base=${f%. *}"
```

**Validation :** `./sub.sh dossier/fichier.log` ‚Üí ext=log, base=fichier

**Conseils :** ma√Ætriser `# ## % %%` est cl√©.

**Astuces :** `${var:-default}` valeur par d√©faut.

**Pi√®ges :** noms avec plusieurs points ‚Üí testez bien.

---

 ### 19) Arithm√©tique  & dates

**√ânonc√© :** `dateadd.sh` ajoute N jours √† aujourd‚Äôhui.

**D√©marche :**

```bash
 #!/usr/bin/env bash

n="${1:-7}"

date -d "+$n days" +%F
```

**Validation :** comparez manuellement.

**Conseils :** d√©porter calculs complexes vers `date`.

**Astuces :** `printf -v d '%(%F)T' -1` (Bash 5).

**Pi√®ges :** `date -d` diff√®re selon OS (BSD/macOS).

---

 ### 20) Tests fichiers (ex√©cutable/dir/links)

**√ânonc√© :** `ftest.sh` v√©rifie type et droits d‚Äôun chemin.

**D√©marche :**

```bash
 #!/usr/bin/env bash

p="$1"

if  [ [ -d "$p" ]]; then echo "Dir"

elif  [ [ -x "$p" ]]; then echo "Executable"

elif  [ [ -L "$p" ]]; then echo "Symlink"

else echo "Autre"; fi
```

**Validation :** testez sur `/bin`, `/bin/ls`, un lien.

**Conseils :** combinez ` [ [ -s file ]]` (non vide), `-w` (√©criture).

**Astuces :** `realpath -e` pour r√©soudre.

**Pi√®ges :** liens cass√©s ‚Üí utilisez `-L` vs `-e`.

---

 ### 21) `find -print0` + `xargs -0`

**√ânonc√© :** `safe-rm-ext.sh` supprime en s√©curit√© tous ` *.tmp` (noms avec espaces).

**D√©marche :**

```bash
 #!/usr/bin/env bash

find . -type f -name ' *.tmp' -print0 | xargs -0 -r rm -f --
```

**Validation :** cr√©ez des fichiers ‚Äúa b.tmp‚Äù puis testez.

**Conseils :** toujours `-print0/-0` pour noms exotiques.

**Astuces :** `-r` (xargs) n‚Äôex√©cute pas si liste vide.

**Pi√®ges :** `rm -rf .` par accident ‚Äî doublez les garde-fous.

---

 ### 22) `grep` avanc√© : bornes, ignore-case, word

**√ânonc√© :** `findpass.sh` d√©tecte lignes passwd avec UID 0.

**D√©marche :**

```bash
 #!/usr/bin/env bash

grep -E '^ [^:]+: [^:] *:0:' /etc/passwd
```

**Validation :** ligne root trouv√©e.

**Conseils :** pr√©f√©rez `grep -E` et ancrez avec `^`.

**Astuces :** `-w` pour ‚Äúmot entier‚Äù.

**Pi√®ges :** faux positifs si pattern vague.

---

 ### 23) `awk` pour colonnes calcul√©es

**√ânonc√© :** `disk-usage.sh` trie par taille (colonne 5 de `ls -l`).

**D√©marche :**

```bash
 #!/usr/bin/env bash

ls -l | awk 'NR>1{print $5, $9}' | sort -nr | head
```

**Validation :** liste top 10 plus gros fichiers.

**Conseils :** `NR>1` pour ignorer l‚Äôent√™te.

**Astuces :** `du -ah | sort -rh | head` est souvent mieux.

**Pi√®ges :** `ls -l` est ambigu (noms avec espaces).

---

 ### 24) `sed` en place (in-place) avec sauvegarde

**√ânonc√© :** `bump-version.sh` remplace `version=1.2.3` ‚Üí `1.2.4` dans un fichier.

**D√©marche :**

```bash
 #!/usr/bin/env bash

sed -i.bak -E 's/(version=)( [0-9]+  . [0-9]+  .)( [0-9]+)/echo "  1  2"$((  3+1))/ge' app.env
```

**Validation :** `grep version app.env` affiche nouvelle version.

**Conseils :** conservez `.bak` pour rollback.

**Astuces :** `-E` pour ERE, `e` pour ex√©cuter substitution.

**Pi√®ges :** `sed -i` diff√®re sur macOS (BSD `-i ''`).

---

 ### 25) Journalisation structur√©e

**√ânonc√© :** `logger.sh` √©crit sur stdout et `/var/log/app.log` avec timestamp.

**D√©marche :**

```bash
 #!/usr/bin/env bash

log(){ printf '%(%F %T)T  [%s] %s  n' -1 "$1" "$2" | tee -a /var/log/app.log; }

log INFO "Service d√©marr√©"
```

**Validation :** ligne horodat√©e en deux sorties.

**Conseils :** niveaux `INFO/WARN/ERROR`.

**Astuces :** `logger -t app "message"` envoie vers syslog.

**Pi√®ges :** droits sur `/var/log/ *` (utiliser sudo ou `$HOME/.local/logs`).

---

 ### 26) Couleurs terminal

**√ânonc√© :** `color.sh` affiche erreurs en rouge, OK en vert.

**D√©marche :**

```bash
 #!/usr/bin/env bash

RED=$'  e [31m'; GRN=$'  e [32m'; RST=$'  e [0m'

printf "%sERREUR%s  n" "$RED" "$RST"

printf "%sOK%s  n" "$GRN" "$RST"
```

**Validation :** couleurs visibles (terminal compatible).

**Conseils :** v√©rifiez `$TERM`.

**Astuces :** variables ANSI centralis√©es.

**Pi√®ges :** redirections vers fichier contiendront codes bruts.

---

 ### 27) Parallelisation simple (background + wait)

**√ânonc√© :** `par.sh` lance 3 pings en parall√®le, attend, puis r√©capitule.

**D√©marche :**

```bash
 #!/usr/bin/env bash

set -Eeuo pipefail

hosts=(8.8.8.8 1.1.1.1 example.com)

pids=()

for h in "${hosts [@]}"; do ping -c1 "$h"  & pids+=($!); done

for p in "${pids [@]}"; do wait "$p"; done

echo "Termin√©"
```

**Validation :** attend la fin des 3 jobs.

**Conseils :** surveillez l‚Äôutilisation CPU.

**Astuces :** `jobs -l` pour voir PIDs.

**Pi√®ges :** ne jamais ignorer `wait` ‚Üí zombies/incoh√©rences.

---

 ### 28) File locking avec `flock`

**√ânonc√© :** `cron-safe.sh` s‚Äôassure qu‚Äôune seule instance tourne.

**D√©marche :**

```bash
 #!/usr/bin/env bash

exec 9>/tmp/cron.lock

flock -n 9 || { echo "D√©j√† en cours"; exit 0; }

 # ... t√¢che longue ...

sleep 5
```

**Validation :** lancer 2 fois simultan√©ment ‚Üí 1 seule passe.

**Conseils :** indispensable en cron/systemd timers.

**Astuces :** `flock -x` verrou exclusif (d√©faut).

**Pi√®ges :** oublier `exec 9>` garde le lock local au shell.

---

 ### 29) S√©curit√© : entr√©e utilisateur  & validation

**√ânonc√© :** `ask-port.sh` demande un port (1024‚Äì65535), puis l‚Äôutilise.

**D√©marche :**

```bash
 #!/usr/bin/env bash

read -r -p "Port: " port

if  [ [ "$port" =~ ^ [0-9]+$ ]]  & & (( port>=1024  & & port<=65535 )); then

  echo "OK: $port"

else

  echo "Port invalide" > &2; exit 2

fi
```

**Validation :** `0` ‚Üí invalide, `8080` ‚Üí OK.

**Conseils :** validez syst√©matiquement les entr√©es.

**Astuces :** `(( expr ))` pour arithm√©tique s√ªre.

**Pi√®ges :** injection via shell si non quot√©/valid√©.

---

 ### 30) Sourcing (`. file` / `source`)

**√ânonc√© :** `env.sh` exporte des variables, `main.sh` les consomme.

**D√©marche :**

```bash
 # env.sh

export APP _ENV=dev

 # main.sh

 #!/usr/bin/env bash

source ./env.sh

echo "$APP _ENV"
```

**Validation :** affiche `dev`.

**Conseils :** ne sourcez que des fichiers **de confiance**.

**Astuces :** validez existence ` [ [ -f env.sh ]] || exit`.

**Pi√®ges :** chemins relatifs cass√©s si lanc√© d‚Äôailleurs ‚Üí utilisez `${BASH _SOURCE [0]}`.

---

 ### 31) Interaction avec `systemd` (oneshot)

**√ânonc√© :** √âcrire un script `rotate.sh` puis service `oneshot` qui l‚Äôex√©cute.

**D√©marche (script) :**

```bash
 #!/usr/bin/env bash

set -Eeuo pipefail

log="/var/log/app.log"

 [ [ -f "$log" ]]  & & mv "$log" "$log.$(date +%F _%H%M%S)" || true
```

**Validation :** `systemctl start rotate.service` renomme le log.

**Conseils :** `UMask=` et `User=` dans unit pour permissions.

**Astuces :** utiliser `RuntimeDirectory=` pour cr√©er un r√©pertoire temp.

**Pi√®ges :** oublier `set -e` ‚Üí erreurs silencieuses.

---

 ### 32) Cron-friendly (chemins absolus, PATH)

**√ânonc√© :** Rendez `backup.sh` compatible cron.

**D√©marche :**

 * En t√™te : `PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin`

 * Utilisez **chemins absolus** (`/usr/bin/rsync`).

&nbsp; **Validation :** job cron √©crit un log OK.

&nbsp; **Conseils :** ne supposez pas le m√™me PATH qu‚Äôen interactive.

&nbsp; **Astuces :** `SHELL=/bin/bash` dans crontab.

&nbsp; **Pi√®ges :** variables non export√©es ‚Üí job √©choue.

---

 ### 33) Gestion d‚Äôerreurs centralis√©e

**√ânonc√© :** `errframe.sh` logge ligne et commande fautive.

**D√©marche :**

```bash
 #!/usr/bin/env bash

set -Eeuo pipefail

trap 's=$?; echo "Erreur ($s) √† la ligne $LINENO: $BASH _COMMAND" > &2' ERR

f(){ false; }

f
```

**Validation :** message d‚Äôerreur d√©taill√©.

**Conseils :** utile pour debugging en prod.

**Astuces :** enrichir avec fonction logger.

**Pi√®ges :** trap ERR ne se propage pas via `set -E` si manquant.

---

 ### 34) V√©rifications pr√©alables (‚Äúguard clauses‚Äù)

**√ânonc√© :** `deploy.sh` √©choue proprement si outil manquant.

**D√©marche :**

```bash
 #!/usr/bin/env bash

set -Eeuo pipefail

command -v rsync >/dev/null || { echo "rsync manquant"; exit 127; }
```

**Validation :** d√©sinstallez/renommez rsync pour tester.

**Conseils :** v√©rifiez aussi droits/espaces disque.

**Astuces :** messages d‚Äôerreurs explicites.

**Pi√®ges :** continuer malgr√© pr√©requis manquants.

---

 ### 35) S√©curiser `rm` (corbeille/backup)

**√ânonc√© :** `safe-rm.sh` d√©place vers corbeille au lieu de supprimer.

**D√©marche :**

```bash
 #!/usr/bin/env bash

set -Eeuo pipefail

trash="$HOME/.local/trash"

mkdir -p "$trash"

for f in "$@"; do mv -n -- "$f" "$trash/"; done
```

**Validation :** fichiers pr√©sents dans la corbeille.

**Conseils :** ajoutez rotation/cleanup planifi√©.

**Astuces :** `-n` n‚Äô√©crase pas.

**Pi√®ges :** noms identiques ‚Üí versionnez (timestamp).

---

 ### 36) S√©curiser `cp` et `rsync` (idempotence)

**√ânonc√© :** `sync.sh` copies only changed.

**D√©marche :**

```bash
 #!/usr/bin/env bash

rsync -a --delete --checksum --human-readable src/ dst/
```

**Validation :** re-lancer : rien √† copier.

**Conseils :** `--dry-run` pour pr√©visualiser.

**Astuces :** `--partial --inplace` selon cas.

**Pi√®ges :** `--delete` supprime dans dst ‚Äî ne pas se tromper de sens.

---

 ### 37) S√©lection par motif (globbing avanc√©)

**√ânonc√© :** `select.sh` met en liste tous les fichiers ` *.{log,txt}` sauf ceux qui commencent par `old _`.

**D√©marche :**

```bash
 #!/usr/bin/env bash

shopt -s extglob nullglob

for f in !("old _") *.@(log|txt); do echo "$f"; done
```

**Validation :** v√©rifiez liste correcte.

**Conseils :** activez `extglob` pour motifs avanc√©s.

**Astuces :** `nullglob` √©vite de renvoyer le motif brut s‚Äôil n‚Äôy a pas de match.

**Pi√®ges :** compatibilit√© si `shopt` non persist√©e.

---

 ### 38) Validation JSON simple avec `jq` (si dispo)

**√ânonc√© :** `check-json.sh` valide un JSON et extrait un champ.

**D√©marche :**

```bash
 #!/usr/bin/env bash

set -Eeuo pipefail

jq -e . "$1" >/dev/null

jq -r '.name' "$1"
```

**Validation :** JSON mal form√© ‚Üí √©chec; sinon affiche `.name`.

**Conseils :** grace √† `-e`, jq renvoie code !=0 si invalide.

**Astuces :** fallback: `python -m json.tool` si jq absent.

**Pi√®ges :** jq n‚Äôest pas toujours install√© ‚Üí tester sa pr√©sence.

---

 ### 39) Entr√©es massives : `mapfile` + traitement

**√ânonc√© :** `bulk.sh` lit une liste de chemins et supprime ceux >10 Mo apr√®s confirmation.

**D√©marche :**

```bash
 #!/usr/bin/env bash

mapfile -t files < liste.txt

for f in "${files [@]}"; do

  size=$(stat -c %s -- "$f" 2>/dev/null || echo 0)

  if (( size > 10 *1024 *1024 )); then

    read -r -p "Supprimer $f (y/N)? " a

     [ [ $a == y ]]  & & rm -f -- "$f"

  fi

done
```

**Validation :** tester sur fichiers factices.

**Conseils :** confirmation interactive = filet de s√©curit√©.

**Astuces :** `dd if=/dev/zero of=bigfile bs=1M count=12`.

**Pi√®ges :** `stat` diff√®re sur macOS (utiliser `-f %z`).

---

 ### 40) D√©fi final : utilitaire CLI de packaging

**√ânonc√© :** `pack.sh` : options `-s src/ -o out.tgz -e " *.log"` qui archive `src` en excluant le motif. Robustesse  & logs.

**D√©marche (squelette) :**

```bash
 #!/usr/bin/env bash

set -Eeuo pipefail

src= out= exclude=

while getopts ":s:o:e:" opt; do

  case "$opt" in

    s) src="$OPTARG";;

    o) out="$OPTARG";;

    e) exclude="$OPTARG";;

    :) echo "Option -$OPTARG requiert un argument" > &2; exit 2;;

      ?) echo "Option invalide: -$OPTARG" > &2; exit 2;;

  end

done

 [ [ -d "$src"  & & -n "$out" ]] || { echo "Usage: -s src -o out.tgz  [-e pattern]"; exit 2; }

log(){ printf '%(%F %T)T  [pack] %s  n' -1 "$ *" > &2; }

tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' EXIT

log "Cr√©ation archive"

if  [ [ -n "$exclude" ]]; then

  tar -C "$src" --exclude="$exclude" -czf "$out" .

else

  tar -C "$src" -czf "$out" .

fi

log "OK -> $out"
```

**Validation :** cr√©e `out.tgz` sans fichiers exclus.

**Conseils :** messages d‚Äôerreurs clairs, exit codes propres.

**Astuces :** `tar -tvf out.tgz` pour v√©rifier contenu.

**Pi√®ges :** oublier `-C` ‚Üí archive chemins absolus (mauvaise pratique).

---

 ## Rappels transverses (pour tous les scripts)

 * **Robustesse** : `set -Eeuo pipefail`, `trap ERR`.

 * **S√©curit√©** : toujours quoter `"${var}"`, valider entr√©es, pr√©f√©rer `--` avant chemins.

 * **Portabilit√©** : en shebang, `#!/usr/bin/env bash`. Sur macOS, `sed -i` diff√®re.

 * **Journalisation** : timestamps, niveaux, fichiers d√©di√©s + `logger`.

 * **Nettoyage** : `trap 'rm -rf "$tmp"' EXIT`, `mktemp`.

 * **Performance** : privil√©gier `awk/sed/find` au lieu de boucles lourdes.

 * **Lisibilit√©** : noms de fonctions explicites, messages d‚Äôerreur utiles, usage de `getopts`.

