\# Exercice approfondi — \*\*SyncLite\*\*



\## objectif



copier \*\*seulement les fichiers nouveaux ou modifiés\*\* d’un \*\*dossier source\*\* vers un \*\*dossier cible\*\*, avec :



\* `-s` source, `-d` destination (obligatoires)

\* `-e` extension à filtrer (optionnelle, ex: `txt` ou `log`)

\* `-n` dry-run (simulation, n’écrit rien)

\* `-v` verbose

\* gestion des erreurs claire + codes retour: `0` ok, `1` erreur d’arguments/prérequis



---



\## script (copier-coller tel quel)



```bash

\#!/usr/bin/env bash

\# SyncLite - Copier uniquement les fichiers nouveaux/modifiés d'un dossier à un autre

\# Compatibilité: Debian 12/13. Requiert bash (car \[\[ ]], ${var^^}, etc.)

\# Codes retour:

\#   0 = succès

\#   1 = erreur d'arguments/prérequis



set -euo pipefail



usage() {

&nbsp; cat <<'USAGE'

Usage: synclite.sh -s <src\_dir> -d <dst\_dir> \[-e <ext>] \[-n] \[-v]

&nbsp; -s  Dossier source (obligatoire)

&nbsp; -d  Dossier destination (obligatoire)

&nbsp; -e  Extension à filtrer (sans le point), ex: txt  (optionnel)

&nbsp; -n  Dry-run: affiche ce qui serait copié, n'écrit rien

&nbsp; -v  Verbose: traces détaillées

Exemples:

&nbsp; synclite.sh -s ./in -d ./out

&nbsp; synclite.sh -s ./in -d ./out -e txt -v

&nbsp; synclite.sh -s ./in -d ./out -n

USAGE

}



SRC="" DST="" EXT="" DRY=false VERB=false



\# --- Parsing arguments ---

while getopts ":s:d:e:nvh" opt; do

&nbsp; case "$opt" in

&nbsp;   s) SRC="$OPTARG" ;;

&nbsp;   d) DST="$OPTARG" ;;

&nbsp;   e) EXT="$OPTARG" ;;

&nbsp;   n) DRY=true ;;

&nbsp;   v) VERB=true ;;

&nbsp;   h) usage; exit 0 ;;

&nbsp;   \\?) echo "Option invalide: -$OPTARG" >\&2; usage; exit 1 ;;

&nbsp;   :)  echo "Option manquante pour -$OPTARG" >\&2; usage; exit 1 ;;

&nbsp; esac

done



\# --- Vérifications de base ---

\[\[ -n "$SRC" \&\& -d "$SRC" \&\& -r "$SRC" ]] || { echo "Erreur: -s doit cibler un dossier lisible." >\&2; usage; exit 1; }

\[\[ -n "$DST" ]] || { echo "Erreur: -d est obligatoire." >\&2; usage; exit 1; }

\# Crée la destination si nécessaire

mkdir -p -- "$DST"

\[\[ -d "$DST" \&\& -w "$DST" ]] || { echo "Erreur: dossier destination non inscriptible: $DST" >\&2; exit 1; }



$VERB \&\& echo "\[VERBOSE] SRC=$SRC DST=$DST EXT=${EXT:-<none>} DRY=$DRY" >\&2



\# --- Fonction de copie sûre (préserve l'arborescence relative) ---

copy\_if\_newer() {

&nbsp; # $1 = chemin absolu du fichier source

&nbsp; local f="$1"

&nbsp; # chemin relatif par rapport à SRC

&nbsp; local rel="${f#"$SRC"/}"

&nbsp; local dest="$DST/$rel"

&nbsp; local dest\_dir

&nbsp; dest\_dir="$(dirname -- "$dest")"



&nbsp; # Filtre extension si demandé (sans le point, ex: txt)

&nbsp; if \[\[ -n "$EXT" ]]; then

&nbsp;   # extraire l'extension en minuscules

&nbsp;   local base ext\_lower

&nbsp;   base="$(basename -- "$f")"

&nbsp;   ext\_lower="${base##\*.}"

&nbsp;   ext\_lower="${ext\_lower,,}"

&nbsp;   if \[\[ "$ext\_lower" != "$EXT" ]]; then

&nbsp;     $VERB \&\& echo "\[VERBOSE] skip (ext) $rel" >\&2

&nbsp;     return 0

&nbsp;   fi

&nbsp; fi



&nbsp; # Cas 1: le fichier n'existe pas encore côté destination -> à copier

&nbsp; if \[\[ ! -e "$dest" ]]; then

&nbsp;   if $DRY; then

&nbsp;     echo "\[DRY] + $rel"

&nbsp;   else

&nbsp;     mkdir -p -- "$dest\_dir"

&nbsp;     cp -p -- "$f" "$dest"

&nbsp;     $VERB \&\& echo "\[VERBOSE] copied (new) $rel" >\&2

&nbsp;   fi

&nbsp;   return 0

&nbsp; fi



&nbsp; # Cas 2: existe -> on copie si source est plus récent que dest (-nt)

&nbsp; if \[\[ "$f" -nt "$dest" ]]; then

&nbsp;   if $DRY; then

&nbsp;     echo "\[DRY] ~ $rel"

&nbsp;   else

&nbsp;     cp -p -- "$f" "$dest"

&nbsp;     $VERB \&\& echo "\[VERBOSE] copied (updated) $rel" >\&2

&nbsp;   fi

&nbsp; else

&nbsp;   $VERB \&\& echo "\[VERBOSE] skip (up-to-date) $rel" >\&2

&nbsp; fi

}



\# --- Parcours des fichiers source ---

\# -print0 gère les noms avec espaces; boucle en NUL-terminated

COUNT=0

while IFS= read -r -d '' file; do

&nbsp; copy\_if\_newer "$file"

&nbsp; ((COUNT++))

done < <(find "$SRC" -type f -print0)



\# --- Bilan ---

if $DRY; then

&nbsp; echo "\[DRY] Fichiers parcourus: $COUNT"

else

&nbsp; echo "Sync terminé. Fichiers parcourus: $COUNT"

fi



exit 0

```



---



\## comment utiliser (pas-à-pas)



1\. \*\*préparer un bac à sable de test :\*\*



```bash

mkdir -p ~/synclite\_demo/in/sub ~/synclite\_demo/out

printf "A\\n" > ~/synclite\_demo/in/a.txt

printf "B\\n" > ~/synclite\_demo/in/b.log

printf "C\\n" > ~/synclite\_demo/in/sub/c.txt

```



2\. \*\*enregistrer le script\*\* sous `synclite.sh` et le rendre exécutable :



```bash

chmod +x synclite.sh

```



3\. \*\*voir l’aide\*\* :



```bash

./synclite.sh -h

```



4\. \*\*première synchronisation (tous fichiers)\*\* :



```bash

./synclite.sh -s ~/synclite\_demo/in -d ~/synclite\_demo/out -v

\# attendu : copie de a.txt, b.log, sub/c.txt

ls -R ~/synclite\_demo/out

```



5\. \*\*tester le filtrage d’extension (`-e txt`)\*\* :



```bash

\# on modifie a.txt (sera plus récent que la copie existante)

printf "A2\\n" >> ~/synclite\_demo/in/a.txt

\# on ajoute un nouveau fichier d'une autre extension

printf "X\\n" >  ~/synclite\_demo/in/new.bin



./synclite.sh -s ~/synclite\_demo/in -d ~/synclite\_demo/out -e txt -v

\# attendu :

\# - a.txt recopié (mis à jour)

\# - sub/c.txt déjà à jour -> skip

\# - b.log et new.bin ignorés (filtrés car pas .txt)

```



6\. \*\*simulation (dry-run)\*\* :



```bash

./synclite.sh -s ~/synclite\_demo/in -d ~/synclite\_demo/out -n -v

\# attendu : affichage \[DRY] des actions, aucun fichier écrit côté out/

```



7\. \*\*vérifier les dates de modification\*\* (comprendre la logique “nouveau/modifié”) :



```bash

\# montre les timestamps côté out/

find ~/synclite\_demo/out -type f -printf '%TY-%Tm-%Td %TH:%TM:%TS %p\\n' | sort

```

