---
## Exercice 1 — `for` sur liste (basique)

### Contexte & objectif

Découvrir la boucle `for` sur une **liste explicite**.

### Script

```bash
#!/usr/bin/env bash
# Itère sur une liste d'éléments "en dur"
for name in Alice Bob Charly; do
  echo "Bonjour $name"
done
```

### Scénario de test

- `./exo1.sh` → affiche 3 salutations.

### Astuces / Pièges / Améliorations

- Ajoutez des noms avec des espaces : remplacez `Alice Bob` par `"Alice Cooper" Bob`.

- Piège : sans guillemets, les espaces séparent en plusieurs items.

---

## Exercice 2 — `for` avec séquence `{1..5}`

### Contexte & objectif

Générer une **séquence numérique** simple.

### Script

```bash
#!/usr/bin/env bash
# Brace expansion : génère 1 2 3 4 5
for i in {1..5}; do
  echo "i = $i"
done
```

### Scénario de test

- `./exo2.sh` → affiche 1..5.

- Modifiez `{5..1}` pour descendre.

### Astuces / Pièges / Améliorations

- Fonctionne avant l’exécution (expansion par le shell) → pas de variables dans `{1..$N}`.

- Amélioration : utilisez `seq` si la borne est dynamique : `for i in $(seq 1 "$N")`.

---

## Exercice 3 — `for ((...))` style C

### Contexte & objectif

Boucle **compteur** avec init/condition/incrément.

### Script

```bash
#!/usr/bin/env bash
# Style C : proche de C/Java
for ((i=0; i<10; i+=2)); do
  echo "i = $i"
done
```

### Scénario de test

- `./exo3.sh` → affiche 0,2,4,6,8.

### Astuces / Pièges / Améliorations

- Arithmétique native bash : pas de `$` dans la condition.

- Amélioration : rendez les bornes paramétrables `max=${1:-10}`.

---

## Exercice 4 — `while` conditionnel

### Contexte & objectif

Répéter **tant que** la condition est vraie.

### Script

```bash
#!/usr/bin/env bash
n=1
while [ "$n" -le 5 ]; do
  echo "Itération $n"
  ((n++))  # incrément natif
done
```

### Scénario de test

- `./exo4.sh` → 5 lignes.

### Astuces / Pièges / Améliorations

- Piège : oublier l’incrément ⇒ boucle infinie.

- Amélioration : validez l’entrée utilisateur pour la borne.

---

## Exercice 5 — `until` (jusqu’à condition vraie)

### Contexte & objectif

Boucler **jusqu’à** ce que la condition soit satisfaite.

### Script

```bash
#!/usr/bin/env bash
i=0
until [ "$i" -gt 3 ]; do
  echo "i = $i"
  ((i++))
done
```

### Scénario de test

- `./exo5.sh` → 0..3.

### Astuces / Pièges / Améliorations

- `until` inverse la logique de `while`.

- Amélioration : utile pour “attendre” un service (`until nc -z host port; do sleep 1; done`).

---

## Exercice 6 — `for` sur tableau `${array[@]}`

### Contexte & objectif

Itérer proprement sur un **tableau**.

### Script

```bash
#!/usr/bin/env bash
codes=(200 301 "404 Not Found" 500)
for c in "${codes[@]}"; do
  echo "Code : $c"
done
```

### Scénario de test

- `./exo6.sh` → affiche 4 lignes, dont une avec espace.

### Astuces / Pièges / Améliorations

- Toujours **quotter** `"${array[@]}"` pour préserver les espaces.

- Amélioration : lire un tableau depuis un fichier avec `mapfile` (voir exo 15).

---

## Exercice 7 — `select` (menu interactif)

### Contexte & objectif

Créer un **menu CLI** sans gérer l’input manuellement.

### Script

```bash
#!/usr/bin/env bash
PS3="Choisissez une couleur : "
select color in rouge vert bleu quitter; do
  case "$REPLY" in
    1|2|3) echo "Vous avez choisi : $color (n° $REPLY)";;
    4) echo "Au revoir"; break;;
    *) echo "Choix invalide ($REPLY)";;
  esac
done
```

### Scénario de test

- `./exo7.sh`, tapez `2`, puis `4`.

### Astuces / Pièges / Améliorations

- `PS3` personnalise l’invite `#?`.

- Amélioration : boucler jusqu’à “Quitter” (déjà fait) et valider le choix.

---

## Exercice 8 — `while read` (fichier ligne par ligne)

### Contexte & objectif

Lire un **fichier** ligne par ligne sans casser les espaces/backslashes.

### Script

```bash
#!/usr/bin/env bash
in="${1:-liste.txt}"     # fichier passé en arg, sinon liste.txt
while IFS= read -r line; do
  echo ">> $line"
done < "$in"
```

### Scénario de test

- Créez `liste.txt` avec quelques lignes (espaces inclus).

- `./exo8.sh` ou `./exo8.sh autre.txt`.

### Astuces / Pièges / Améliorations

- `IFS= read -r` est la **bonne** pratique.

- Amélioration : numéroter les lignes (`nl -ba` ou compteur).

---

## Exercice 9 — Pipeline vers `while read`

### Contexte & objectif

Traiter la **sortie d’une commande** ligne par ligne.

### Script

```bash
#!/usr/bin/env bash
ls -1 /etc | while IFS= read -r f; do
  echo "[/etc] $f"
done
```

### Scénario de test

- `./exo9.sh` → liste annotée.

### Astuces / Pièges / Améliorations

- Piège : la boucle après `|` tourne dans un **sous-shell** → variables modifiées dedans **ne remontent pas**.

- Amélioration : utilisez un **process substitution** pour rester dans le shell parent :  
  `while IFS= read -r f; do ...; done < <(ls -1 /etc)`

---

## Exercice 10 — `break` & `continue`

### Contexte & objectif

Contrôler fin et saut d’itérations.

### Script

```bash
#!/usr/bin/env bash
for i in {1..10}; do
  if [ "$i" -eq 3 ]; then
    echo "On saute $i"
    continue
  fi
  if [ "$i" -eq 7 ]; then
    echo "On s'arrête à $i"
    break
  fi
  echo "i = $i"
done
```

### Scénario de test

- `./exo10.sh` → observe le saut de 3 et l’arrêt à 7.

### Astuces / Pièges / Améliorations

- Amélioration : combiner avec des **conditions composées** `[ "$i" -ge 3 ] && [ "$i" -le 5 ]`.

---

## Exercice 11 — Boucles imbriquées

### Contexte & objectif

Combiner deux boucles.

### Script

```bash
#!/usr/bin/env bash
for carte in pique coeur carreau trefle; do
  for rang in {1..3}; do
    echo "$carte-$rang"
  done
done
```

### Scénario de test

- `./exo11.sh` → 12 combinaisons.

### Astuces / Pièges / Améliorations

- Amélioration : interrompre la **boucle externe** depuis l’interne : `break 2`.

---

## Exercice 12 — Boucle infinie maîtrisée (`while true`) + `trap`

### Contexte & objectif

Boucle “daemon” simple + **sortie propre** au signal.

### Script

```bash
#!/usr/bin/env bash
trap 'echo; echo "[STOP] Interruption reçue."; exit 0' INT TERM
while true; do
  date '+%H:%M:%S'
  sleep 1
done
```

### Scénario de test

- `./exo12.sh` puis **Ctrl+C** → message propre.

### Astuces / Pièges / Améliorations

- Piège : sans `trap`, arrêt abrupt.

- Amélioration : écrire dans un log (rediriger `>> script.log`).

---

## Exercice 13 — Itérer sur fichiers sans `$(ls ...)`

### Contexte & objectif

Itérer sur fichiers **robustement** (espaces, aucun match).

### Script

```bash
#!/usr/bin/env bash
shopt -s nullglob      # si aucun match, la boucle ne tourne pas
for f in *.txt; do
  echo "Fichier : $f"
done
shopt -u nullglob
```

### Scénario de test

- Créez 0 puis 2 fichiers `.txt`. Comparez sorties.

### Astuces / Pièges / Améliorations

- Piège : `for f in $(ls *.txt)` casse avec espaces.

- Amélioration : combinez avec `extglob` pour motifs avancés.

---

## Exercice 14 — `find -print0` + `while read -d ''`

### Contexte & objectif

Gestion **noms avec espaces/newlines** (robuste).

### Script

```bash
#!/usr/bin/env bash
dir="${1:-.}"
find "$dir" -type f -name "*.log" -print0 | \
while IFS= read -r -d '' path; do
  echo "LOG : $path"
done
```

### Scénario de test

- Créez `a.log`, `b with space.log`.

- `./exo14.sh` → les deux sont traités correctement.

### Astuces / Pièges / Améliorations

- `-print0` + `-d ''` = duo **anti-espaces/newlines**.

- Amélioration : ajouter une action (gzip, mv, etc.) en place.

---

## Exercice 15 — `mapfile` / `readarray` + boucle

### Contexte & objectif

Charger un flux en **tableau**, puis itérer.

### Script

```bash
#!/usr/bin/env bash
mapfile -t entries < /etc/passwd   # -t retire les \n finaux
for line in "${entries[@]}"; do
  user=${line%%:*}
  shell=${line##*:}
  echo "user=$user | shell=$shell"
done
```

### Scénario de test

- `./exo15.sh` → pairs user/shell.

### Astuces / Pièges / Améliorations

- `mapfile` évite de gérer la boucle de lecture manuelle.

- Amélioration : filtrer `shell` avec un `case` (ex: bash seulement).

---

## Exercice 16 — Substitution de commande autour d’une boucle

### Contexte & objectif

Capturer la **sortie** d’une boucle dans une **variable**.

### Script

```bash
#!/usr/bin/env bash
block=$(
  for i in {1..3}; do
    echo "item-$i"
  done
)
echo "Bloc généré :"
echo "$block"
```

### Scénario de test

- `./exo16.sh` → “item-1…3” dans `block`.

### Astuces / Pièges / Améliorations

- Amélioration : `printf` pour mieux formater (CSV/JSON léger).

---

## Exercice 17 — `xargs` (boucle implicite performante)

### Contexte & objectif

Remplacer une boucle par **xargs** (performant).

### Script

```bash
#!/usr/bin/env bash
find /etc -maxdepth 1 -name "*.conf" -print0 | \
xargs -0 -n1 -I{} bash -c 'echo "Conf: {}"'
```

### Scénario de test

- `./exo17.sh` → liste “Conf: …”.

### Astuces / Pièges / Améliorations

- `-0` gère null-terminated.

- Amélioration : paralléliser `xargs -P 4` (attention aux effets de bord).

---

## Exercice 18 — `select` + `case` + traitements

### Contexte & objectif

Menu réitéré avec **opérations concrètes**.

### Script

```bash
#!/usr/bin/env bash
PS3="Choix ? "
options=("Lister .sh" "Compter lignes *.txt" "Quitter")
select opt in "${options[@]}"; do
  case "$REPLY" in
    1)
      found=false
      for f in *.sh; do
        [ -e "$f" ] || continue
        found=true; echo "$f"
      done
      $found || echo "Aucun .sh"
      ;;
    2)
      total=0
      for f in *.txt; do
        [ -e "$f" ] || continue
        c=$(wc -l <"$f"); echo "$f : $c"; ((total+=c))
      done
      echo "Total lignes: $total"
      ;;
    3) echo "Bye"; break ;;
    *) echo "Choix invalide" ;;
  esac
done
```

### Scénario de test

- Créez quelques `.sh` et `.txt`.

- `./exo18.sh` → testez 1, 2, puis 3.

### Astuces / Pièges / Améliorations

- Vérifiez l’existence de fichiers (`[ -e "$f" ]`).

- Amélioration : ajouter une option “créer un *.txt de test”.

---

## Exercice 19 — `while read` + `break/continue` (validation)

### Contexte & objectif

Valider l’entrée utilisateur, **ignorer vides**, **STOP** pour quitter.

### Script

```bash
#!/usr/bin/env bash
echo "Entrez des mots (STOP pour finir) :"
while IFS= read -r word; do
  [ -z "$word" ] && { echo "(ligne vide ignorée)"; continue; }
  [ "$word" = "STOP" ] && { echo "Fin."; break; }
  echo ">> $word"
done
```

### Scénario de test

- `./exo19.sh` → tapez lignes vides, mots, puis `STOP`.

### Astuces / Pièges / Améliorations

- Amélioration : ajouter un **timeout** d’entrée avec `read -t 5`.

---

## Exercice 20 — Traitement robuste (find | while) + compteur parent

### Contexte & objectif

Boucler via pipeline (sous-shell) et **conserver un compteur** dans le parent.

### Script

```bash
#!/usr/bin/env bash
tmp_count="$(mktemp)"
printf 0 > "$tmp_count"

# Boucle dans un sous-shell : on met à jour un compteur via fichier
find . -type f -name "*.log" -print0 | \
while IFS= read -r -d '' f; do
  # Traitement simulé
  # ex: grep -q "ERROR" "$f" && echo "Erreur dans $f"
  c=$(<"$tmp_count"); c=$((c+1)); printf "%s" "$c" > "$tmp_count"
done

total=$(<"$tmp_count")
rm -f "$tmp_count"
echo "Fichiers .log traités : $total"
```

### Scénario de test

- Créez `touch a.log "b with space.log"`.

- `./exo20.sh` → total = 2.

### Astuces / Pièges / Améliorations

- Piège : la boucle après `|` perd l’état → on persiste dans un **fichier**.

- Amélioration (avancé) : rester dans le shell parent avec **process substitution** :
  
  ```bash
  count=0
  while IFS= read -r -d '' f; do ((count++)); done < <(find . -type f -name "*.log" -print0)
  echo "Total = $count"
  ```

---

### Conseils généraux (utiles partout)

- Quottez systématiquement `"${var}"` et `"${array[@]}"`.

- Pour des **chemins arbitraires**, préférez `find -print0` + `read -d ''` ou `xargs -0`.

- Évitez `for f in $(commande)` si la sortie peut contenir espaces/newlines.

- Pour interrompre proprement, utilisez `trap` (SIGINT/SIGTERM).

- Pour **performances**, `xargs -P` parallélise (mais testez l’idempotence !).

Si tu veux, je peux te livrer **un pack .zip** de ces 20 scripts nommés `exo01.sh`…`exo20.sh`, plus une **fiche-mémo A4**.
