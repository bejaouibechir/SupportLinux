# 1) Panorama des shells (bash/dash/zsh, `/etc/shells`, `chsh`)

###Ex.1 — Identifier le shell **réel** et sa version

**Objectif**: savoir quel shell tourne vraiment.

**Préparer**: rien.

**Étapes**

1. Afficher le binaire réel du shell courant.

2. Afficher le `$SHELL` déclaré.

3. Si `bash`, afficher sa version.

&nbsp;  **Commandes**

```bash
readlink -f /proc/$$/exe

echo "SHELL (env): $SHELL"

bash --version | head -1 || echo "bash non par défaut"
```

**Attendu**: un chemin type `/usr/bin/bash` ou `/usr/bin/dash`, puis le `$SHELL`.

**Pourquoi**: `/proc/$$/exe` dit **ce qui tourne**; `$SHELL` dit **ce qui est configuré** pour login.

### Ex.2 — Lister les shells disponibles

**Objectif**: voir les shells autorisés.

**Préparer**: rien.

**Étapes**

1. Lister `/etc/shells`.

2. Vérifier quelques shells.

&nbsp;  **Commandes**

```bash
cat /etc/shells

command -v bash dash zsh || true
```

**Attendu**: chemins des shells.

**Pourquoi**: on ne peut choisir que des shells présents dans `/etc/shells`.

### Ex.3 — Montrer qu’un script **bash** échoue sous **sh (dash)**

**Objectif**: comprendre la différence `[[ ]]` (bash) vs `[` POSIX.

**Préparer**:

```bash
cat > test_cond.sh <<'EOF'

#!/usr/bin/env bash

s="x"; if [[ "$s" == "x" ]]; then echo OK; fi

EOF

chmod +x test_cond.sh
```

**Étapes**

1. Exécuter avec `sh` (dash).

2. Exécuter normalement (bash via shebang).

&nbsp;  **Commandes**

```bash
sh ./test_cond.sh || echo "Échec sous sh (attendu)"; ./test_cond.sh
```

**Attendu**: échec sous `sh`, “OK” sous bash.

**Pourquoi**: `[[ ]]` n’est pas pris en charge par `dash`.

### Ex.4 — Voir le shell de login **sans changer**

**Objectif**: localiser le shell de l’utilisateur.

**Étapes**

```bash
getent passwd "$USER" | cut -d: -f1,7

echo "Commande de changement (si besoin) : chsh -s /bin/bash"
```

**Attendu**: ligne `user:/bin/bash` par ex.

**Pourquoi**: `getent` lit la base de comptes; `chsh` s’emploie ensuite si nécessaire.

### Ex.5 — Vérifier le shell d’un autre utilisateur

**Objectif**: lecture ciblée.

**Étapes**

```bash
read -r -p "Utilisateur : " U

getent passwd "$U" | cut -d: -f1,7 || echo "Inconnu"
```

**Attendu**: affiche `user:/bin/...` ou “Inconnu”.

**Pourquoi**: pratique pour audit rapide.

---

# 2) tmux (sessions, fenêtres, splits, navigation)

### Ex.1 — Créer → détacher → rattacher une session

**Objectif**: cycle de vie tmux.

**Étapes**

1. Lancer une session nommée.

2. Détacher.

3. Rattacher.

&nbsp;  **Commandes**

```bash
tmux new -s demo           # dans tmux: Ctrl-b d pour détacher

tmux ls

tmux attach -t demo
```

**Attendu**: session `demo` visible/rattachable.

**Pourquoi**: base de l’utilisation multi-sessions.

### Ex.2 — Fenêtres (créer/renommer/naviguer)

**Objectif**: organiser le travail.

**Étapes (dans tmux)**

* `Ctrl-b c` (nouvelle fenêtre)

* `Ctrl-b ,` (renommer)

* `Ctrl-b n`/`Ctrl-b p` (naviguer)

&nbsp; **Attendu**: noms visibles dans la barre.

&nbsp; **Pourquoi**: une session → plusieurs fenêtres thématiques.

### Ex.3 — Splits (panneaux)

**Objectif**: multi-vues simultanées.

**Étapes (dans tmux)**

* `Ctrl-b %` (split vertical)

* `Ctrl-b "` (split horizontal)

* `Ctrl-b` + flèches (naviguer)

&nbsp; **Attendu**: plusieurs panneaux actifs.

&nbsp; **Pourquoi**: comparer commandes/logs en parallèle.

### Ex.4 — Lister et fermer proprement

**Objectif**: maintenir propre.

**Étapes**

```bash
tmux ls

tmux kill-window -t demo:1 || true

tmux kill-server || true
```

**Attendu**: plus de sessions.

**Pourquoi**: éviter des serveurs tmux fantômes.

### Ex.5 — Capturer la sortie d’un panneau

**Objectif**: sauvegarder du texte.

**Étapes (dans tmux)**

* `Ctrl-b :` puis `capture-pane -S -2000`

* `save-buffer /tmp/out.txt`

&nbsp; **Attendu**: `/tmp/out.txt` contient l’historique.

&nbsp; **Pourquoi**: utile pour partager des résultats.

---

# 3) Écrire un script (shebang, exécution, robustesse)

### Ex.1 — “Hello” + strict mode

**Objectif**: squelette fiable.

**Étapes**

```bash
cat > hello.sh <<'EOF'

#!/usr/bin/env bash

set -euo pipefail

echo "Hello ${USER:-inconnu}"

EOF

chmod +x hello.sh; ./hello.sh
```

**Attendu**: “Hello …”.

**Pourquoi**: `set -euo pipefail` évite des erreurs silencieuses.

### Ex.2 — Demander un argument

**Objectif**: valider l’entrée.

**Étapes**

```bash
cat > needarg.sh <<'EOF'

#!/usr/bin/env bash

set -euo pipefail

[ $# -ge 1 ] || { echo "Usage: $0 <fichier>"; exit 1; }

echo "OK: $1"

EOF

chmod +x needarg.sh
```

**Attendu**: message d’usage si manquant.

**Pourquoi**: empêche une exécution ambiguë.

### Ex.3 — Log + écran (tee)

**Objectif**: tracer sans perdre l’affichage.

**Étapes**

```bash
./hello.sh | tee hello.log
```

**Attendu**: écran + `hello.log`.

**Pourquoi**: utile pour rapports et debug.

### Ex.4 — Résoudre un chemin

**Objectif**: éviter les chemins relatifs.

**Étapes**

```bash
cat > abspath.sh <<'EOF'

#!/usr/bin/env bash

set -euo pipefail

[ $# -ge 1 ] || { echo "Usage: $0 <path>"; exit 1; }

realpath -- "$1"

EOF

chmod +x abspath.sh
```

**Attendu**: chemin absolu.

**Pourquoi**: facilite les scripts multi-répertoires.

### Ex.5 — Codes de retour (|| / &&)

**Objectif**: réagir à l’état d’une commande.

**Étapes**

```bash
false || echo "Échec (prévu)"

true  && echo "Réussite"
```

**Attendu**: messages cohérents.

**Pourquoi**: mini-contrôles de flux lisibles.

---

# 4) Variables & environnement

### Ex.1 — Export et héritage

**Objectif**: variable visible par l’enfant.

**Étapes**

```bash
x=2; sh -c 'echo "enfant: x=${x-<unset>}"'

export x; sh -c 'echo "enfant: x=${x-<unset>}"'
```

**Attendu**: `<unset>` puis `2`.

**Pourquoi**: sans `export`, pas d’héritage.

### Ex.2 — Ajouter `~/bin` au PATH (session)

**Objectif**: lancer vos scripts partout.

**Étapes**

```bash
mkdir -p ~/bin

export PATH="$PATH:$HOME/bin"

command -v hello.sh || echo "Ajoutez hello.sh dans ~/bin pour le tester"
```

**Pourquoi**: `PATH` décide où chercher les binaires.

### Ex.3 — Rendre persistant dans `~/.bashrc`

**Objectif**: conserver à la prochaine session.

**Étapes**

```bash
echo 'export PATH="$PATH:$HOME/bin"' >> ~/.bashrc
```

**Attendu**: après nouveau shell, dispo.

**Pourquoi**: `.bashrc` est relu à l’ouverture.

### Ex.4 — Personnaliser le prompt

**Objectif**: prompt utile.

**Étapes**

```bash
PS1='[u@h W]$ '

echo 'PS1="[u@h W]$ "' >> ~/.bashrc
```

**Pourquoi**: repères rapides (user/host/dossier).

### Ex.5 — Charger des variables depuis un fichier

**Objectif**: centraliser les configs.

**Étapes**

```bash
cat > ~/myenv <<'EOF'

export API_URL="https://example.org"

export TIMEOUT=5

EOF

. ~/myenv; echo "$API_URL $TIMEOUT"
```

**Pourquoi**: plus propre que d’éditer le script.

---

# 5) Lecture interactive (`read`)

### Ex.1 — `read -r` (préserver ``)

**Objectif**: ne pas interpréter les backslashes.

**Étapes**

```bash
read -r -p "Chemin: " p; echo "Saisi: $p"
```

**Attendu**: exactement ce que vous tapez.

**Pourquoi**: `-r` désactive l’échappement.

### Ex.2 — Saisie masquée (`-s`)

**Objectif**: mot de passe discret.

**Étapes**

```bash
read -r -s -p "Mot de passe: " pwd; echo; echo "Longueur: ${#pwd}"
```

**Pourquoi**: n’affiche pas la saisie.

### Ex.3 — Valeur par défaut

**Objectif**: accepter “Entrée” sans saisie.

**Étapes**

```bash
read -r -p "Pseudo (defaut bechir): " u; u=${u:-bechir}; echo "Pseudo=$u"
```

**Pourquoi**: `${var:-def}` fixe un fallback.

### Ex.4 — Timeout

**Objectif**: éviter de bloquer.

**Étapes**

```bash
read -r -t 5 -p "Code (5s): " c || echo "Timeout"
```

**Pourquoi**: `-t` borne le temps de lecture.

### Ex.5 — Plusieurs valeurs

**Objectif**: parser deux champs.

**Étapes**

```bash
read -r -p "Ville Pays: " v p; echo "Ville=$v, Pays=$p"
```

**Pourquoi**: split par espace dans deux variables.

---

# 6) Numérique en bash

### Ex.1 — Entiers `declare -i`

**Objectif**: arithmétique sûre.

**Étapes**

```bash
declare -i x=3 y=4 z=0; z=x+y; echo "$z"
```

**Pourquoi**: `declare -i` force le type entier.

### Ex.2 — Pair/impair

**Objectif**: modulo.

**Étapes**

```bash
read -r -p "Nombre: " n; (( n%2==0 )) && echo "Pair" || echo "Impair"
```

**Pourquoi**: `$(( ))` = arithmétique bash.

### Ex.3 — Compteur while

**Objectif**: incrément.

**Étapes**

```bash
i=1; while (( i<=5 )); do echo $i; ((i++)); done
```

**Pourquoi**: contrôle simple et lisible.

### Ex.4 — Comparaison

**Objectif**: if numérique.

**Étapes**

```bash
a=10; b=7; if (( a>b )); then echo "a>b"; else echo "a<=b"; fi
```

**Pourquoi**: `(( ))` gère >, <, ==, etc.

### Ex.5 — Flottants via `awk`

**Objectif**: calcul décimal.

**Étapes**

```bash
echo | awk 'BEGIN{printf "%.2fn", 3.14+2}'
```

**Pourquoi**: bash ne gère pas les floats nativement.

---

# 7) Flux conditionnels

### Ex.1 — If/elif/else

**Objectif**: 3 branches.

**Étapes**

```bash
read -r -p "n: " n

if   (( n<0 )); then echo "negatif"

elif (( n==0 )); then echo "zero"

else                 echo "positif"

fi
```

**Pourquoi**: structure de décision de base.

### Ex.2 — Regex `[[ =~ ]]` (email simple)

**Objectif**: valider un format.

**Étapes**

```bash
read -r -p "email: " e

if [[ "$e" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Za-z]{2,}$ ]]; then echo OK; else echo KO; fi
```

**Pourquoi**: `[[ =~ ]]` offre la regex étendue.

### Ex.3 — `&&` / `||` idiomatiques

**Objectif**: condense un if.

**Étapes**

```bash
[ -f data.txt ] && echo "existe" || touch data.txt
```

**Pourquoi**: lecture rapide, une ligne.

### Ex.4 — `case` (menu)

**Objectif**: choix multi-valeurs.

**Étapes**

```bash
read -r -p "Couleur (rouge/vert/bleu): " c

case "${c,,}" in rouge|vert|bleu) echo "ok";; *) echo "invalide";; esac
```

**Pourquoi**: `case` gère proprement plusieurs motifs.

### Ex.5 — Stopper à la 1re erreur

**Objectif**: démontrer `set -e`.

**Étapes**

```bash
set -e; echo "A"; false; echo "B (jamais affiché)"
```

**Pourquoi**: utile pour pipelines/CI stricts.

---

# 8) Tests de fichiers

### Ex.1 — Fichier/dossier/inexistant

**Objectif**: détecter le type.

**Étapes**

```bash
read -r -p "Chemin: " p

if   [ -d "$p" ]; then echo "dossier"

elif [ -f "$p" ]; then echo "fichier"

else                   echo "inexistant"

fi
```

**Pourquoi**: `-d/-f` couvrent 90% des cas.

### Ex.2 — Droits `-r/-w/-x`

**Objectif**: vérifier l’accès.

**Étapes**

```bash
f=script.sh; printf "r:%s w:%s x:%sn" 

  $([ -r "$f" ]&&echo oui||echo non) 

  $([ -w "$f" ]&&echo oui||echo non) 

  $([ -x "$f" ]&&echo oui||echo non)
```

**Pourquoi**: utile avant d’exécuter.

### Ex.3 — Plus récent `-nt` / plus ancien `-ot`

**Objectif**: sync simple.

**Étapes**

```bash
[ fileA -nt fileB ] && echo "A plus récent" || echo "B plus récent/égal"
```

**Pourquoi**: base des scripts de synchronisation.

### Ex.4 — Fichier non vide `-s`

**Objectif**: éviter des traitements inutiles.

**Étapes**

```bash
[ -s data.txt ] && echo "non vide" || echo "vide"
```

**Pourquoi**: tri rapide des entrées.

### Ex.5 — Dossier lisible/inscriptible

**Objectif**: prérequis E/S.

**Étapes**

```bash
d=out; [ -d "$d" ] && [ -w "$d" ] && [ -r "$d" ] && echo "OK" || echo "KO"
```

**Pourquoi**: sécurise les scripts “qui écrivent”.

---

# 9) Boucles

### Ex.1 — `for` sur fichiers

**Objectif**: itérer `*.txt`.

**Étapes**

```bash
for f in *.txt; do echo "$f"; done
```

**Pourquoi**: itérations simples par glob.

### Ex.2 — `while read` (préserver ligne)

**Objectif**: lire un fichier proprement.

**Étapes**

```bash
while IFS= read -r line; do echo "$line"; done < data.txt
```

**Pourquoi**: `-r` ne casse pas les ``.

### Ex.3 — `until` (jusqu’à vrai)

**Objectif**: boucle inverse.

**Étapes**

```bash
i=1; until (( i>3 )); do echo $i; ((i++)); done
```

**Pourquoi**: s’arrête quand condition vraie.

### Ex.4 — Style C

**Objectif**: compteur classique.

**Étapes**

```bash
for ((i=0;i<5;i++)); do echo $i; done
```

**Pourquoi**: lisible pour séquences numériques.

### Ex.5 — Tableaux

**Objectif**: itérer un array.

**Étapes**

```bash
arr=(alpha beta gamma)

for x in "${arr[@]}"; do echo "$x"; done
```

**Pourquoi**: `${arr[@]}` respecte les espaces.

---

# 10) Fonctions

### Ex.1 — Fonction + paramètres

**Objectif**: factoriser un calcul.

**Étapes**

```bash
add(){ echo $(( $1 + $2 )); }

add 5 3
```

**Pourquoi**: réutilisable dans le script.

### Ex.2 — Variables locales

**Objectif**: éviter la pollution globale.

**Étapes**

```bash
var="global"; f(){ local var="local"; echo "in:$var"; }; f; echo "out:$var"

``**

**Pourquoi**: `local` confine dans la fonction.



### Ex.3 — Retour par code (`return`)

**Objectif**: signaler un état.  

**Étapes**

```bash

is_even(){ (( $1%2==0 )) && return 0 || return 1; }

is_even 4; echo $?

is_even 5; echo $?
```

**Pourquoi**: `$?` chaînable avec `&&`/`||`.

### Ex.4 — Wrapper de commande

**Objectif**: étendre `ls`.

**Étapes**

```bash
ls(){ command ls -lh --color=auto "$@"; }

ls .
```

**Pourquoi**: garde l’original via `command`.

### Ex.5 — Deux fonctions en pipeline (+pipefail)

**Objectif**: pipelines sûrs.

**Étapes**

```bash
set -o pipefail

gen(){ printf "AnBnCn"; }

fil(){ grep -E 'A|C'; }

gen | fil
```

**Pourquoi**: `pipefail` fait remonter les erreurs du pipeline.
