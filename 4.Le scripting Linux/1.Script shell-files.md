# Existence & Type

## 1) `-e` — le chemin existe (fichier, dossier, lien, etc.)

### Préparation

```bash
mkdir -p /tmp/demo-if && touch /tmp/demo-if/config.yaml
```

### Script

```bash
#!/usr/bin/env bash
FILE="/tmp/demo-if/config.yaml"

# Teste si le chemin existe (quel que soit le type)
if [ -e "$FILE" ]; then
  echo "[OK] $FILE existe."
else
  echo "[KO] $FILE n'existe pas."
fi
```

### Test

```
./test-e.sh
# [OK] /tmp/demo-if/config.yaml existe.
```

---

## 2) `-f` — fichier régulier

### Préparation

```bash
echo "hello" > /tmp/demo-if/reg.txt
mkdir -p /tmp/demo-if/dir
```

### Script

```bash
#!/usr/bin/env bash
P="/tmp/demo-if/reg.txt"
if [ -f "$P" ]; then
  echo "[OK] $P est un fichier régulier."
else
  echo "[KO] $P n'est pas un fichier régulier."
fi
```

### Test

```
./test-f.sh
# [OK] /tmp/demo-if/reg.txt est un fichier régulier.
```

---

## 3) `-d` — répertoire

### Préparation

```bash
mkdir -p /tmp/demo-if/logs
```

### Script

```bash
#!/usr/bin/env bash
D="/tmp/demo-if/logs"
if [ -d "$D" ]; then
  echo "[OK] $D est un répertoire."
else
  echo "[KO] $D n'est pas un répertoire."
fi
```

### Test

```
./test-d.sh
# [OK] /tmp/demo-if/logs est un répertoire.
```

---

## 4) `-s` — fichier existe et taille > 0

### Préparation

```bash
: > /tmp/demo-if/empty.txt         # vide
echo "ligne" > /tmp/demo-if/full.txt # non vide
```

### Script

```bash
#!/usr/bin/env bash
for F in /tmp/demo-if/empty.txt /tmp/demo-if/full.txt; do
  if [ -s "$F" ]; then
    echo "[OK] $F existe et n'est pas vide."
  else
    echo "[KO] $F est vide ou n'existe pas."
  fi
done
```

### Test

```
./test-s.sh
# [KO] .../empty.txt est vide ou n'existe pas.
# [OK] .../full.txt existe et n'est pas vide.
```

---

## 5) `-L` (ou `-h`) — lien symbolique

### Préparation

```bash
echo "v1" > /tmp/demo-if/orig.txt
ln -s /tmp/demo-if/orig.txt /tmp/demo-if/symlink.txt
```

### Script

```bash
#!/usr/bin/env bash
S="/tmp/demo-if/symlink.txt"
if [ -L "$S" ]; then
  echo "[OK] $S est un lien symbolique."
fi
```

### Test

```
./test-L.sh
# [OK] .../symlink.txt est un lien symbolique.
```

---

## 6) `-p` — FIFO (tube nommé)

### Préparation

```bash
mkfifo /tmp/demo-if/pipe.fifo
```

### Script

```bash
#!/usr/bin/env bash
P="/tmp/demo-if/pipe.fifo"
if [ -p "$P" ]; then
  echo "[OK] $P est une FIFO."
fi
```

### Test

```
./test-p.sh
# [OK] .../pipe.fifo est une FIFO.
```

---

## 7) `-b` — fichier spécial bloc

> Selon la machine, un bloc courant est souvent `/dev/loop0` ou un disque (ex. `/dev/sda`).  
> Exemple robuste : on testera l’un des deux si présent.

### Préparation

*(rien à créer)*

### Script

```bash
#!/usr/bin/env bash
for CAND in /dev/loop0 /dev/sda; do
  if [ -e "$CAND" ]; then
    if [ -b "$CAND" ]; then
      echo "[OK] $CAND est un périphérique bloc."
    else
      echo "[KO] $CAND existe mais n'est pas bloc."
    fi
  fi
done
```

### Test

```
./test-b.sh
# [OK] /dev/loop0 est un périphérique bloc.   (selon machine)
```

---

## 8) `-c` — fichier spécial caractère

### Préparation

*(utilisons `/dev/null`, toujours présent)*

### Script

```bash
#!/usr/bin/env bash
CH="/dev/null"
if [ -c "$CH" ]; then
  echo "[OK] $CH est un périphérique caractère."
fi
```

### Test

```
./test-c.sh
# [OK] /dev/null est un périphérique caractère.
```

---

## 9) `-S` — socket (Unix)

### Préparation (crée un socket Unix via Python – pas besoin d’install)

Dans un terminal 1 :

```bash
python3 - <<'PY'
import socket, os, time
p = "/tmp/demo-if/app.sock"
try:
    os.unlink(p)
except FileNotFoundError:
    pass
s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
s.bind(p)
print("Socket prêt:", p)
time.sleep(10)  # garde le socket 10s
PY
```

### Script (dans un terminal 2 pendant les 10s)

```bash
#!/usr/bin/env bash
SO="/tmp/demo-if/app.sock"
if [ -S "$SO" ]; then
  echo "[OK] $SO est un socket Unix."
else
  echo "[KO] $SO absent ou pas un socket."
fi
```

### Test

```
./test-S.sh
# [OK] .../app.sock est un socket Unix.
```

---

# Permissions

## 10) `-r` — lisible

### Préparation

```bash
echo "secret" > /tmp/demo-if/readme.txt
chmod 400 /tmp/demo-if/readme.txt    # lecture seule propriétaire
```

### Script

```bash
#!/usr/bin/env bash
F="/tmp/demo-if/readme.txt"
if [ -r "$F" ]; then
  echo "[OK] $F est lisible par $(whoami)."
else
  echo "[KO] $F n'est pas lisible par $(whoami)."
fi
```

### Test

```
./test-r.sh
# [OK] ... lisible par <user>
```

---

## 11) `-w` — inscriptible

### Préparation

```bash
echo "lock" > /tmp/demo-if/write.txt
chmod 200 /tmp/demo-if/write.txt  # écriture seule propriétaire
```

### Script

```bash
#!/usr/bin/env bash
F="/tmp/demo-if/write.txt"
if [ -w "$F" ]; then
  echo "[OK] $F est inscriptible (modifiable)."
else
  echo "[KO] $F n'est pas inscriptible."
fi
```

### Test

```
./test-w.sh
# [OK] ...
```

---

## 12) `-x` — exécutable

### Préparation

```bash
echo -e '#!/usr/bin/env bash\necho "run"' > /tmp/demo-if/run.sh
chmod +x /tmp/demo-if/run.sh
```

### Script

```bash
#!/usr/bin/env bash
X="/tmp/demo-if/run.sh"
if [ -x "$X" ]; then
  echo "[OK] $X est exécutable. Lançons-le:"
  "$X"
else
  echo "[KO] $X n'est pas exécutable."
fi
```

### Test

```
./test-x.sh
# [OK] ...
# run
```

---

# Propriété

## 13) `-O` — possédé par l’utilisateur courant

### Préparation

```bash
touch /tmp/demo-if/owner.txt     # appartient au user courant
```

### Script

```bash
#!/usr/bin/env bash
F="/tmp/demo-if/owner.txt"
if [ -O "$F" ]; then
  echo "[OK] $F appartient à $(whoami)."
else
  echo "[KO] $F n'appartient pas à $(whoami)."
fi
```

### Test

```
./test-O.sh
# [OK] ...
```

> (Contre-exemple : si vous faites `sudo chown root:root /tmp/demo-if/owner.txt`, le test deviendra KO.)

---

## 14) `-G` — même groupe que l’utilisateur courant

### Préparation

```bash
touch /tmp/demo-if/group.txt
# met le groupe primaire courant (par défaut déjà le cas)
chgrp "$(id -gn)" /tmp/demo-if/group.txt
```

### Script

```bash
#!/usr/bin/env bash
F="/tmp/demo-if/group.txt"
if [ -G "$F" ]; then
  echo "[OK] $F a le même groupe que l'utilisateur courant ($(id -gn))."
else
  echo "[KO] groupe différent."
fi
```

### Test

```
./test-G.sh
# [OK] ...
```

---

## 15) `-N` — modifié depuis la dernière lecture

> Interprétation : “modifié depuis la dernière **lecture par ce shell**”.

### Préparation & Script

```bash
#!/usr/bin/env bash
F="/tmp/demo-if/fresh.txt"
echo "v1" > "$F"

# 1) On "lit" le fichier (met à jour l'heure de dernier accès pour ce shell)
cat "$F" >/dev/null

# 2) On le modifie après lecture
sleep 1
echo "v2" >> "$F"

# 3) Test -N : vrai si modifié depuis lecture
if [ -N "$F" ]; then
  echo "[OK] $F a été modifié depuis la dernière lecture."
else
  echo "[KO] $F n'a pas été modifié depuis lecture."
fi
```

### Test

```
./test-N.sh
# [OK] ...
```

---

# Comparaisons entre fichiers (binaires avec `test`/`[`])

## 16) `file1 -nt file2` — `file1` plus récent que `file2`

### Préparation

```bash
echo A > /tmp/demo-if/a.txt
sleep 1
echo B > /tmp/demo-if/b.txt
```

### Script

```bash
#!/usr/bin/env bash
A="/tmp/demo-if/a.txt" B="/tmp/demo-if/b.txt"
if [ "$B" -nt "$A" ]; then
  echo "[OK] $B est plus récent que $A."
else
  echo "[KO] $B n'est pas plus récent que $A."
fi
```

### Test

```
./test-nt.sh
# [OK] ...
```

---

## 17) `file1 -ot file2` — `file1` plus ancien que `file2`

### Script

```bash
#!/usr/bin/env bash
A="/tmp/demo-if/a.txt" B="/tmp/demo-if/b.txt"
if [ "$A" -ot "$B" ]; then
  echo "[OK] $A est plus ancien que $B."
else
  echo "[KO] $A n'est pas plus ancien que $B."
fi
```

### Test

```
./test-ot.sh
# [OK] ...
```

---

## 18) `file1 -ef file2` — mêmes inode (même fichier)

> Cas typique : **lien physique (hard link)**.

### Préparation

```bash
echo "origin" > /tmp/demo-if/origin.txt
ln /tmp/demo-if/origin.txt /tmp/demo-if/hardlink.txt   # lien physique
```

### Script

```bash
#!/usr/bin/env bash
O="/tmp/demo-if/origin.txt" H="/tmp/demo-if/hardlink.txt"
if [ "$O" -ef "$H" ]; then
  echo "[OK] $O et $H désignent le même fichier (même inode)."
else
  echo "[KO] fichiers différents."
fi
```

### Test

```
./test-ef.sh
# [OK] ...
```

---

# Conseils & pièges courants

- **Espaces obligatoires** : `if [ -f "$F" ]; then` (et pas `if [-f"$F"];then`).

- **Toujours citer les variables** : `"$F"` évite les erreurs si le chemin contient des espaces.

- **Privilégier des chemins sous `/tmp`** pour vos labos afin d’éviter les permissions root.

- **`-N`** dépend de la **lecture par le shell courant** : l’ordre des opérations est important.

- **Bloc/Caractère** : utilisez des entrées de `/dev` existantes (`/dev/null`, `/dev/loop0`, `/dev/sda` selon machine).

# Partie II Test de combinaisons d'operateurs

Parfait. Voici une sélection de **combinaisons d’opérateurs** (utiles au quotidien) avec des mini-scripts commentés.  
Chaque bloc est autonome : copiez-le dans un `.sh`, rendez-le exécutable (`chmod +x ...`) et lancez-le.

---

## 1) Lancer un script **seulement s’il est régulier, exécutable et non vide**

```bash
#!/usr/bin/env bash
APP="/tmp/demo/app.sh"

# Préparation démo
mkdir -p /tmp/demo
printf '#!/usr/bin/env bash\necho OK\n' > "$APP"
chmod +x "$APP"

# Conditions combinées : fichier régulier (-f), exécutable (-x), non vide (-s)
if [ -f "$APP" ] && [ -x "$APP" ] && [ -s "$APP" ]; then
  echo "→ Lancement de $APP"
  "$APP"
else
  echo "→ $APP n'est pas prêt (fichier/exécution/taille)."
fi
```

---

## 2) Sauvegarder **seulement si la source est un répertoire** et la destination **inscriptible**

```bash
#!/usr/bin/env bash
SRC="/tmp/demo/src"
DST="/tmp/demo/backup.tar"

# Préparation
mkdir -p "$SRC"
echo "un fichier" > "$SRC/f.txt"
: > "$DST"          # crée le fichier si besoin

# -d : SRC est un répertoire ; -w : DST inscriptible (même dossier)
if [ -d "$SRC" ] && [ -w "$(dirname "$DST")" ]; then
  tar -cf "$DST" -C "$SRC" .
  echo "→ Archive créée : $DST"
else
  echo "→ Préconditions non satisfaites (SRC dossier / DST inscriptible)."
fi
```

---

## 3) **Rotation de logs** : si le log existe et **n’est pas vide**, on le renomme

```bash
#!/usr/bin/env bash
LOG="/tmp/demo/app.log"

# Préparation
mkdir -p /tmp/demo
echo "ligne" >> "$LOG"

# -s : log existe et taille > 0
if [ -s "$LOG" ]; then
  mv "$LOG" "$LOG.$(date +%F_%H%M%S)"
  echo "→ Log pivoté."
else
  echo "→ Rien à faire (log absent ou vide)."
fi
```

---

## 4) Déployer un fichier **seulement si la source est plus récente** que la destination

```bash
#!/usr/bin/env bash
SRC="/tmp/demo/build.bin"
DST="/tmp/demo/release.bin"

# Préparation
echo "v1" > "$DST"
sleep 1
echo "v2" > "$SRC"

# -nt : SRC plus récent que DST
if [ "$SRC" -nt "$DST" ]; then
  cp -f "$SRC" "$DST"
  echo "→ Copie car $SRC est plus récent que $DST."
else
  echo "→ Pas de mise à jour (DST à jour)."
fi
```

---

## 5) Copier si **destination manquante OU source plus récente**

```bash
#!/usr/bin/env bash
SRC="/tmp/demo/app.cfg"
DST="/tmp/demo/app.cfg.dist"

# Préparation
echo "cfg=v1" > "$SRC" ; : > "$DST" ; sleep 1 ; echo "cfg=v2" > "$SRC"

# Combinaison OR : destination absente (-e négation) OU source -nt destination
if [ ! -e "$DST" ] || [ "$SRC" -nt "$DST" ]; then
  cp "$SRC" "$DST"
  echo "→ $DST mis à jour."
else
  echo "→ $DST déjà présent et à jour."
fi
```

---

## 6) **Résoudre un lien symbolique** et vérifier que la **cible est un fichier régulier**

```bash
#!/usr/bin/env bash
LINK="/tmp/demo/conf.ln"
TARGET="/tmp/demo/conf.yaml"

# Préparation
echo "key=val" > "$TARGET"
ln -sf "$TARGET" "$LINK"

# -L : le chemin est un lien ; on résout puis on teste -f sur la cible
if [ -L "$LINK" ] && [ -f "$(readlink -f "$LINK")" ]; then
  echo "→ $LINK pointe vers un fichier régulier valide."
else
  echo "→ Lien invalide ou cible non fichier."
fi
```

---

## 7) **Détecter un lien symbolique orphelin**

```bash
#!/usr/bin/env bash
LINK="/tmp/demo/broken.ln"

# Préparation
ln -sf /tmp/demo/absent.txt "$LINK"  # cible qui n'existe pas

# -L lien ; ! -e cible résolue → orphelin
if [ -L "$LINK" ] && [ ! -e "$(readlink -f "$LINK")" ]; then
  echo "→ $LINK est orphelin (cible absente)."
fi
```

---

## 8) **Vérifier une socket** Unix avant de s’y connecter

```bash
#!/usr/bin/env bash
SOCK="/tmp/demo/app.sock"

# Préparation (crée une socket 8s)
python3 - <<'PY' &
import socket, os, time
p="/tmp/demo/app.sock"
try: os.unlink(p)
except FileNotFoundError: pass
s=socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
s.bind(p); print("socket prête:", p); time.sleep(8)
PY

# -S : socket présente ; -r : lisible (visibilité/ACL)
if [ -S "$SOCK" ] && [ -r "$SOCK" ]; then
  echo "→ Socket détectée, tentative de connexion (exemple)."
else
  echo "→ Socket indisponible ou droits insuffisants."
fi
```

---

## 9) **Sécuriser un exécutable** : seulement si **appartient à l’utilisateur** et **pas encore exécutable**

```bash
#!/usr/bin/env bash
BIN="/tmp/demo/tool.sh"

# Préparation
printf '#!/usr/bin/env bash\necho tool\n' > "$BIN"

# -O : possession par l’utilisateur courant ; ! -x : pas exécutable
if [ -O "$BIN" ] && [ ! -x "$BIN" ]; then
  chmod u+x "$BIN"
  echo "→ Droits d'exécution accordés au propriétaire."
fi
```

---

## 10) **Vérifier groupe** + exécution : exécuter **seulement si même groupe** et **exécutable**

```bash
#!/usr/bin/env bash
BIN="/tmp/demo/groupcmd.sh"

# Préparation
printf '#!/usr/bin/env bash\necho groupe OK\n' > "$BIN"
chmod 750 "$BIN"
chgrp "$(id -gn)" "$BIN"

# -G : même groupe que l’utilisateur ; -x : exécutable
if [ -G "$BIN" ] && [ -x "$BIN" ]; then
  "$BIN"
else
  echo "→ Conditions groupe/exécution non satisfaites."
fi
```

---

## 11) **Guarde de création** : créer un répertoire **seulement s’il n’existe pas**

```bash
#!/usr/bin/env bash
D="/tmp/demo/newdir"

# ! -d : n’est pas un dossier → on crée
if [ ! -d "$D" ]; then
  mkdir -p "$D" && echo "→ Dossier créé: $D"
else
  echo "→ Déjà présent: $D"
fi
```

---

## 12) **Suppression sûre** : supprimer **uniquement** un fichier **régulier**, **appartenant** à l’utilisateur

```bash
#!/usr/bin/env bash
F="/tmp/demo/to-delete.txt"

# Préparation
echo "tmp" > "$F"

# -f : fichier régulier ; -O : possédé par utilisateur
if [ -f "$F" ] && [ -O "$F" ]; then
  rm -f -- "$F"
  echo "→ Fichier supprimé en sécurité."
else
  echo "→ Refusé (pas un régulier ou pas votre fichier)."
fi
```

---

## 13) **Recharger config** si le fichier **existe**, **lisible** et **modifié depuis la dernière lecture**

```bash
#!/usr/bin/env bash
CFG="/tmp/demo/app.cfg"

# Préparation
echo "v1" > "$CFG"
cat "$CFG" >/dev/null  # "lecture" de référence
sleep 1
echo "v2" >> "$CFG"    # modification post-lecture

# -e existe ; -r lisible ; -N modifié depuis dernière lecture (dans ce shell)
if [ -e "$CFG" ] && [ -r "$CFG" ] && [ -N "$CFG" ]; then
  echo "→ Rechargement config (changé depuis lecture précédente)."
else
  echo "→ Pas de rechargement."
fi
```

---

## 14) **Comparer deux artefacts** : agir si A **plus ancien** que B **ET** A **existe**

```bash
#!/usr/bin/env bash
A="/tmp/demo/a.bin"
B="/tmp/demo/b.bin"

# Préparation
echo A > "$A"; sleep 1; echo B > "$B"

# -e A existe ; A -ot B : A est plus ancien que B
if [ -e "$A" ] && [ "$A" -ot "$B" ]; then
  echo "→ $A est plus ancien que $B (pensez à reconstruire A)."
else
  echo "→ A à jour ou absent."
fi
```

---

## 15) **Vérifier un FIFO** **et** la **permission d’écriture** avant d’émettre

```bash
#!/usr/bin/env bash
P="/tmp/demo/pipe.fifo"

# Préparation
mkfifo -m 660 "$P" 2>/dev/null || true
# Astuce : dans un autre terminal, lancez: `cat "$P"` pour consommer

# -p : FIFO ; -w : inscriptible
if [ -p "$P" ] && [ -w "$P" ]; then
  echo "message" > "$P"
  echo "→ Message écrit dans la FIFO."
else
  echo "→ FIFO absente ou non inscriptible."
fi
```

---

## 16) **Stratégie “safe write”** : écrire **seulement si** le fichier **existe** et **nous appartient** **ET** que l’on a l’accès écriture

```bash
#!/usr/bin/env bash
T="/tmp/demo/owned.txt"

# Préparation
echo "init" > "$T"

# -e existe ; -O possédé ; -w inscriptible
if [ -e "$T" ] && [ -O "$T" ] && [ -w "$T" ]; then
  echo "append" >> "$T"
  echo "→ Écrit en sécurité."
else
  echo "→ Interdit (existence/ownership/écriture non réunis)."
fi
```

---

### Tips pratiques pour composer proprement

- **Préférez** `[` … `]` enchaînés avec `&&` / `||` plutôt que `-a` / `-o` (peu portables).

- **Toujours citer** vos chemins : `"$F"`.

- **Découpez** les tests : plusieurs `[ ... ]` lisibles > un seul test illisible.

- Les tests `-N`, `-nt`, `-ot` **dépendent des timestamps** : insérez parfois `sleep 1` pour la démo.
