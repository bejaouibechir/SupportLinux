# Atelier 8 — Vérification et réparation de tables (CHECK TABLE`, `REPAIR TABLE)

## But de l’atelier

Apprendre à vérifier l’intégrité des tables MariaDB et à réparer celles qui présentent des erreurs.  
Cet atelier introduit deux commandes essentielles :

- `CHECK TABLE` : détecte les erreurs de structure ou d’index.

- `REPAIR TABLE` : tente de corriger automatiquement certains problèmes.

---

## Étapes de l’atelier

1. Créer une table de test.

2. Vérifier la table avec `CHECK TABLE`.

3. Introduire volontairement un problème (simulation).

4. Réparer la table avec `REPAIR TABLE`.

5. Vérifier à nouveau après réparation.

---

## Démarches (commandes commentées)

### 1. Créer une table de test

```sql
CREATE DATABASE IF NOT EXISTS maintenance_demo;
USE maintenance_demo;

CREATE TABLE logs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    message VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO logs (message) VALUES
('Démarrage service A'),
('Connexion utilisateur X'),
('Erreur 404 sur endpoint Y');
```

---

### 2. Vérifier la table

```sql
CHECK TABLE logs;
```

Résultat attendu :

```
Table   Op     Msg_type Msg_text
maintenance_demo.logs check status OK
```

---

### 3. Simuler un problème

En pratique, les corruptions surviennent après un crash ou une coupure brutale.  
Pour la démo, on peut forcer un problème en utilisant `myisamchk` (uniquement si la table est en moteur MyISAM).

Conversion volontaire :

```sql
ALTER TABLE logs ENGINE=MyISAM;
```

Puis en shell :

```bash
sudo myisamchk --destroy /var/lib/mysql/maintenance_demo/logs.MYI
```

Cela détruit l’index, simulant une corruption.

---

### 4. Réparer la table

Retour dans MariaDB :

```sql
REPAIR TABLE logs;
```

Résultat attendu :

```
Table   Op      Msg_type   Msg_text
maintenance_demo.logs repair status OK
```

---

### 5. Vérifier à nouveau

```sql
CHECK TABLE logs;
```

La table doit maintenant être signalée comme correcte.

---

## Résultats attendus

- `CHECK TABLE` permet de diagnostiquer l’état d’une table.

- Après corruption simulée, `CHECK TABLE` doit montrer un problème.

- `REPAIR TABLE` restaure l’intégrité.

- `CHECK TABLE` après réparation doit revenir à l’état OK.

---

Très bien. Nous restons dans le **chapitre Maintenance et optimisation** et passons à l’atelier suivant.

---

# Analyse et optimisation des tables (`ANALYZE TABLE`, `OPTIMIZE TABLE`)

## But de l’atelier

Comprendre comment améliorer les performances de MariaDB en recalculant les statistiques et en optimisant l’espace de stockage :

- `ANALYZE TABLE` : met à jour les statistiques utilisées par l’optimiseur de requêtes.

- `OPTIMIZE TABLE` : défragmente et réorganise les données, libérant de l’espace disque.

---

## Étapes de l’atelier

1. Créer une table et y insérer beaucoup de données.

2. Lancer une requête simple et observer le plan d’exécution.

3. Supprimer une partie des données.

4. Exécuter `ANALYZE TABLE` et `OPTIMIZE TABLE`.

5. Constater la différence dans l’espace et les performances.

---

## Démarches (commandes commentées)

### 1. Créer une table avec beaucoup de données

```sql
CREATE DATABASE IF NOT EXISTS opt_demo;
USE opt_demo;

CREATE TABLE ventes (
    id INT AUTO_INCREMENT PRIMARY KEY,
    produit VARCHAR(100),
    quantite INT,
    prix DECIMAL(10,2)
);

-- Insérer 50 000 lignes
INSERT INTO ventes (produit, quantite, prix)
SELECT CONCAT('Produit_', FLOOR(RAND()*100)),
       FLOOR(RAND()*10),
       ROUND(RAND()*100,2)
FROM information_schema.tables t1,
     information_schema.tables t2
LIMIT 50000;
```

---

### 2. Exécuter une requête et voir le plan d’exécution

```sql
EXPLAIN SELECT * FROM ventes WHERE produit='Produit_5';
```

Résultat attendu :

- Si les statistiques ne sont pas à jour, l’optimiseur peut mal choisir son plan d’accès.

---

### 3. Supprimer des données

```sql
DELETE FROM ventes WHERE id <= 20000;
```

À ce stade :

- Beaucoup d’espace est encore occupé physiquement bien que les lignes soient supprimées.

---

### 4. Exécuter les commandes de maintenance

```sql
-- Recalcul des statistiques
ANALYZE TABLE ventes;

-- Réorganisation et libération d’espace
OPTIMIZE TABLE ventes;
```

---

### 5. Vérifier le résultat

- Espace disque :

```sql
SHOW TABLE STATUS LIKE 'ventes'\G
```

Comparer les colonnes `Data_length` et `Index_length` avant et après.

- Plan d’exécution :

```sql
EXPLAIN SELECT * FROM ventes WHERE produit='Produit_5';
```

L’optimiseur devrait mieux utiliser les index après `ANALYZE TABLE`.

---

## Résultats attendus

- `ANALYZE TABLE` met à jour les statistiques et améliore le choix du plan d’exécution.

- `OPTIMIZE TABLE` réduit l’espace disque utilisé après suppression de nombreuses lignes.

- Les requêtes sur la table deviennent plus rapides et plus fiables.

---

Nous restons dans le **chapitre Maintenance et optimisation** et poursuivons avec un atelier centré sur les **index et l’analyse des performances**.

---

# Utilisation des index et `EXPLAIN`

## But de l’atelier

Apprendre à :

1. Comprendre le rôle des index pour accélérer les recherches.

2. Créer et supprimer des index.

3. Utiliser `EXPLAIN` pour analyser le plan d’exécution d’une requête.

4. Constater l’impact d’un index sur les performances.

---

## Étapes de l’atelier

1. Créer une table sans index spécifique.

2. Effectuer une recherche et analyser le plan avec `EXPLAIN`.

3. Ajouter un index et refaire la recherche.

4. Comparer les résultats.

5. Supprimer l’index et observer à nouveau.

---

## Démarches (commandes commentées)

### 1. Créer une table de test

```sql
CREATE DATABASE IF NOT EXISTS perf_demo;
USE perf_demo;

CREATE TABLE clients (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nom VARCHAR(100),
    email VARCHAR(100),
    ville VARCHAR(50)
);

-- Insérer 50 000 enregistrements
INSERT INTO clients (nom, email, ville)
SELECT CONCAT('Nom_', FLOOR(RAND()*10000)),
       CONCAT('user', FLOOR(RAND()*10000), '@exemple.com'),
       CONCAT('Ville_', FLOOR(RAND()*100))
FROM information_schema.tables t1,
     information_schema.tables t2
LIMIT 50000;
```

---

### 2. Recherche sans index

```sql
EXPLAIN SELECT * FROM clients WHERE email='user1234@exemple.com';
```

Résultat attendu :

- Dans la colonne `type`, on voit `ALL`, ce qui signifie un **scan complet de la table**.

- La colonne `rows` indique que des dizaines de milliers de lignes sont examinées.

---

### 3. Ajouter un index

```sql
CREATE INDEX idx_email ON clients(email);
```

---

### 4. Recherche avec index

```sql
EXPLAIN SELECT * FROM clients WHERE email='user1234@exemple.com';
```

Résultat attendu :

- La colonne `type` doit indiquer `ref` ou `const` (utilisation de l’index).

- La colonne `rows` doit être proche de 1.

- La requête est beaucoup plus rapide.

---

### 5. Supprimer l’index

```sql
DROP INDEX idx_email ON clients;
```

Vérification :

```sql
EXPLAIN SELECT * FROM clients WHERE email='user1234@exemple.com';
```

On revient à un scan complet de la table (`ALL`).

---

## Résultats attendus

- Sans index, une recherche spécifique parcourt toute la table.

- Avec un index, MariaDB accède directement à la donnée, réduisant le nombre de lignes scannées.

- `EXPLAIN` permet de vérifier si une requête utilise un index et d’optimiser les performances.

## Corriger des problèmes d'intégrité

Apprendre à détecter et corriger les problèmes d'intégrité dans les tables MariaDB en utilisant `CHECK TABLE` et `REPAIR TABLE`.



## Mise en situation

Vous êtes administrateur d'une base de données. Après une coupure de courant, certains utilisateurs signalent des erreurs lors de l'accès à une table. Vous devez vérifier l'intégrité de cette table et la réparer si nécessaire.

---

## 1. Préparation de l'environnement

**Étape 1 :** Créez une base de données et une table pour les tests.

Connectez-vous à MariaDB :

```bash
mysql -u root -p
```

Dans l'invite MariaDB, exécutez :

```sql
-- Création de la base de données si elle n'existe pas
CREATE DATABASE IF NOT EXISTS maintenance_demo;
USE maintenance_demo;

-- Création d'une table de logs
CREATE TABLE logs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    message VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insertion de quelques données de test
INSERT INTO logs (message) VALUES
('Démarrage service A'),
('Connexion utilisateur X'),
('Erreur 404 sur endpoint Y');
```

**Vérification :**

```sql
SELECT * FROM logs;
```

---

## 2. Vérification de l'intégrité d'une table

**Étape 2 :** Utilisez `CHECK TABLE` pour examiner l'état de la table.

```sql
CHECK TABLE logs;
```

**Résultat attendu :**

```
+-------------------------+-------+----------+----------+
| Table                   | Op    | Msg_type | Msg_text |
+-------------------------+-------+----------+----------+
| maintenance_demo.logs | check | status   | OK       |
+-------------------------+-------+----------+----------+
```

**Que signifie ce résultat ?**

- `Msg_type` : `status` indique le type de message.
- `Msg_text` : `OK` signifie que la table est saine.

---

## 3. Simulation d'une corruption de table

**Note :** Dans la réalité, une corruption peut survenir après un crash système ou une panne de courant. Pour les besoins de l'exercice, nous allons simuler une corruption en utilisant l'outil `myisamchk` sur une table MyISAM.

**Étape 3.1 :** Convertissez la table au moteur MyISAM (si elle ne l'est pas déjà).

```sql
ALTER TABLE logs ENGINE=MyISAM;
```

**Étape 3.2 :** Quittez MariaDB et revenez au terminal.

```sql
exit;
```

**Étape 3.3 :** Utilisez `myisamchk` pour endommager l'index de la table.

```bash
# Arrêtez le service MariaDB pour pouvoir manipuler les fichiers
sudo systemctl stop mariadb

# Allez dans le répertoire des données de la base
cd /var/lib/mysql/maintenance_demo

# Détruisez l'index de la table logs (simulation de corruption)
sudo myisamchk --destroy logs.MYI

# Redémarrez MariaDB
sudo systemctl start mariadb
```

**Attention :** Cette manipulation est destructrice et ne doit être faite que dans un environnement de test.

**Étape 3.4 :** Reconnectez-vous à MariaDB et vérifiez l'état de la table.

```bash
mysql -u root -p
```

```sql
USE maintenance_demo;
CHECK TABLE logs;
```

**Résultat attendu (exemple d'erreur) :**

```
+-------------------------+-------+----------+----------------------------------------+
| Table                   | Op    | Msg_type | Msg_text                               |
+-------------------------+-------+----------+----------------------------------------+
| maintenance_demo.logs | check | error    | Table 'logs' is marked as crashed      |
+-------------------------+-------+----------+----------------------------------------+
```

**Que s'est-il passé ?**
La table est maintenant marquée comme corrompue.

---

## 4. Réparation de la table

**Étape 4 :** Utilisez `REPAIR TABLE` pour tenter de réparer la table.

```sql
REPAIR TABLE logs;
```

**Résultat attendu :**

```
+-------------------------+--------+----------+------------------------------------------+
| Table                   | Op     | Msg_type | Msg_text                                 |
+-------------------------+--------+----------+------------------------------------------+
| maintenance_demo.logs | repair | status   | OK                                       |
+-------------------------+--------+----------+------------------------------------------+
```

**Explication :** `REPAIR TABLE` tente de réparer la table. Si la réparation réussit, le statut sera `OK`.

---

## 5. Vérification après réparation

**Étape 5 :** Vérifiez à nouveau l'intégrité de la table.

```sql
CHECK TABLE logs;
```

**Résultat attendu :**

```
+-------------------------+-------+----------+----------+
| Table                   | Op    | Msg_type | Msg_text |
+-------------------------+-------+----------+----------+
| maintenance_demo.logs | check | status   | OK       |
+-------------------------+-------+----------+----------+
```

**Étape supplémentaire :** Reconvertissez la table en InnoDB (si vous le souhaitez).

```sql
ALTER TABLE logs ENGINE=InnoDB;
```

---

## Exercice pratique

**Problème :** 
Une table nommée `clients` dans la base `gestion_stock` est suspectée d'être corrompue. Vérifiez son intégrité et réparez-la si nécessaire.

**Données de départ :**

```sql
-- Si la table n'existe pas, créez-la
USE gestion_stock;
CREATE TABLE IF NOT EXISTS clients (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nom VARCHAR(100),
    email VARCHAR(100)
) ENGINE=MyISAM;  -- Utilisez MyISAM pour pouvoir simuler la corruption

-- Insérez quelques données
INSERT INTO clients (nom, email) VALUES
('Alice Dupont', 'alice@example.com'),
('Bob Martin', 'bob@example.com');
```

**Votre mission :**

1. Vérifiez l'état de la table `clients`.
2. Simulez une corruption en utilisant `myisamchk` (comme montré précédemment).
3. Vérifiez à nouveau la table et observez l'erreur.
4. Réparez la table.
5. Confirmez que la réparation a fonctionné.

**Solution :**

1. **Vérification initiale :**
   
   ```sql
   CHECK TABLE clients;
   ```

2. **Simulation de corruption :**
   
   - Quittez MariaDB.
   - Arrêtez MariaDB.
   - Allez dans le répertoire `/var/lib/mysql/gestion_stock`.
   - Exécutez : `sudo myisamchk --destroy clients.MYI`
   - Redémarrez MariaDB.

3. **Vérification après corruption :**
   
   ```sql
   CHECK TABLE clients;
   ```
   
   Notez le message d'erreur.

4. **Réparation :**
   
   ```sql
   REPAIR TABLE clients;
   ```

5. **Vérification finale :**
   
   ```sql
   CHECK TABLE clients;
   ```

**Pour aller plus loin :**

- Essayez de réparer une table InnoDB. Notez que `REPAIR TABLE` ne fonctionne pas pour InnoDB. Pour InnoDB, il faut utiliser d'autres méthodes, comme restaurer à partir d'une sauvegarde.
- Consultez la documentation MariaDB pour connaître les options de `CHECK TABLE` (comme `CHECK TABLE ... FOR UPGRADE`).

---

## En résumé

- `CHECK TABLE` permet de vérifier l'intégrité d'une table.
- `REPAIR TABLE` tente de réparer une table corrompue (surtout pour MyISAM).
- Pour InnoDB, privilégiez la restauration à partir d'une sauvegarde en cas de corruption.
- Testez régulièrement l'intégrité de vos tables importantes.
