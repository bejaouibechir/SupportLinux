# Atelier 8 — Vérification et réparation de tables (`CHECK TABLE`, `REPAIR TABLE`)

## But de l’atelier

Apprendre à vérifier l’intégrité des tables MariaDB et à réparer celles qui présentent des erreurs.  
Cet atelier introduit deux commandes essentielles :

- `CHECK TABLE` : détecte les erreurs de structure ou d’index.

- `REPAIR TABLE` : tente de corriger automatiquement certains problèmes.

---

## Étapes de l’atelier

1. Créer une table de test.

2. Vérifier la table avec `CHECK TABLE`.

3. Introduire volontairement un problème (simulation).

4. Réparer la table avec `REPAIR TABLE`.

5. Vérifier à nouveau après réparation.

---

## Démarches (commandes commentées)

### 1. Créer une table de test

```sql
CREATE DATABASE IF NOT EXISTS maintenance_demo;
USE maintenance_demo;

CREATE TABLE logs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    message VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO logs (message) VALUES
('Démarrage service A'),
('Connexion utilisateur X'),
('Erreur 404 sur endpoint Y');
```

---

### 2. Vérifier la table

```sql
CHECK TABLE logs;
```

Résultat attendu :

```
Table   Op     Msg_type Msg_text
maintenance_demo.logs check status OK
```

---

### 3. Simuler un problème

En pratique, les corruptions surviennent après un crash ou une coupure brutale.  
Pour la démo, on peut forcer un problème en utilisant `myisamchk` (uniquement si la table est en moteur MyISAM).

Conversion volontaire :

```sql
ALTER TABLE logs ENGINE=MyISAM;
```

Puis en shell :

```bash
sudo myisamchk --destroy /var/lib/mysql/maintenance_demo/logs.MYI
```

Cela détruit l’index, simulant une corruption.

---

### 4. Réparer la table

Retour dans MariaDB :

```sql
REPAIR TABLE logs;
```

Résultat attendu :

```
Table   Op      Msg_type   Msg_text
maintenance_demo.logs repair status OK
```

---

### 5. Vérifier à nouveau

```sql
CHECK TABLE logs;
```

La table doit maintenant être signalée comme correcte.

---

## Résultats attendus

- `CHECK TABLE` permet de diagnostiquer l’état d’une table.

- Après corruption simulée, `CHECK TABLE` doit montrer un problème.

- `REPAIR TABLE` restaure l’intégrité.

- `CHECK TABLE` après réparation doit revenir à l’état OK.

---

Très bien. Nous restons dans le **chapitre Maintenance et optimisation** et passons à l’atelier suivant.

---

# Analyse et optimisation des tables (`ANALYZE TABLE`, `OPTIMIZE TABLE`)

## But de l’atelier

Comprendre comment améliorer les performances de MariaDB en recalculant les statistiques et en optimisant l’espace de stockage :

- `ANALYZE TABLE` : met à jour les statistiques utilisées par l’optimiseur de requêtes.

- `OPTIMIZE TABLE` : défragmente et réorganise les données, libérant de l’espace disque.

---

## Étapes de l’atelier

1. Créer une table et y insérer beaucoup de données.

2. Lancer une requête simple et observer le plan d’exécution.

3. Supprimer une partie des données.

4. Exécuter `ANALYZE TABLE` et `OPTIMIZE TABLE`.

5. Constater la différence dans l’espace et les performances.

---

## Démarches (commandes commentées)

### 1. Créer une table avec beaucoup de données

```sql
CREATE DATABASE IF NOT EXISTS opt_demo;
USE opt_demo;

CREATE TABLE ventes (
    id INT AUTO_INCREMENT PRIMARY KEY,
    produit VARCHAR(100),
    quantite INT,
    prix DECIMAL(10,2)
);

-- Insérer 50 000 lignes
INSERT INTO ventes (produit, quantite, prix)
SELECT CONCAT('Produit_', FLOOR(RAND()*100)),
       FLOOR(RAND()*10),
       ROUND(RAND()*100,2)
FROM information_schema.tables t1,
     information_schema.tables t2
LIMIT 50000;
```

---

### 2. Exécuter une requête et voir le plan d’exécution

```sql
EXPLAIN SELECT * FROM ventes WHERE produit='Produit_5';
```

Résultat attendu :

- Si les statistiques ne sont pas à jour, l’optimiseur peut mal choisir son plan d’accès.

---

### 3. Supprimer des données

```sql
DELETE FROM ventes WHERE id <= 20000;
```

À ce stade :

- Beaucoup d’espace est encore occupé physiquement bien que les lignes soient supprimées.

---

### 4. Exécuter les commandes de maintenance

```sql
-- Recalcul des statistiques
ANALYZE TABLE ventes;

-- Réorganisation et libération d’espace
OPTIMIZE TABLE ventes;
```

---

### 5. Vérifier le résultat

- Espace disque :

```sql
SHOW TABLE STATUS LIKE 'ventes'\G
```

Comparer les colonnes `Data_length` et `Index_length` avant et après.

- Plan d’exécution :

```sql
EXPLAIN SELECT * FROM ventes WHERE produit='Produit_5';
```

L’optimiseur devrait mieux utiliser les index après `ANALYZE TABLE`.

---

## Résultats attendus

- `ANALYZE TABLE` met à jour les statistiques et améliore le choix du plan d’exécution.

- `OPTIMIZE TABLE` réduit l’espace disque utilisé après suppression de nombreuses lignes.

- Les requêtes sur la table deviennent plus rapides et plus fiables.

---

Nous restons dans le **chapitre Maintenance et optimisation** et poursuivons avec un atelier centré sur les **index et l’analyse des performances**.

---

# Utilisation des index et `EXPLAIN`

## But de l’atelier

Apprendre à :

1. Comprendre le rôle des index pour accélérer les recherches.

2. Créer et supprimer des index.

3. Utiliser `EXPLAIN` pour analyser le plan d’exécution d’une requête.

4. Constater l’impact d’un index sur les performances.

---

## Étapes de l’atelier

1. Créer une table sans index spécifique.

2. Effectuer une recherche et analyser le plan avec `EXPLAIN`.

3. Ajouter un index et refaire la recherche.

4. Comparer les résultats.

5. Supprimer l’index et observer à nouveau.

---

## Démarches (commandes commentées)

### 1. Créer une table de test

```sql
CREATE DATABASE IF NOT EXISTS perf_demo;
USE perf_demo;

CREATE TABLE clients (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nom VARCHAR(100),
    email VARCHAR(100),
    ville VARCHAR(50)
);

-- Insérer 50 000 enregistrements
INSERT INTO clients (nom, email, ville)
SELECT CONCAT('Nom_', FLOOR(RAND()*10000)),
       CONCAT('user', FLOOR(RAND()*10000), '@exemple.com'),
       CONCAT('Ville_', FLOOR(RAND()*100))
FROM information_schema.tables t1,
     information_schema.tables t2
LIMIT 50000;
```

---

### 2. Recherche sans index

```sql
EXPLAIN SELECT * FROM clients WHERE email='user1234@exemple.com';
```

Résultat attendu :

- Dans la colonne `type`, on voit `ALL`, ce qui signifie un **scan complet de la table**.

- La colonne `rows` indique que des dizaines de milliers de lignes sont examinées.

---

### 3. Ajouter un index

```sql
CREATE INDEX idx_email ON clients(email);
```

---

### 4. Recherche avec index

```sql
EXPLAIN SELECT * FROM clients WHERE email='user1234@exemple.com';
```

Résultat attendu :

- La colonne `type` doit indiquer `ref` ou `const` (utilisation de l’index).

- La colonne `rows` doit être proche de 1.

- La requête est beaucoup plus rapide.

---

### 5. Supprimer l’index

```sql
DROP INDEX idx_email ON clients;
```

Vérification :

```sql
EXPLAIN SELECT * FROM clients WHERE email='user1234@exemple.com';
```

On revient à un scan complet de la table (`ALL`).

---

## Résultats attendus

- Sans index, une recherche spécifique parcourt toute la table.

- Avec un index, MariaDB accède directement à la donnée, réduisant le nombre de lignes scannées.

- `EXPLAIN` permet de vérifier si une requête utilise un index et d’optimiser les performances.

---
