# Atelier - ETL avec CDC (Change Data Capture)





# 1. Contexte & objectifs

## 1.1. Pourquoi une technique ETL bas√©e sur CDC ?

Avec les deux premi√®res techniques :

- **SQL natif + proc√©dures stock√©es** ‚Üí tr√®s efficace pour des batchs planifi√©s.

- **Python + Pandas** ‚Üí tr√®s flexible pour transformer et charger des volumes.

Le probl√®me commun :  
üëâ on travaille souvent **en batch** (toutes les heures, toutes les nuits‚Ä¶), donc **pas r√©ellement en temps r√©el**.

La technique CDC (Change Data Capture) repose sur l‚Äôid√©e suivante :

- MariaDB √©crit **toutes les modifications** (INSERT, UPDATE, DELETE) dans les **binlogs**.

- **MaxScale** lit ces binlogs, les convertit en un format exploitable (AVRO/JSON).

- Un **consommateur** (Data Warehouse, autre instance MariaDB, script ETL‚Ä¶) lit ce flux et applique les changements.

**Cas principal vis√© ici :**

> **Transf√©rer en continu les changements d‚Äôune base MariaDB ‚Äútransactionnelle‚Äù (OLTP) vers une autre base MariaDB (ou Data Warehouse) sur une autre instance.**

**Cas secondaires :**

- Export **CDC ‚Üí fichiers JSON** (pour archives, reporting, ingestion par d‚Äôautres outils).

- Rejeu de ces fichiers vers une autre base (pattern ETL en plusieurs temps).

---

# 2. Architecture CDC autour de MariaDB + MaxScale

## 2.1. Vue d‚Äôensemble

Architecture simplifi√©e :

- **Serveur 1 : MariaDB Source**
  
  - Base `shop_tx` (OLTP : commandes, clients, produits).
  
  - Binlogs activ√©s en **ROW**.

- **Serveur 2 : MaxScale**
  
  - Lit les binlogs du serveur 1 via le **Binlogrouter**. ([MariaDB](https://mariadb.com/docs/maxscale/reference/maxscale-routers/maxscale-binlogrouter?utm_source=chatgpt.com "MaxScale Binlogrouter - MariaDB"))
  
  - Convertit les √©v√©nements binlog en fichiers **AVRO/JSON** via l‚Äô**Avro Router**. ([MariaDB](https://mariadb.com/resources/blog/data-streaming-with-mariadb-maxscale/?utm_source=chatgpt.com "Data Streaming with MariaDB MaxScale"))
  
  - Expose un **flux CDC** (protocole CDC) consultable par des clients. ([MariaDB](https://mariadb.com/docs/maxscale/reference/maxscale-protocols/maxscale-change-data-capture-cdc-protocol?utm_source=chatgpt.com "MaxScale Change Data Capture (CDC) Protocol - MariaDB"))

- **Serveur 3 : Cible (MariaDB ou autre)**
  
  - Par exemple : `shop_dw` (Data Warehouse ou base de reporting).
  
  - Un **client CDC** lit les √©v√©nements ‚Üí applique les changements (INSERT/UPDATE/DELETE).

---

# 3. Pr√©paration du serveur MariaDB Source (OLTP)

> Objectif : Activer les binlogs en mode **ROW**, pr√©requis de MaxScale CDC.

### 3.1. Activer les binlogs en mode row

Cr√©er le fichier `/etc/mysql/conf.d/cdc_source.cnf` :

```ini
# /etc/mysql/conf.d/cdc_source.cnf
# Configuration minimale pour activer le CDC c√¥t√© MariaDB source

[mysqld]
# Active les binlogs (journal des changements)
log_bin = mariadb-bin

# Identifiant unique pour la r√©plication
server_id = 1

# Format de binlog : √©v√©nements au niveau des lignes (requis pour CDC)
binlog_format = ROW

# Optionnel : conserver les binlogs assez longtemps
expire_logs_days = 7

# Nom par d√©faut du fichier binlog
log_bin_basename = /var/lib/mysql/mariadb-bin
```

Red√©marrer MariaDB :

```bash
sudo systemctl restart mariadb
```

V√©rifier que les binlogs sont bien activ√©s :

```sql
SHOW VARIABLES LIKE 'log_bin';
SHOW VARIABLES LIKE 'binlog_format';
```

On doit voir `log_bin = ON` et `binlog_format = ROW`.

---

### 3.2. Cr√©er un utilisateur d√©di√© √† MaxScale (lecture binlog)

Se connecter sur la **base source** :

```sql
CREATE USER 'maxscale'@'%' IDENTIFIED BY 'Mot2PasseMaxScale!';

GRANT REPLICATION SLAVE, REPLICATION CLIENT
ON *.* TO 'maxscale'@'%';

FLUSH PRIVILEGES;
```

Cet utilisateur servira √† **MaxScale** pour lire les binlogs en tant que ‚Äúreplica logique‚Äù.

---

# 4. Installation & configuration de MaxScale pour CDC

> Objectif : Configurer MaxScale pour :
> 
> - se connecter √† MariaDB source,
> 
> - consommer les binlogs,
> 
> - g√©n√©rer des fichiers AVRO/JSON,
> 
> - exposer un flux CDC consommable par un client.

*(On consid√®re ici un serveur Linux d√©di√© √† MaxScale, par exemple `maxscale-host`.)*

## 4.1. D√©finir le serveur MariaDB source dans MaxScale

Cr√©er le fichier `/etc/maxscale.cnf` *(ou adapter celui existant)*.

### 4.1.1. Bloc serveur + monitor

```ini
# /etc/maxscale.cnf
# Configuration minimale pour MaxScale + CDC

[maxscale]
threads=auto

#
# 1) D√©claration de la base MariaDB source
#
[server1]
type=server
address=192.168.10.10      # Adresse IP ou hostname du serveur MariaDB source
port=3306
protocol=mariadbclient

#
# 2) Monitor pour surveiller l'√©tat de server1
#
[MariaDB-Monitor]
type=monitor
module=mariadbmon
servers=server1
user=maxscale
password=Mot2PasseMaxScale!
monitor_interval=5s
```

- `server1` : d√©crit la base MariaDB source.

- `MariaDB-Monitor` : permet √† MaxScale de savoir si `server1` est UP/DOWN.

---

## 4.2. Activer le Binlogrouter et l‚ÄôAvro Router

Le **Binlogrouter** r√©cup√®re les binlogs du serveur source. ([MariaDB](https://mariadb.com/docs/maxscale/reference/maxscale-routers/maxscale-binlogrouter?utm_source=chatgpt.com "MaxScale Binlogrouter - MariaDB"))  
L‚Äô**Avro Router** convertit ces binlogs en fichiers AVRO/JSON. ([MariaDB](https://mariadb.com/resources/blog/data-streaming-with-mariadb-maxscale/?utm_source=chatgpt.com "Data Streaming with MariaDB MaxScale"))

### 4.2.1. Service Binlogrouter

Ajouter dans `/etc/maxscale.cnf` :

```ini
#
# 3) Service Binlogrouter : lit les binlogs de server1
#
[Binlog-Service]
type=service
router=binlogrouter
servers=server1
user=maxscale
password=Mot2PasseMaxScale!

# R√©pertoire local o√π MaxScale stockera une copie des binlogs
binlogdir=/var/lib/maxscale/binlogs
```

- Ce service se comporte comme un ‚Äúbinlog server‚Äù interm√©diaire.

---

### 4.2.2. Service Avro Router

Ce service lit les binlogs localement et produit des fichiers AVRO/JSON par table.

```ini
#
# 4) Service Avro Router : convertit les binlogs en fichiers AVRO
#
[Avro-Service]
type=service
router=avrorouter
source=Binlog-Service

# R√©pertoire o√π seront g√©n√©r√©s les fichiers AVRO
avrodir=/var/lib/maxscale/avro

# Nom du sch√©ma √† suivre (optionnel, ici uniquement la base shop_tx)
match=shop_tx%
```

- `source=Binlog-Service` : Avro lit les √©v√©nements fournis par le Binlogrouter.

- `match=shop_tx%` : on limite le CDC √† la base `shop_tx` (optionnel mais conseill√©).

---

## 4.3. Activer le protocole CDC

Pour que des clients externes puissent consommer les fichiers AVRO/JSON, MaxScale expose un **service CDC**. ([MariaDB](https://mariadb.com/docs/maxscale/reference/maxscale-protocols/maxscale-change-data-capture-cdc-protocol?utm_source=chatgpt.com "MaxScale Change Data Capture (CDC) Protocol - MariaDB"))

Ajouter :

```ini
#
# 5) Service CDC : expose un flux de changements (JSON/AVRO)
#
[CDC-Service]
type=service
router=cdcrouter
source=Avro-Service
```

Puis d√©finir un **listener** (port d‚Äô√©coute) :

```ini
#
# 6) Listener CDC : permet aux clients de se connecter
#
[CDC-Listener]
type=listener
service=CDC-Service
protocol=CDC
port=4001
```

---

## 4.4. D√©marrer et v√©rifier MaxScale

Red√©marrer MaxScale :

```bash
sudo systemctl restart maxscale
```

V√©rifier l‚Äô√©tat :

```bash
maxctrl list services
maxctrl list servers
```

Tu dois voir les services `Binlog-Service`, `Avro-Service`, `CDC-Service` en √©tat `Running` (ou √©quivalent).

---

# 5. Pr√©parer un exemple de table ‚Äúsuivie‚Äù par le CDC

> Objectif : Avoir une table simple dont on va suivre les changements en temps r√©el.

Sur la base **source** `shop_tx` :

```sql
CREATE DATABASE IF NOT EXISTS shop_tx;
USE shop_tx;

CREATE TABLE commandes (
  id INT AUTO_INCREMENT PRIMARY KEY,
  client VARCHAR(100),
  montant DECIMAL(10,2),
  statut VARCHAR(20),
  date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

√Ä partir de maintenant, **tout INSERT/UPDATE/DELETE** sur `shop_tx.commandes` sera √©crit dans le binlog ‚Üí lu par MaxScale ‚Üí converti en AVRO/JSON.

---

# 6. Client CDC simple (Python) pour consommer les √©v√©nements

> Objectif : Montrer comment consommer le flux CDC JSON depuis MaxScale,  
> afin de :
> 
> - soit l‚Äôafficher (demo),
> 
> - soit le rejouer vers une autre instance MariaDB (ETL continu).

MaxScale fournit un **exemple de client CDC en Python** dans sa documentation et son repo. ([MariaDB](https://mariadb.com/docs/maxscale/reference/maxscale-protocols/maxscale-change-data-capture-cdc-protocol?utm_source=chatgpt.com "MaxScale Change Data Capture (CDC) Protocol - MariaDB"))  
Ici, on va cr√©er une version simplifi√©e et comment√©e pour la d√©mo.

## 6.1. Pr√©paration de l‚Äôenvironnement Python

Installer Python 3 et les d√©pendances minimales :

```bash
pip install requests
```

(*Le client CDC ‚Äúofficiel‚Äù utilise parfois des libs sp√©cifiques, mais pour l‚Äôatelier on reste tr√®s simple.*)

---

## 6.2. Client CDC minimal pour afficher les changements

Cr√©er le fichier `cdc_client_simple.py` :

```python
# cdc_client_simple.py
# --------------------
# Client CDC simplifi√© pour se connecter √† MaxScale
# et afficher les changements sous forme de JSON.
#
# Hypoth√®ses :
# - MaxScale √©coute sur le port 4001 pour le protocole CDC
# - On suit la base shop_tx et la table commandes
#
# Remarque : le vrai client CDC officiel propose plus d'options :
# - reprise depuis un GTID donn√©
# - filtrage par table, etc.

import socket
import json

HOST = "maxscale-host"   # Nom ou IP du serveur MaxScale
PORT = 4001              # Port du CDC-Listener (cf. maxscale.cnf)


def main():
    # Cr√©ation d'une connexion TCP simple vers le listener CDC
    with socket.create_connection((HOST, PORT)) as sock:
        # Exemple de demande simple : on demande le flux pour shop_tx.commandes
        # La syntaxe exacte peut varier selon la version de MaxScale.
        # Ici on suppose un protocole texte simplifi√© pour illustrer.
        #
        # Dans un vrai client, tu utilises la librairie CDC officielle,
        # mais pour l'atelier on illustre le principe :
        #
        #   - envoyer une "subscription" sur base.table
        #   - lire en boucle les messages (format JSON)
        #
        request = "REGISTER shop_tx commandes\n"
        sock.sendall(request.encode("utf-8"))

        print("Client CDC connect√©. En attente d'√©v√©nements...\n")

        # Lis en continu les messages envoy√©s par MaxScale
        buffer = b""
        while True:
            data = sock.recv(4096)
            if not data:
                print("Connexion ferm√©e par le serveur CDC.")
                break

            buffer += data

            # On suppose que chaque √©v√©nement est sur une ligne s√©par√©e
            while b"\n" in buffer:
                line, buffer = buffer.split(b"\n", 1)
                if not line.strip():
                    continue

                try:
                    event = json.loads(line.decode("utf-8"))
                except json.JSONDecodeError:
                    print("Message non JSON :", line)
                    continue

                # Affichage du contenu de l'√©v√©nement CDC
                print("=== √âv√©nement CDC re√ßu ===")
                print(json.dumps(event, indent=2, ensure_ascii=False))
                print()


if __name__ == "__main__":
    main()
```

> ‚ö†Ô∏è **Important** :  
> Le protocole CDC r√©el est plus structur√© que ce pseudo protocole `REGISTER shop_tx commandes`.  
> Pour un environnement de production, il faut s‚Äôappuyer sur la doc officielle et/ou le client Python fourni par MariaDB MaxScale. ([MariaDB](https://mariadb.com/docs/maxscale/reference/maxscale-protocols/maxscale-change-data-capture-cdc-protocol?utm_source=chatgpt.com "MaxScale Change Data Capture (CDC) Protocol - MariaDB"))  
> Ici on cherche √† **montrer la logique ETL** : un flux d‚Äô√©v√©nements JSON consomm√© par un client.

---

# 7. Cas principal : transfert continu entre deux instances MariaDB

Maintenant qu‚Äôon a le flux CDC disponible, on peut :

1. Lire les √©v√©nements JSON en continu.

2. Pour chaque √©v√©nement, **appliquer le changement** sur la base cible `shop_dw` (autre instance MariaDB).

## 7.1. Pr√©parer la base cible `shop_dw` sur une autre instance

Sur l‚Äôinstance MariaDB cible (par exemple `192.168.10.20`) :

```sql
CREATE DATABASE IF NOT EXISTS shop_dw;
USE shop_dw;

CREATE TABLE commandes_dw (
  id INT PRIMARY KEY,
  client VARCHAR(100),
  montant DECIMAL(10,2),
  statut VARCHAR(20),
  date_creation TIMESTAMP
);
```

- Sch√©ma volontairement proche de `shop_tx.commandes`.

- On va appliquer en continu les changements sous forme de **UPSERT** (INSERT ou UPDATE).

---

## 7.2. Client CDC qui rejoue les changements vers la base cible

Cr√©er le fichier `cdc_to_dw.py` :

```python
# cdc_to_dw.py
# ------------
# Client CDC qui lit les √©v√©nements depuis MaxScale
# et les applique sur une instance MariaDB cible (shop_dw.commandes_dw).
#
# On illustre la logique ETL :
#   CDC -> JSON -> application sur la base cible.
#
# Remarque : la structure exacte des √©v√©nements JSON d√©pend de la configuration
# Avro/CDC. Ici, on suppose un format simplifi√© du style :
# {
#   "type": "insert" | "update" | "delete",
#   "table": "shop_tx.commandes",
#   "data": { "id": 1, "client": "...", ... }
# }

import socket
import json
import mysql.connector


HOST = "maxscale-host"
PORT = 4001

DW_CONFIG = {
    "host": "192.168.10.20",   # Instance cible
    "port": 3306,
    "user": "etl_user",
    "password": "Mot2PasseETL!",
    "database": "shop_dw",
}


def apply_event_to_dw(conn, event: dict):
    """
    Applique un √©v√©nement CDC (insert/update/delete)
    sur la table shop_dw.commandes_dw.
    """
    ev_type = event.get("type")
    table = event.get("table")
    row = event.get("data") or {}

    # On se limite √† la table commandes
    if table != "shop_tx.commandes":
        return

    cursor = conn.cursor()

    if ev_type == "insert" or ev_type == "update":
        # UPSERT simple : si la cl√© existe, on met √† jour
        sql = """
        INSERT INTO commandes_dw (id, client, montant, statut, date_creation)
        VALUES (%s, %s, %s, %s, %s)
        ON DUPLICATE KEY UPDATE
          client = VALUES(client),
          montant = VALUES(montant),
          statut = VALUES(statut),
          date_creation = VALUES(date_creation)
        """
        params = (
            row.get("id"),
            row.get("client"),
            row.get("montant"),
            row.get("statut"),
            row.get("date_creation"),
        )
        cursor.execute(sql, params)

    elif ev_type == "delete":
        sql = "DELETE FROM commandes_dw WHERE id = %s"
        params = (row.get("id"),)
        cursor.execute(sql, params)

    conn.commit()
    cursor.close()


def main():
    # Connexion √† la base cible
    dw_conn = mysql.connector.connect(**DW_CONFIG)

    # Connexion au service CDC de MaxScale
    with socket.create_connection((HOST, PORT)) as sock:
        request = "REGISTER shop_tx commandes\n"
        sock.sendall(request.encode("utf-8"))

        print("Client CDC->DW connect√©. En attente d'√©v√©nements...\n")

        buffer = b""
        while True:
            data = sock.recv(4096)
            if not data:
                print("Connexion CDC ferm√©e.")
                break

            buffer += data

            while b"\n" in buffer:
                line, buffer = buffer.split(b"\n", 1)
                if not line.strip():
                    continue

                try:
                    event = json.loads(line.decode("utf-8"))
                except json.JSONDecodeError:
                    print("Message non JSON :", line)
                    continue

                print("√âv√©nement CDC :", event)
                apply_event_to_dw(dw_conn, event)

    dw_conn.close()


if __name__ == "__main__":
    main()
```

---

## 7.3. Comment tester le flux CDC ‚Äúend-to-end‚Äù

1. V√©rifier que :
   
   - MariaDB source (`shop_tx`) tourne avec binlogs activ√©s.
   
   - MaxScale est d√©marr√© (`maxctrl list services`).
   
   - MariaDB cible (`shop_dw`) est accessible.

2. Lancer le client CDC‚ÜíDW :
   
   ```bash
   python cdc_to_dw.py
   ```

3. Sur la base **source** `shop_tx`, ex√©cuter :
   
   ```sql
   USE shop_tx;
   
   INSERT INTO commandes (client, montant, statut)
   VALUES ('Client A', 120.50, 'NOUVELLE');
   
   UPDATE commandes
   SET statut = 'PAYEE'
   WHERE client = 'Client A';
   
   DELETE FROM commandes
   WHERE client = 'Client A';
   ```

4. C√¥t√© client `cdc_to_dw.py`, tu dois voir les √©v√©nements appara√Ætre :
   
   - `type: insert`
   
   - `type: update`
   
   - `type: delete`

5. Sur la base **cible** `shop_dw` :
   
   ```sql
   SELECT * FROM commandes_dw;
   ```
   
   - Apr√®s l‚ÄôINSERT ‚Üí une ligne pour `Client A`.
   
   - Apr√®s l‚ÄôUPDATE ‚Üí m√™me ligne avec `statut = 'PAYEE'`.
   
   - Apr√®s le DELETE ‚Üí plus de ligne pour `Client A`.

Tu viens de mettre en place un **ETL continu** entre deux instances MariaDB bas√© sur **CDC** (Change Data Capture).

---

# 8. Cas secondaire : CDC ‚Üí fichiers JSON (logs d‚Äô√©v√©nements)

Une fois que le flux JSON est disponible, on peut facilement :

- **Rediriger la sortie** du client vers un fichier :
  
  ```bash
  python cdc_client_simple.py >> cdc_events.log
  ```

- Utiliser un autre script pour :
  
  - parser `cdc_events.log`,
  
  - g√©n√©rer des **fichiers journaliers**,
  
  - les compresser,
  
  - les stocker dans un data lake ou un stockage objet.

Ce pattern est utile si tu veux :

- garder un **historique des changements**,

- rejouer des √©v√©nements apr√®s coup,

- alimenter plusieurs cibles √† partir d‚Äôun m√™me flux CDC.

---

# 9. Bilan : quand choisir la technique CDC ?

**Points forts :**

- **Quasi temps r√©el** : les changements sont propag√©s d√®s qu‚Äôils sont commis. ([MariaDB](https://mariadb.com/resources/blog/data-streaming-with-mariadb-maxscale/?utm_source=chatgpt.com "Data Streaming with MariaDB MaxScale"))

- Tr√®s adapt√© pour :
  
  - synchroniser une base OLTP vers un data warehouse,
  
  - alimenter des syst√®mes d‚Äôanalytics (Kafka, Spark, ColumnStore),
  
  - r√©duire la charge des gros batchs nocturnes.

**Limites :**

- Mise en place plus **complexe** (MaxScale, binlogs, services CDC).

- N√©cessite une bonne **gouvernance** :
  
  - gestion des sch√©mas,
  
  - compatibilit√© des versions,
  
  - surveillance de MaxScale.

---

### Am√©liorations

- enrichir ce sc√©nario avec **Kafka** (MaxScale ‚Üí KafkaCDC ‚Üí consommateurs multiples), ou
