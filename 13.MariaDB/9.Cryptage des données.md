# Atelier -- Protection des données avec le chiffrement

## Objectif pratique

Apprendre à mettre en place et gérer le chiffrement des données au repos (at-rest encryption) dans MariaDB pour protéger les informations sensibles stockées sur disque.

---

## Mise en situation

Vous êtes administrateur d'une base de données contenant des informations sensibles (données clients, informations médicales, données financières). Votre entreprise doit se conformer au RGPD et aux standards de sécurité. Vous allez implémenter le chiffrement des données au repos pour empêcher l'accès aux données en cas de vol ou de copie non autorisée des fichiers.

---

## Étape 1 : Comprendre le chiffrement au repos

### Qu'est-ce que le chiffrement au repos ?

Le chiffrement "at-rest" protège les données stockées sur le disque dur. Même si quelqu'un copie les fichiers de la base de données, il ne pourra pas lire les données sans la clé de chiffrement.

### Différents niveaux de chiffrement dans MariaDB :

1. **Chiffrement des tables** : Chiffre les fichiers `.ibd` (données InnoDB)
2. **Chiffrement des logs** : Chiffre les fichiers de redo log
3. **Chiffrement des binlogs** : Chiffre les fichiers de réplication

---

## Étape 2 : Vérification des prérequis

Connectez-vous à MariaDB et vérifiez la version et les plugins disponibles :

```sql
-- Vérifier la version de MariaDB
SELECT VERSION();

-- Vérifier le support du chiffrement InnoDB
SHOW VARIABLES LIKE '%innodb_encrypt%';

-- Vérifier les plugins de chiffrement disponibles
SHOW PLUGINS;

-- Vérifier si le plugin file_key_management est disponible
SELECT PLUGIN_NAME, PLUGIN_STATUS 
FROM INFORMATION_SCHEMA.PLUGINS 
WHERE PLUGIN_NAME LIKE '%encrypt%' OR PLUGIN_NAME LIKE '%key%';
```

**Important** : MariaDB 10.1 ou supérieure est recommandée pour une bonne prise en charge du chiffrement.

---

## Étape 3 : Préparation de l'environnement

### 3.1 Création d'un répertoire sécurisé pour les clés

```bash
# Créer un répertoire avec des permissions restreintes
sudo mkdir -p /etc/mysql/encryption
sudo chmod 700 /etc/mysql/encryption
sudo chown mysql:mysql /etc/mysql/encryption
```

### 3.2 Génération de la clé maîtresse

```bash
# Générer une clé aléatoire de 256 bits (32 octets)
sudo openssl rand -hex 32 > /etc/mysql/encryption/master_key.txt

# Afficher les premiers caractères de la clé (pour vérification)
sudo head -c 20 /etc/mysql/encryption/master_key.txt && echo "..."
```

---

## Étape 4 : Configuration du chiffrement

### 4.1 Édition du fichier de configuration

```bash
# Ouvrir le fichier de configuration principal
sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf
```

### 4.2 Ajouter la configuration de chiffrement

Ajoutez ces lignes dans la section `[mysqld]` :

```
# Activation du plugin de gestion des clés
plugin_load_add = file_key_management

# Chemin vers le fichier de clés chiffrées
file_key_management_filename = /etc/mysql/encryption/keyfile.enc

# Chemin vers la clé pour déchiffrer le fichier de clés
file_key_management_filekey = FILE:/etc/mysql/encryption/master_key.txt

# Options de chiffrement InnoDB
innodb_encrypt_tables = ON
innodb_encryption_threads = 4
innodb_encryption_rotate_key_age = 1

# Chiffrement des logs
innodb_encrypt_log = ON
innodb_encryption_rotate_key_age = 1

# Chiffrement des binlogs (optionnel mais recommandé)
encrypt_binlog = ON
encrypt_tmp_files = ON

# Algorithme de chiffrement (AES-256 par défaut)
innodb_encryption_algorithm = aes_cbc
```

### 4.3 Explication des paramètres :

- `innodb_encrypt_tables = ON` : Active le chiffrement pour toutes les nouvelles tables
- `innodb_encryption_threads` : Nombre de threads pour le chiffrement/déchiffrement
- `encrypt_binlog = ON` : Chiffre les fichiers de réplication
- `innodb_encryption_algorithm` : Algorithme utilisé (aes_cbc, aes_ctr, etc.)

---

## Étape 5 : Création du fichier de clés de tables

### 5.1 Créer un fichier de clés chiffré

```bash
# Créer le fichier de clés de tables
sudo mariadb-key-management \
  --write-keyfile \
  --file-keyfile /etc/mysql/encryption/keyfile.enc \
  --encryption-keyfile /etc/mysql/encryption/master_key.txt
```

### 5.2 Vérifier les permissions

```bash
# Vérifier et ajuster les permissions
sudo chmod 600 /etc/mysql/encryption/*
sudo chown mysql:mysql /etc/mysql/encryption/*
```

---

## Étape 6 : Redémarrage et test de la configuration

### 6.1 Redémarrer MariaDB

```bash
# Redémarrer le service
sudo systemctl restart mariadb

# Vérifier qu'il démarre correctement
sudo systemctl status mariadb
```

### 6.2 Vérifier la configuration active

```sql
-- Vérifier que le plugin est chargé
SHOW PLUGINS LIKE 'file_key_management%';

-- Vérifier les variables de chiffrement
SHOW VARIABLES LIKE '%encrypt%';
SHOW VARIABLES LIKE '%key%';
```

---

## Étape 7 : Création et test de tables chiffrées

### 7.1 Créer une base de données de test

```sql
CREATE DATABASE IF NOT EXISTS donnees_sensibles;
USE donnees_sensibles;
```

### 7.2 Créer une table chiffrée

```sql
-- Méthode 1 : Table avec chiffrement explicite
CREATE TABLE patients (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nom VARCHAR(100),
    prenom VARCHAR(100),
    date_naissance DATE,
    numero_securite_sociale VARCHAR(15),
    diagnostic TEXT
) ENCRYPTED=YES 
  ENCRYPTION_KEY_ID=1 
  COMMENT='Table chiffrée des patients';

-- Méthode 2 : Table avec paramètres par défaut
CREATE TABLE documents_confidentiels (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nom_document VARCHAR(200),
    contenu LONGTEXT,
    date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENCRYPTED=YES;

-- Méthode 3 : Table partitionnée avec chiffrement
CREATE TABLE historique_paiements (
    id INT AUTO_INCREMENT,
    client_id INT,
    montant DECIMAL(10,2),
    date_paiement DATE,
    methode VARCHAR(50),
    PRIMARY KEY (id, date_paiement)
) 
PARTITION BY RANGE (YEAR(date_paiement)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
)
ENCRYPTED=YES;
```

### 7.3 Insérer des données de test

```sql
-- Insérer des données dans la table chiffrée
INSERT INTO patients (nom, prenom, date_naissance, numero_securite_sociale, diagnostic) 
VALUES 
('Martin', 'Jean', '1985-03-15', '185038512345678', 'Contrôle annuel'),
('Dubois', 'Marie', '1990-07-22', '290079023456789', 'Suivi traitement');

-- Insérer dans la table des documents
INSERT INTO documents_confidentiels (nom_document, contenu)
VALUES 
('Contrat_Confidentiel_001', 'Ceci est un document très sensible...'),
('Rapport_Financier_2024', 'Données financières confidentielles...');
```

---

## Étape 8 : Vérification du chiffrement

### 8.1 Vérifier au niveau SQL

```sql
-- Vérifier quelles tables sont chiffrées
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    CREATE_OPTIONS
FROM information_schema.TABLES 
WHERE CREATE_OPTIONS LIKE '%ENCRYPTED%';

-- Vérification détaillée
SELECT 
    t.TABLE_SCHEMA,
    t.TABLE_NAME,
    t.CREATE_OPTIONS,
    i.ENCRYPTION_SCHEME,
    i.KEY_VERSION
FROM information_schema.TABLES t
JOIN information_schema.INNODB_TABLESPACES_ENCRYPTION i 
ON t.TABLE_SCHEMA = i.SCHEMA_NAME AND t.TABLE_NAME = i.TABLE_NAME
WHERE t.TABLE_SCHEMA = 'donnees_sensibles';
```

### 8.2 Vérifier au niveau système de fichiers

```bash
# Trouver l'emplacement des fichiers de données
sudo mysql -e "SHOW VARIABLES LIKE 'datadir';"

# Aller dans le répertoire des données
cd /var/lib/mysql/donnees_sensibles

# Vérifier les fichiers de table
ls -la *.ibd

# Essayer de lire un fichier chiffré (devrait être illisible)
sudo strings patients.ibd | head -20
```

**Observation** : Les fichiers `.ibd` devraient apparaître comme des données binaires sans texte lisible.

---

## Étape 9 : Gestion des clés de chiffrement

### 9.1 Rotation des clés

```sql
-- Créer une nouvelle clé de tablespace
SET GLOBAL innodb_encryption_threads = 4;
ALTER INSTANCE ROTATE INNODB MASTER KEY;

-- Vérifier la rotation
SELECT 
    TABLE_NAME,
    ENCRYPTION_SCHEME,
    MIN_KEY_VERSION,
    CURRENT_KEY_VERSION
FROM information_schema.INNODB_TABLESPACES_ENCRYPTION;
```

### 9.2 Sauvegarde sécurisée des clés

```bash
# Sauvegarder les clés de chiffrement
sudo tar -czf /backup/encryption_keys_$(date +%Y%m%d).tar.gz -C /etc/mysql/encryption .

# Chiffrer la sauvegarde avec GPG
sudo gpg --symmetric --cipher-algo AES256 /backup/encryption_keys_$(date +%Y%m%d).tar.gz

# Supprimer la version non chiffrée
sudo rm /backup/encryption_keys_$(date +%Y%m%d).tar.gz
```

### 9.3 Script de rotation automatique

Créez un fichier `/usr/local/bin/rotate_encryption_keys.sh` :

```bash
#!/bin/bash
# Script de rotation des clés de chiffrement MariaDB

LOG_FILE="/var/log/mariadb/encryption_rotation.log"
BACKUP_DIR="/backup/encryption_keys"

echo "$(date) - Début de la rotation des clés" >> $LOG_FILE

# Sauvegarder les clés actuelles
mkdir -p $BACKUP_DIR
tar -czf $BACKUP_DIR/keys_backup_$(date +%Y%m%d_%H%M%S).tar.gz -C /etc/mysql/encryption . 2>> $LOG_FILE

# Rotation de la clé maîtresse
mysql -e "ALTER INSTANCE ROTATE INNODB MASTER KEY;" 2>> $LOG_FILE

if [ $? -eq 0 ]; then
    echo "$(date) - Rotation des clés réussie" >> $LOG_FILE
else
    echo "$(date) - ERREUR: Rotation des clés échouée" >> $LOG_FILE
    exit 1
fi

# Nettoyage des anciennes sauvegardes (garder 30 jours)
find $BACKUP_DIR -name "*.tar.gz" -mtime +30 -delete 2>> $LOG_FILE

echo "$(date) - Fin de la rotation des clés" >> $LOG_FILE
```

Rendez-le exécutable :

```bash
sudo chmod +x /usr/local/bin/rotate_encryption_keys.sh
```

---

## Étape 10 : Chiffrement de tables existantes

### 10.1 Vérifier les tables non chiffrées

```sql
-- Lister les tables non chiffrées
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    ENGINE
FROM information_schema.TABLES 
WHERE TABLE_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema')
AND CREATE_OPTIONS NOT LIKE '%ENCRYPTED%'
AND ENGINE = 'InnoDB';
```

### 10.2 Chiffrer une table existante

```sql
-- Méthode 1 : ALTER TABLE
ALTER TABLE ma_table_existante ENCRYPTED=YES;

-- Méthode 2 : Créer une copie chiffrée
CREATE TABLE ma_table_chiffree LIKE ma_table_existante;
ALTER TABLE ma_table_chiffree ENCRYPTED=YES;
INSERT INTO ma_table_chiffree SELECT * FROM ma_table_existante;
RENAME TABLE ma_table_existante TO ma_table_ancienne, ma_table_chiffree TO ma_table_existante;
DROP TABLE ma_table_ancienne;

-- Méthode 3 : Utiliser pt-online-schema-change (pour les grosses tables)
-- Nécessite l'installation de Percona Toolkit
```

### 10.3 Exemple complet

```sql
-- Vérifier la table avant chiffrement
SELECT TABLE_NAME, TABLE_ROWS, DATA_LENGTH 
FROM information_schema.TABLES 
WHERE TABLE_NAME = 'historique_connexions';

-- Chiffrer la table
ALTER TABLE historique_connexions ENCRYPTED=YES;

-- Vérifier après chiffrement
SELECT 
    t.TABLE_NAME,
    t.TABLE_ROWS,
    e.ENCRYPTION_SCHEME,
    e.CURRENT_KEY_VERSION
FROM information_schema.TABLES t
JOIN information_schema.INNODB_TABLESPACES_ENCRYPTION e
ON t.TABLE_NAME = e.TABLE_NAME
WHERE t.TABLE_NAME = 'historique_connexions';
```

---

## Étape 11 : Performance et monitoring

### 11.1 Mesurer l'impact sur les performances

```sql
-- Activer le monitoring des performances
SET GLOBAL innodb_monitor_enable = 'module_encryption';

-- Vérifier les statistiques de chiffrement
SELECT 
    NAME,
    COUNT,
    MAX_COUNT,
    MIN_COUNT,
    AVG_COUNT
FROM information_schema.INNODB_METRICS
WHERE NAME LIKE '%encrypt%' OR NAME LIKE '%decrypt%';

-- Mesurer le temps d'exécution avec chiffrement
EXPLAIN ANALYZE
SELECT * FROM patients WHERE nom LIKE 'M%';
```

### 11.2 Configuration pour optimiser les performances

```sql
-- Ajuster les paramètres de performance
SET GLOBAL innodb_encryption_threads = 4;
SET GLOBAL innodb_encryption_rotate_key_age = 2;
SET GLOBAL innodb_encryption_rotation_iops = 200;

-- Pour les tables très utilisées, désactiver le chiffrement des indexes
ALTER TABLE patients ENCRYPTION_KEY_ID=1, ENCRYPTION='Y', ENCRYPTION='N' FOR 'PRIMARY';
```

---

## Exercice pratique : Mise en œuvre complète

**Scénario** : Une clinique médicale doit protéger les données des patients.

**Tâches** :

1. Créer une base `clinique_medicale` avec 3 tables chiffrées :
   
   - `patients` (informations personnelles)
   - `consultations` (historique médical)
   - `ordonnances` (prescriptions)

2. Configurer le chiffrement avec rotation automatique mensuelle

3. Implémenter un système de sauvegarde sécurisé des clés

4. Tester la restauration des données

**Solution guidée** :

Étape 1 - Création des tables :

```sql
CREATE DATABASE clinique_medicale;
USE clinique_medicale;

CREATE TABLE patients (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nom VARCHAR(100),
    prenom VARCHAR(100),
    date_naissance DATE,
    groupe_sanguin VARCHAR(3),
    allergies TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENCRYPTED=YES COMMENT='Données patients chiffrées';

CREATE TABLE consultations (
    id INT AUTO_INCREMENT PRIMARY KEY,
    patient_id INT,
    date_consultation DATETIME,
    medecin VARCHAR(100),
    diagnostic TEXT,
    traitement TEXT,
    FOREIGN KEY (patient_id) REFERENCES patients(id)
) ENCRYPTED=YES;

-- Insérer des données de test
INSERT INTO patients (nom, prenom, date_naissance, groupe_sanguin, allergies)
VALUES ('Durand', 'Sophie', '1992-08-15', 'O+', 'Pénicilline');
```

Étape 2 - Tester l'accès aux données :

```sql
-- Doit fonctionner via MariaDB
SELECT * FROM patients WHERE nom = 'Durand';

-- Doit échouer via lecture directe des fichiers
-- Essayez : sudo strings /var/lib/mysql/clinique_medicale/patients.ibd
```

---

## Pièges courants et solutions

### Problème 1 : "MariaDB ne démarre pas après configuration"

**Solution** :

1. Vérifier les permissions des fichiers de clés
2. Vérifier le format des clés
3. Consulter les logs : `sudo journalctl -xe -u mariadb`

### Problème 2 : "Les performances se dégradent"

**Solution** :

1. Augmenter `innodb_encryption_threads`
2. Utiliser des processeurs supportant AES-NI
3. Chiffrer seulement les colonnes sensibles

### Problème 3 : "Perte des clés de chiffrement"

**Solution** :

1. Restaurer depuis la sauvegarde sécurisée
2. Avoir une copie hors-site des clés
3. Utiliser un HSM (Hardware Security Module) en production

### Problème 4 : "Erreur lors de la rotation des clés"

**Solution** :

```sql
-- Forcer la rotation en cas d'erreur
ALTER INSTANCE ROTATE INNODB MASTER KEY FORCE;
```

---

## Checklist de sécurité

- [ ] Clés stockées dans un répertoire sécurisé (permissions 700)
- [ ] Clés sauvegardées et chiffrées hors-site
- [ ] Rotation régulière des clés configurée
- [ ] Monitoring des performances activé
- [ ] Tests de restauration effectués régulièrement
- [ ] Audit des accès aux fichiers de clés
- [ ] Conformité aux réglementations (RGPD, HIPAA, etc.)

---

## Commandes de référence

```sql
-- Activation du chiffrement pour une table
CREATE TABLE ma_table (...) ENCRYPTED=YES;
ALTER TABLE ma_table_existante ENCRYPTED=YES;

-- Rotation des clés
ALTER INSTANCE ROTATE INNODB MASTER KEY;

-- Vérification
SHOW VARIABLES LIKE '%encrypt%';
SELECT * FROM information_schema.INNODB_TABLESPACES_ENCRYPTION;
```

```bash
# Gestion des clés
openssl rand -hex 32 > master_key.txt
mariadb-key-management --write-keyfile --file-keyfile keyfile.enc --encryption-keyfile master_key.txt

# Vérification des fichiers
sudo strings /var/lib/mysql/ma_base/ma_table.ibd | head -20
```

---

## À retenir

1. Le chiffrement au repos protège les données stockées sur disque
2. MariaDB supporte le chiffrement transparent des tables, logs et binlogs
3. La gestion sécurisée des clés est cruciale
4. Monitorer l'impact sur les performances
5. Tester régulièrement la restauration des données
6. Maintenir les sauvegardes des clés hors-site et chiffrées

**Prochain atelier** : Chiffrement des données en transit avec SSL/TLS et authentification sécurisée.

Apprendre à :

1. Activer le chiffrement au repos dans MariaDB.

2. Chiffrer les tables et les journaux de MariaDB.

3. Vérifier que le chiffrement est bien actif.

Le chiffrement *at-rest* protège les données stockées sur disque (fichiers de tables, journaux, binlogs), de sorte qu’un attaquant qui copie les fichiers ne puisse pas les lire.

---

## Étapes de l’atelier

1. Vérifier la prise en charge du chiffrement dans la version MariaDB installée.

2. Activer le plugin de chiffrement.

3. Configurer une clé de chiffrement.

4. Créer une table chiffrée.

5. Vérifier que le chiffrement est appliqué.

---

## Démarches

### 1. Vérifier le support du chiffrement

Dans MariaDB :

```sql
SHOW VARIABLES LIKE 'innodb_encrypt%';
SHOW PLUGINS LIKE 'file_key_management';
```

Résultat attendu :

- Les variables `innodb_encrypt_tables` et `innodb_encrypt_log` doivent exister.

- Le plugin `file_key_management` peut être utilisé pour gérer les clés.

---

### 2. Activer le plugin de chiffrement

Éditer le fichier de configuration MariaDB :

```bash
sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf
```

Ajouter dans la section `[mysqld]` :

```
plugin_load_add = file_key_management
file_key_management_filename = /etc/mysql/encryption/keyfile.enc
file_key_management_filekey = FILE:/etc/mysql/encryption/keyfile
innodb_encrypt_tables = ON
innodb_encrypt_log = ON
encrypt_binlog = ON
```

---

### 3. Créer une clé de chiffrement

Créer le répertoire et le fichier de clé :

```bash
sudo mkdir -p /etc/mysql/encryption
sudo chmod 700 /etc/mysql/encryption

# Génération d’une clé aléatoire de 32 octets
openssl rand -base64 32 | sudo tee /etc/mysql/encryption/keyfile > /dev/null

# Créer un fichier de clés chiffrées
sudo mariadb-key-management \
  --write-keyfile --file-keyfile /etc/mysql/encryption/keyfile \
  --encryption-keyfile /etc/mysql/encryption/keyfile.enc
```

Assurer les permissions :

```bash
sudo chown -R mysql:mysql /etc/mysql/encryption
sudo chmod 600 /etc/mysql/encryption/*
```

---

### 4. Créer une table chiffrée

Après redémarrage de MariaDB :

```bash
sudo systemctl restart mariadb
```

Dans MariaDB :

```sql
CREATE DATABASE secure_demo;
USE secure_demo;

CREATE TABLE secrets (
    id INT AUTO_INCREMENT PRIMARY KEY,
    info VARCHAR(100)
) ENCRYPTED=YES;

INSERT INTO secrets (info) VALUES ('motdepasse'), ('token_api');
```

---

### 5. Vérifier le chiffrement

Vérification des options :

```sql
SHOW VARIABLES LIKE 'innodb_encrypt_tables';
SHOW VARIABLES LIKE 'innodb_encrypt_log';
```

Vérification d’une table :

```sql
SELECT TABLE_SCHEMA, TABLE_NAME, CREATE_OPTIONS
FROM information_schema.tables
WHERE table_schema='secure_demo';
```

Résultat attendu : la colonne `CREATE_OPTIONS` contient `ENCRYPTED=YES`.

---

## Résultats attendus

- Le plugin de gestion de clés est activé et configuré.

- Les fichiers de tables et journaux MariaDB sont chiffrés sur disque.

- La table `secrets` est stockée avec l’option `ENCRYPTED=YES`.

- Même si quelqu’un copie les fichiers du disque, les données ne sont pas lisibles sans la clé.
