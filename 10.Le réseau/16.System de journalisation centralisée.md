# Atelier : Mise en place d’un Syslog centralisé réseau

## 1. Contexte & objectif

Dans une infrastructure réelle, il est essentiel de **centraliser les journaux** système et applicatifs afin de :

- Avoir une vision unifiée des événements.

- Détecter plus rapidement les anomalies.

- Sécuriser les logs en évitant leur suppression locale par un attaquant.

Dans cet atelier, vous allez :

- Transformer `machine1` en **serveur Syslog central** (rsyslog).

- Configurer `machine2` comme **client Syslog** qui enverra ses logs à `machine1`.

- Vérifier en temps réel la réception et la classification des logs.

---

## 2. Préparation du terrain

### Prérequis

- 2 machines Debian reliées par le réseau interne `10.10.10.0/24`.
  
  - `machine1` : 10.10.10.1 (serveur Syslog).
  
  - `machine2` : 10.10.10.2 (client Syslog).

### Paquets nécessaires

Sur **les deux machines** :

```bash
sudo apt update
sudo apt install -y rsyslog
```

Vérifiez que `rsyslog` est activé et fonctionne :

```bash
systemctl status rsyslog
```

---

## 3. Démarche progressive

### Étape 1 – Activer le serveur Syslog sur machine1

1. Ouvrir le fichier de configuration principale :
   
   ```bash
   sudo nano /etc/rsyslog.conf
   ```

2. Décommentez ou ajoutez ces lignes pour autoriser la réception réseau :
   
   ```conf
   # Activer réception UDP
   module(load="imudp")
   input(type="imudp" port="514")
   
   # Activer réception TCP
   module(load="imtcp")
   input(type="imtcp" port="514")
   ```

3. Sauvegardez et redémarrez rsyslog :
   
   ```bash
   sudo systemctl restart rsyslog
   ```

4. Vérifiez que le port est bien ouvert :
   
   ```bash
   sudo ss -tulpn | grep 514
   ```

---

### Étape 2 – Configurer le client Syslog sur machine2

1. Éditer la configuration de rsyslog :
   
   ```bash
   sudo nano /etc/rsyslog.conf
   ```

2. Ajoutez une règle pour envoyer tous les logs vers `machine1` :
   
   ```conf
   *.*   @10.10.10.1:514        # envoi UDP
   # ou
   *.*   @@10.10.10.1:514       # envoi TCP (double @)
   ```

3. Sauvegardez et redémarrez rsyslog :
   
   ```bash
   sudo systemctl restart rsyslog
   ```

---

### Étape 3 – Vérifier la centralisation

1. Sur `machine2`, générez un message de log :
   
   ```bash
   logger "Test log depuis machine2"
   ```

2. Sur `machine1`, vérifiez l’arrivée du message dans les fichiers de logs :
   
   ```bash
   sudo tail -f /var/log/syslog
   ```
   
   Vous devez voir :
   
   ```
   Oct  2 22:45 machine2 Test log depuis machine2
   ```

---

### Étape 4 – Organisation des logs par hôte

Pour mieux séparer les logs, configurez `machine1` :

1. Créez un fichier de configuration dédié :
   
   ```bash
   sudo nano /etc/rsyslog.d/remote.conf
   ```

2. Ajoutez :
   
   ```conf
   # Stocker les logs entrants par machine
   if ($fromhost-ip != "") then {
      action(type="omfile" file="/var/log/remote/%HOSTNAME%.log")
      stop
   }
   ```

3. Créez le dossier et redémarrez :
   
   ```bash
   sudo mkdir -p /var/log/remote
   sudo systemctl restart rsyslog
   ```

4. Testez de nouveau avec `logger` depuis machine2 → un fichier `/var/log/remote/machine2.log` doit apparaître.

---

## 4. Nettoyage

Pour remettre l’environnement à zéro :

### Sur machine2 (client)

- Supprimer la règle d’envoi :
  
  ```bash
  sudo nano /etc/rsyslog.conf
  # commentez la ligne *.* @10.10.10.1:514
  ```

- Redémarrer :
  
  ```bash
  sudo systemctl restart rsyslog
  ```

### Sur machine1 (serveur)

- Supprimer ou commenter les lignes ajoutées dans `/etc/rsyslog.conf` et `/etc/rsyslog.d/remote.conf`.

- Supprimer le dossier créé :
  
  ```bash
  sudo rm -rf /var/log/remote
  ```

- Redémarrer rsyslog :
  
  ```bash
  sudo systemctl restart rsyslog
  ```

---

✅ **Résultat attendu** : vous avez démontré un **serveur Syslog centralisé** capable de collecter et organiser les journaux d’autres machines du réseau.

---

Parfait — voici **la Partie II** qui complète l’atelier en montrant **comment tester** votre serveur de logs rsyslog de façon rigoureuse (connectivité, facilities/severity, rafales, panne réseau/service, tcpdump, rotation, etc.).
Je vous la donne en version **complète ci-dessous** (copiable telle quelle) **et** en **fichier .md téléchargeable** :

[Download the Markdown](sandbox:/mnt/data/16b.Syslog_Central_Tests.md)

---

# Atelier (Partie II) — Tester un serveur Syslog centralisé (rsyslog)

## 1) Contexte & objectif

Vous avez mis en place un serveur **rsyslog** central (Partie I). Cette Partie II fournit une **batterie de tests** reproductibles pour valider :

* l’écoute sur les ports 514/UDP et 514/TCP,
* la **connectivité réseau** client→serveur,
* l’**émission** de logs avec `logger` (facilities & severities),
* la **classification** et la **rotation** des logs côté serveur,
* le **comportement en panne** (coupure de port/arrêt service),
* une **observation réseau** rapide avec `tcpdump`,
* quelques **pièges & astuces** fréquents.

> Topologie de référence identique à la Partie I :
> `machine1` = serveur rsyslog (10.10.10.1) — `machine2` = client rsyslog (10.10.10.2) — Debian 12+

---

## 2) Préparation du terrain

### 2.1 Prérequis côté configuration

* Partie I terminée et fonctionnelle (écoute 514/UDP et 514/TCP sur `machine1`, redirection des logs depuis `machine2`).
* Un dossier dédié côté serveur (ex. `/var/log/remote/`) déjà créé si vous avez suivi l’étape d’organisation par hôte.

### 2.2 Outils utiles

Exécuter sur **chaque** machine :

```bash
sudo apt update
sudo apt install -y netcat-openbsd tcpdump nmap
```

> `netcat-openbsd` apporte un `nc` compatible `-z -v -u` (tests UDP).

### 2.3 Synchronisation horaire (recommandée)

Sur **chaque** machine :

```bash
timedatectl status
# Si "NTP service: inactive", activez-le :
sudo timedatectl set-ntp true
```

---

## 3) Déroulé des tests (pas à pas)

### Test 1 — Sanité du serveur : ports ouverts

Sur **machine1 (serveur)** :

```bash
sudo ss -tulpn | grep ':514 '
```

**Attendu** : lignes montrant `udp` 0.0.0.0:514 et `tcp` 0.0.0.0:514 (processus `rsyslogd`).

### Test 2 — Connectivité réseau depuis le client

Sur **machine2 (client)** :

```bash
# Test UDP (paquets "best effort" — pas d’ACK attendu)
nc -vz -u 10.10.10.1 514

# Test TCP (connexion explicite)
nc -vz 10.10.10.1 514
```

**Attendu** : `succeeded` pour TCP ; pour UDP, `nc` peut afficher `succeeded` sans garantie (UDP est non connecté).

### Test 3 — Envoi d’un log simple (niveau « info » par défaut)

Sur **machine2 (client)** :

```bash
logger "PartieII: test simple depuis machine2"
```

Sur **machine1 (serveur)**, observer en temps réel :

```bash
sudo tail -n0 -f /var/log/syslog /var/log/remote/machine2.log
```

**Attendu** : une ligne contenant `machine2` et le message `PartieII: test simple...` apparaît dans l’un des fichiers (selon votre config Partie I).

### Test 4 — Facilities & Sevérity (classification fonctionnelle)

Sur **machine2 (client)**, envoyez plusieurs messages :

```bash
logger -p user.debug   "PartieII: user.debug"
logger -p daemon.info  "PartieII: daemon.info"
logger -p authpriv.notice "PartieII: authpriv.notice"
logger -p local0.err   "PartieII: local0.err"
```

> `-p facility.severity` permet de valider vos règles.
> `authpriv.*` peut être redirigé par défaut vers `/var/log/auth.log` côté serveur.

Sur **machine1 (serveur)**, vérifiez :

```bash
# Selon votre politique :
sudo grep -E "PartieII: (user.debug|daemon.info|authpriv.notice|local0.err)" -n \
  /var/log/syslog /var/log/auth.log /var/log/remote/machine2.log || true
```

**Attendu** : chaque message est présent **une seule fois**, dans le fichier conforme à votre politique de routage.

### Test 5 — Règle serveur par hôte (si activée en Partie I)

Sur **machine2 (client)** :

```bash
logger -p local1.warning "PartieII: routage par hôte vers /var/log/remote/machine2.log"
```

Sur **machine1 (serveur)** :

```bash
sudo tail -n5 /var/log/remote/machine2.log
```

**Attendu** : le message est bien écrit dans `/var/log/remote/machine2.log`.

### Test 6 — Observation réseau (tcpdump)

Sur **machine1 (serveur)**, dans un premier terminal :

```bash
sudo tcpdump -i any -nn "udp port 514 or tcp port 514" -c 5 -A
```

Dans un **second** terminal (toujours sur `machine2`) :

```bash
for i in $(seq 1 5); do logger "PartieII: tcpdump-$i"; sleep 0.2; done
```

**Attendu** côté `tcpdump` : 5 paquets capturés avec un payload commençant par `<PRI>` (format syslog).

### Test 7 — Débit / rafale (résilience et rate-limiting)

Sur **machine2 (client)** :

```bash
for i in $(seq 1 500); do logger -p local0.info "PartieII: burst $i"; done
```

Sur **machine1 (serveur)** :

```bash
sudo grep -c "PartieII: burst " /var/log/remote/machine2.log
```

**Attendu** : proche de 500 (un léger écart est possible si une limite de débit/ratelimiting est active).

### Test 8 — Panne contrôlée : arrêt du service côté serveur

Sur **machine1 (serveur)** :

```bash
sudo systemctl stop rsyslog
sudo ss -tulpn | grep ':514 ' || echo "Ports 514 inactifs (attendu)"
```

Tandis que **machine1** est arrêté, sur **machine2 (client)** :

```bash
for i in $(seq 1 10); do logger "PartieII: serveur OFF essai $i"; sleep 0.2; done
```

Remettez **machine1** en service :

```bash
sudo systemctl start rsyslog
```

**Attendu** : en **UDP**, ces messages sont perdus ; en **TCP**, ils échouent pendant l’arrêt puis reprennent après redémarrage. Vérifiez l’absence/présence des messages :

```bash
sudo grep "PartieII: serveur OFF essai" /var/log/remote/machine2.log || echo "Aucune trace (UDP attendu)"
```

### Test 9 — Panne réseau simulée : firewall côté serveur

Sur **machine1 (serveur)**, **bloquez temporairement** 514/UDP et 514/TCP :

```bash
# Bloquer TCP/UDP 514 (IPv4) — nftables (Debian par défaut)
sudo nft add table inet test_syslog
sudo nft add chain inet test_syslog input { type filter hook input priority 0 \; }
sudo nft add rule  inet test_syslog input tcp dport 514 drop
sudo nft add rule  inet test_syslog input udp dport 514 drop

# Vérifier
sudo nft list ruleset | sed -n '1,120p'
```

Sur **machine2 (client)**, essayez :

```bash
logger -p user.info "PartieII: firewall drop test"
```

Puis **retirez** les règles et réessayez :

```bash
# Nettoyage firewall
sudo nft delete table inet test_syslog
logger -p user.info "PartieII: firewall cleared"
```

Sur **machine1 (serveur)**, contrôlez :

```bash
sudo grep -E "PartieII: firewall (drop test|cleared)" /var/log/remote/machine2.log || true
```

**Attendu** : seule la ligne `firewall cleared` apparaît (celle en « drop test » a été bloquée).

### Test 10 — Rotation des logs

Sur **machine1 (serveur)** :

```bash
# Forcer une rotation rsyslog (peut varier selon Debian)
sudo logrotate -f /etc/logrotate.d/rsyslog || true
# Relancer rsyslog par précaution
sudo systemctl restart rsyslog
```

Ensuite, sur **machine2 (client)** :

```bash
logger -p local0.notice "PartieII: post-rotation check"
```

Sur **machine1 (serveur)**, vérifiez :

```bash
sudo grep "PartieII: post-rotation check" /var/log/remote/machine2.log
```

**Attendu** : le message apparaît dans le nouveau fichier après rotation (la continuité d’écriture est assurée).

---

## 4) Vérifications / Résultats attendus (résumé)

* `ss -tulpn` sur serveur montre 514/udp et 514/tcp bindés par `rsyslogd`.
* `nc -vz 10.10.10.1 514` affiche `succeeded` (TCP OK).
* Les `logger -p facility.level` se retrouvent dans les **bons fichiers** côté serveur (`/var/log/remote/machine2.log`, `/var/log/auth.log`, etc.).
* `tcpdump` capture le trafic lors des envois `logger`.
* Pendant un **arrêt serveur** : pertes en UDP, échecs en TCP puis rétablissement au redémarrage.
* Lors d’un **drop firewall** : aucun log reçu jusqu’à suppression de la règle de blocage.
* Après **rotation** : les logs continuent d’être écrits sans perte.

---

## 5) Nettoyage / Retour à l’état initial

Sur **machine1 (serveur)** :

```bash
# S'assurer qu’aucune règle de test persiste
sudo nft list tables | grep -q test_syslog && sudo nft delete table inet test_syslog || true

# (Optionnel) Purger les traces de tests si besoin
sudo find /var/log/remote -type f -name "machine2.log*" -print -exec sudo truncate -s 0 {} \;
```

Sur **machine2 (client)** : aucun changement persistant à nettoyer.

---

## 6) Astuces & Pièges

* **UDP vs TCP** : UDP est léger mais non garanti (pertes possibles) ; TCP apporte l’ACK et la reconnexion. Choisir selon criticité et volume.
* **Rate limiting** : rsyslog peut limiter certaines sources/facilities. Ajustez les *rulesets* et options `ratelimit.interval/ratelimit.burst` si des pertes apparaissent en rafale.
* **Templates & format** : par défaut Debian est souvent en RFC3164. Pour des parsers SIEM, envisagez RFC5424 (`RSYSLOG_TraditionalForwardFormat` vs `RSYSLOG_SyslogProtocol23Format`).
* **DNS/Hostnames** : si `machine2` n’a pas de résolution inverse correcte, `%HOSTNAME%` peut ne pas refléter l’attendu. Utilisez `%fromhost-ip%` ou fixez `/etc/hosts`/DNS PTR.
* **Horodatage** : des horloges désalignées compliquent les corrélations temporelles ; activez `systemd-timesyncd` ou un NTP interne.
* **Sécurité** : ouvrez 514/TCP/UDP **uniquement** depuis les sous-réseaux clients autorisés (nftables), chiffrez côté VPN si nécessaire.

---

## 🧹 Nettoyage intégral de l’atelier Partie I

### 1️⃣ Sur le **client (machine2)**

```bash
echo "=== Nettoyage machine2 (client) ==="

# 1. Sauvegarder la configuration actuelle avant modification
sudo cp /etc/rsyslog.conf /etc/rsyslog.conf.bak.part1

# 2. Supprimer ou commenter la règle d’envoi vers le serveur
sudo sed -i '/@10\.10\.10\.1:514/s/^/#/' /etc/rsyslog.conf
sudo sed -i '/@@10\.10\.10\.1:514/s/^/#/' /etc/rsyslog.conf

# 3. Redémarrer rsyslog pour revenir au mode local uniquement
sudo systemctl restart rsyslog

# 4. Vérifier que rsyslog écoute uniquement en local
sudo ss -tulpn | grep rsyslog || echo "rsyslog client nettoyé"
```

🧭 **Résultat attendu :**

* Aucun envoi réseau vers 10.10.10.1.
* Les journaux sont à nouveau écrits localement dans `/var/log/syslog`.

---

### 2️⃣ Sur le **serveur (machine1)**

```bash
echo "=== Nettoyage machine1 (serveur) ==="

# 1. Sauvegarde des fichiers modifiés
sudo cp /etc/rsyslog.conf /etc/rsyslog.conf.bak.part1
sudo [ -f /etc/rsyslog.d/remote.conf ] && sudo cp /etc/rsyslog.d/remote.conf /etc/rsyslog.d/remote.conf.bak.part1

# 2. Supprimer la configuration spécifique à la réception distante
sudo sed -i '/imudp/ s/^/#/' /etc/rsyslog.conf
sudo sed -i '/imtcp/ s/^/#/' /etc/rsyslog.conf
sudo sed -i '/input(type="imudp"/ s/^/#/' /etc/rsyslog.conf
sudo sed -i '/input(type="imtcp"/ s/^/#/' /etc/rsyslog.conf

# 3. Supprimer le fichier de routage par hôte (si présent)
sudo rm -f /etc/rsyslog.d/remote.conf

# 4. Supprimer les logs reçus et le dossier dédié
sudo rm -rf /var/log/remote

# 5. Redémarrer rsyslog
sudo systemctl restart rsyslog

# 6. Vérification finale
sudo ss -tulpn | grep ':514' || echo "Ports 514 fermés — nettoyage terminé"
```

🧭 **Résultat attendu :**

* Le service `rsyslog` n’écoute plus sur le réseau (`ss` ne montre plus de port 514 ouvert).
* Le répertoire `/var/log/remote` est supprimé.
* Les fichiers de configuration sont revenus à leur état d’origine (sauvegardes conservées).

---

### 3️⃣ Vérification finale des deux machines

```bash
echo "=== Vérification globale ==="
for h in 10.10.10.1 10.10.10.2; do
  echo "----- $h -----"
  ssh $h 'sudo systemctl status rsyslog --no-pager | grep Active'
done
```

**Attendu :**

* Les deux services `rsyslog` sont actifs (`active (running)`).
* Plus de communication réseau entre client et serveur.

---

### 4️⃣ (Optionnel) Purge des paquets et journaux pour repartir de zéro

```bash
sudo apt purge -y rsyslog
sudo rm -rf /var/log/*
sudo apt install -y rsyslog
sudo systemctl enable --now rsyslog
```

⚠️ À utiliser **uniquement** si vous voulez repartir d’un environnement vierge avant un nouvel atelier.

---
