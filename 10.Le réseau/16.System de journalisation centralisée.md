# Atelier : Mise en place d‚Äôun Syslog centralis√© r√©seau

## 1. Contexte & objectif

Dans une infrastructure r√©elle, il est essentiel de **centraliser les journaux** syst√®me et applicatifs afin de :

- Avoir une vision unifi√©e des √©v√©nements.

- D√©tecter plus rapidement les anomalies.

- S√©curiser les logs en √©vitant leur suppression locale par un attaquant.

Dans cet atelier, vous allez :

- Transformer `machine1` en **serveur Syslog central** (rsyslog).

- Configurer `machine2` comme **client Syslog** qui enverra ses logs √† `machine1`.

- V√©rifier en temps r√©el la r√©ception et la classification des logs.

---

## 2. Pr√©paration du terrain

### Pr√©requis

- 2 machines Debian reli√©es par le r√©seau interne `10.10.10.0/24`.
  
  - `machine1` : 10.10.10.1 (serveur Syslog).
  
  - `machine2` : 10.10.10.2 (client Syslog).

### Paquets n√©cessaires

Sur **les deux machines** :

```bash
sudo apt update
sudo apt install -y rsyslog
```

V√©rifiez que `rsyslog` est activ√© et fonctionne :

```bash
systemctl status rsyslog
```

---

## 3. D√©marche progressive

### √âtape 1 ‚Äì Activer le serveur Syslog sur machine1

1. Ouvrir le fichier de configuration principale :
   
   ```bash
   sudo nano /etc/rsyslog.conf
   ```

2. D√©commentez ou ajoutez ces lignes pour autoriser la r√©ception r√©seau :
   
   ```conf
   # Activer r√©ception UDP
   module(load="imudp")
   input(type="imudp" port="514")
   
   # Activer r√©ception TCP
   module(load="imtcp")
   input(type="imtcp" port="514")
   ```

3. Sauvegardez et red√©marrez rsyslog :
   
   ```bash
   sudo systemctl restart rsyslog
   ```

4. V√©rifiez que le port est bien ouvert :
   
   ```bash
   sudo ss -tulpn | grep 514
   ```

---

### √âtape 2 ‚Äì Configurer le client Syslog sur machine2

1. √âditer la configuration de rsyslog :
   
   ```bash
   sudo nano /etc/rsyslog.conf
   ```

2. Ajoutez une r√®gle pour envoyer tous les logs vers `machine1` :
   
   ```conf
   *.*   @10.10.10.1:514        # envoi UDP
   # ou
   *.*   @@10.10.10.1:514       # envoi TCP (double @)
   ```

3. Sauvegardez et red√©marrez rsyslog :
   
   ```bash
   sudo systemctl restart rsyslog
   ```

---

### √âtape 3 ‚Äì V√©rifier la centralisation

1. Sur `machine2`, g√©n√©rez un message de log :
   
   ```bash
   logger "Test log depuis machine2"
   ```

2. Sur `machine1`, v√©rifiez l‚Äôarriv√©e du message dans les fichiers de logs :
   
   ```bash
   sudo tail -f /var/log/syslog
   ```
   
   Vous devez voir :
   
   ```
   Oct  2 22:45 machine2 Test log depuis machine2
   ```

---

### √âtape 4 ‚Äì Organisation des logs par h√¥te

Pour mieux s√©parer les logs, configurez `machine1` :

1. Cr√©ez un fichier de configuration d√©di√© :
   
   ```bash
   sudo nano /etc/rsyslog.d/remote.conf
   ```

2. Ajoutez :
   
   ```conf
   # Stocker les logs entrants par machine
   if ($fromhost-ip != "") then {
      action(type="omfile" file="/var/log/remote/%HOSTNAME%.log")
      stop
   }
   ```

3. Cr√©ez le dossier et red√©marrez :
   
   ```bash
   sudo mkdir -p /var/log/remote
   sudo systemctl restart rsyslog
   ```

4. Testez de nouveau avec `logger` depuis machine2 ‚Üí un fichier `/var/log/remote/machine2.log` doit appara√Ætre.

---

## 4. Nettoyage

Pour remettre l‚Äôenvironnement √† z√©ro :

### Sur machine2 (client)

- Supprimer la r√®gle d‚Äôenvoi :
  
  ```bash
  sudo nano /etc/rsyslog.conf
  # commentez la ligne *.* @10.10.10.1:514
  ```

- Red√©marrer :
  
  ```bash
  sudo systemctl restart rsyslog
  ```

### Sur machine1 (serveur)

- Supprimer ou commenter les lignes ajout√©es dans `/etc/rsyslog.conf` et `/etc/rsyslog.d/remote.conf`.

- Supprimer le dossier cr√©√© :
  
  ```bash
  sudo rm -rf /var/log/remote
  ```

- Red√©marrer rsyslog :
  
  ```bash
  sudo systemctl restart rsyslog
  ```

---

‚úÖ **R√©sultat attendu** : vous avez d√©montr√© un **serveur Syslog centralis√©** capable de collecter et organiser les journaux d‚Äôautres machines du r√©seau.

---

Parfait ‚Äî voici **la Partie II** qui compl√®te l‚Äôatelier en montrant **comment tester** votre serveur de logs rsyslog de fa√ßon rigoureuse (connectivit√©, facilities/severity, rafales, panne r√©seau/service, tcpdump, rotation, etc.).
Je vous la donne en version **compl√®te ci-dessous** (copiable telle quelle) **et** en **fichier .md t√©l√©chargeable** :

[Download the Markdown](sandbox:/mnt/data/16b.Syslog_Central_Tests.md)

---

# Atelier (Partie II) ‚Äî Tester un serveur Syslog centralis√© (rsyslog)

## 1) Contexte & objectif

Vous avez mis en place un serveur **rsyslog** central (Partie I). Cette Partie II fournit une **batterie de tests** reproductibles pour valider :

* l‚Äô√©coute sur les ports 514/UDP et 514/TCP,
* la **connectivit√© r√©seau** client‚Üíserveur,
* l‚Äô**√©mission** de logs avec `logger` (facilities & severities),
* la **classification** et la **rotation** des logs c√¥t√© serveur,
* le **comportement en panne** (coupure de port/arr√™t service),
* une **observation r√©seau** rapide avec `tcpdump`,
* quelques **pi√®ges & astuces** fr√©quents.

> Topologie de r√©f√©rence identique √† la Partie I :
> `machine1` = serveur rsyslog (10.10.10.1) ‚Äî `machine2` = client rsyslog (10.10.10.2) ‚Äî Debian 12+

---

## 2) Pr√©paration du terrain

### 2.1 Pr√©requis c√¥t√© configuration

* Partie I termin√©e et fonctionnelle (√©coute 514/UDP et 514/TCP sur `machine1`, redirection des logs depuis `machine2`).
* Un dossier d√©di√© c√¥t√© serveur (ex. `/var/log/remote/`) d√©j√† cr√©√© si vous avez suivi l‚Äô√©tape d‚Äôorganisation par h√¥te.

### 2.2 Outils utiles

Ex√©cuter sur **chaque** machine :

```bash
sudo apt update
sudo apt install -y netcat-openbsd tcpdump nmap
```

> `netcat-openbsd` apporte un `nc` compatible `-z -v -u` (tests UDP).

### 2.3 Synchronisation horaire (recommand√©e)

Sur **chaque** machine :

```bash
timedatectl status
# Si "NTP service: inactive", activez-le :
sudo timedatectl set-ntp true
```

---

## 3) D√©roul√© des tests (pas √† pas)

### Test 1 ‚Äî Sanit√© du serveur : ports ouverts

Sur **machine1 (serveur)** :

```bash
sudo ss -tulpn | grep ':514 '
```

**Attendu** : lignes montrant `udp` 0.0.0.0:514 et `tcp` 0.0.0.0:514 (processus `rsyslogd`).

### Test 2 ‚Äî Connectivit√© r√©seau depuis le client

Sur **machine2 (client)** :

```bash
# Test UDP (paquets "best effort" ‚Äî pas d‚ÄôACK attendu)
nc -vz -u 10.10.10.1 514

# Test TCP (connexion explicite)
nc -vz 10.10.10.1 514
```

**Attendu** : `succeeded` pour TCP ; pour UDP, `nc` peut afficher `succeeded` sans garantie (UDP est non connect√©).

### Test 3 ‚Äî Envoi d‚Äôun log simple (niveau ¬´ info ¬ª par d√©faut)

Sur **machine2 (client)** :

```bash
logger "PartieII: test simple depuis machine2"
```

Sur **machine1 (serveur)**, observer en temps r√©el :

```bash
sudo tail -n0 -f /var/log/syslog /var/log/remote/machine2.log
```

**Attendu** : une ligne contenant `machine2` et le message `PartieII: test simple...` appara√Æt dans l‚Äôun des fichiers (selon votre config Partie I).

### Test 4 ‚Äî Facilities & Sev√©rity (classification fonctionnelle)

Sur **machine2 (client)**, envoyez plusieurs messages :

```bash
logger -p user.debug   "PartieII: user.debug"
logger -p daemon.info  "PartieII: daemon.info"
logger -p authpriv.notice "PartieII: authpriv.notice"
logger -p local0.err   "PartieII: local0.err"
```

> `-p facility.severity` permet de valider vos r√®gles.
> `authpriv.*` peut √™tre redirig√© par d√©faut vers `/var/log/auth.log` c√¥t√© serveur.

Sur **machine1 (serveur)**, v√©rifiez :

```bash
# Selon votre politique :
sudo grep -E "PartieII: (user.debug|daemon.info|authpriv.notice|local0.err)" -n \
  /var/log/syslog /var/log/auth.log /var/log/remote/machine2.log || true
```

**Attendu** : chaque message est pr√©sent **une seule fois**, dans le fichier conforme √† votre politique de routage.

### Test 5 ‚Äî R√®gle serveur par h√¥te (si activ√©e en Partie I)

Sur **machine2 (client)** :

```bash
logger -p local1.warning "PartieII: routage par h√¥te vers /var/log/remote/machine2.log"
```

Sur **machine1 (serveur)** :

```bash
sudo tail -n5 /var/log/remote/machine2.log
```

**Attendu** : le message est bien √©crit dans `/var/log/remote/machine2.log`.

### Test 6 ‚Äî Observation r√©seau (tcpdump)

Sur **machine1 (serveur)**, dans un premier terminal :

```bash
sudo tcpdump -i any -nn "udp port 514 or tcp port 514" -c 5 -A
```

Dans un **second** terminal (toujours sur `machine2`) :

```bash
for i in $(seq 1 5); do logger "PartieII: tcpdump-$i"; sleep 0.2; done
```

**Attendu** c√¥t√© `tcpdump` : 5 paquets captur√©s avec un payload commen√ßant par `<PRI>` (format syslog).

### Test 7 ‚Äî D√©bit / rafale (r√©silience et rate-limiting)

Sur **machine2 (client)** :

```bash
for i in $(seq 1 500); do logger -p local0.info "PartieII: burst $i"; done
```

Sur **machine1 (serveur)** :

```bash
sudo grep -c "PartieII: burst " /var/log/remote/machine2.log
```

**Attendu** : proche de 500 (un l√©ger √©cart est possible si une limite de d√©bit/ratelimiting est active).

### Test 8 ‚Äî Panne contr√¥l√©e : arr√™t du service c√¥t√© serveur

Sur **machine1 (serveur)** :

```bash
sudo systemctl stop rsyslog
sudo ss -tulpn | grep ':514 ' || echo "Ports 514 inactifs (attendu)"
```

Tandis que **machine1** est arr√™t√©, sur **machine2 (client)** :

```bash
for i in $(seq 1 10); do logger "PartieII: serveur OFF essai $i"; sleep 0.2; done
```

Remettez **machine1** en service :

```bash
sudo systemctl start rsyslog
```

**Attendu** : en **UDP**, ces messages sont perdus ; en **TCP**, ils √©chouent pendant l‚Äôarr√™t puis reprennent apr√®s red√©marrage. V√©rifiez l‚Äôabsence/pr√©sence des messages :

```bash
sudo grep "PartieII: serveur OFF essai" /var/log/remote/machine2.log || echo "Aucune trace (UDP attendu)"
```

### Test 9 ‚Äî Panne r√©seau simul√©e : firewall c√¥t√© serveur

Sur **machine1 (serveur)**, **bloquez temporairement** 514/UDP et 514/TCP :

```bash
# Bloquer TCP/UDP 514 (IPv4) ‚Äî nftables (Debian par d√©faut)
sudo nft add table inet test_syslog
sudo nft add chain inet test_syslog input { type filter hook input priority 0 \; }
sudo nft add rule  inet test_syslog input tcp dport 514 drop
sudo nft add rule  inet test_syslog input udp dport 514 drop

# V√©rifier
sudo nft list ruleset | sed -n '1,120p'
```

Sur **machine2 (client)**, essayez :

```bash
logger -p user.info "PartieII: firewall drop test"
```

Puis **retirez** les r√®gles et r√©essayez :

```bash
# Nettoyage firewall
sudo nft delete table inet test_syslog
logger -p user.info "PartieII: firewall cleared"
```

Sur **machine1 (serveur)**, contr√¥lez :

```bash
sudo grep -E "PartieII: firewall (drop test|cleared)" /var/log/remote/machine2.log || true
```

**Attendu** : seule la ligne `firewall cleared` appara√Æt (celle en ¬´ drop test ¬ª a √©t√© bloqu√©e).

### Test 10 ‚Äî Rotation des logs

Sur **machine1 (serveur)** :

```bash
# Forcer une rotation rsyslog (peut varier selon Debian)
sudo logrotate -f /etc/logrotate.d/rsyslog || true
# Relancer rsyslog par pr√©caution
sudo systemctl restart rsyslog
```

Ensuite, sur **machine2 (client)** :

```bash
logger -p local0.notice "PartieII: post-rotation check"
```

Sur **machine1 (serveur)**, v√©rifiez :

```bash
sudo grep "PartieII: post-rotation check" /var/log/remote/machine2.log
```

**Attendu** : le message appara√Æt dans le nouveau fichier apr√®s rotation (la continuit√© d‚Äô√©criture est assur√©e).

---

## 4) V√©rifications / R√©sultats attendus (r√©sum√©)

* `ss -tulpn` sur serveur montre 514/udp et 514/tcp bind√©s par `rsyslogd`.
* `nc -vz 10.10.10.1 514` affiche `succeeded` (TCP OK).
* Les `logger -p facility.level` se retrouvent dans les **bons fichiers** c√¥t√© serveur (`/var/log/remote/machine2.log`, `/var/log/auth.log`, etc.).
* `tcpdump` capture le trafic lors des envois `logger`.
* Pendant un **arr√™t serveur** : pertes en UDP, √©checs en TCP puis r√©tablissement au red√©marrage.
* Lors d‚Äôun **drop firewall** : aucun log re√ßu jusqu‚Äô√† suppression de la r√®gle de blocage.
* Apr√®s **rotation** : les logs continuent d‚Äô√™tre √©crits sans perte.

---

## 5) Nettoyage / Retour √† l‚Äô√©tat initial

Sur **machine1 (serveur)** :

```bash
# S'assurer qu‚Äôaucune r√®gle de test persiste
sudo nft list tables | grep -q test_syslog && sudo nft delete table inet test_syslog || true

# (Optionnel) Purger les traces de tests si besoin
sudo find /var/log/remote -type f -name "machine2.log*" -print -exec sudo truncate -s 0 {} \;
```

Sur **machine2 (client)** : aucun changement persistant √† nettoyer.

---

## 6) Astuces & Pi√®ges

* **UDP vs TCP** : UDP est l√©ger mais non garanti (pertes possibles) ; TCP apporte l‚ÄôACK et la reconnexion. Choisir selon criticit√© et volume.
* **Rate limiting** : rsyslog peut limiter certaines sources/facilities. Ajustez les *rulesets* et options `ratelimit.interval/ratelimit.burst` si des pertes apparaissent en rafale.
* **Templates & format** : par d√©faut Debian est souvent en RFC3164. Pour des parsers SIEM, envisagez RFC5424 (`RSYSLOG_TraditionalForwardFormat` vs `RSYSLOG_SyslogProtocol23Format`).
* **DNS/Hostnames** : si `machine2` n‚Äôa pas de r√©solution inverse correcte, `%HOSTNAME%` peut ne pas refl√©ter l‚Äôattendu. Utilisez `%fromhost-ip%` ou fixez `/etc/hosts`/DNS PTR.
* **Horodatage** : des horloges d√©salign√©es compliquent les corr√©lations temporelles ; activez `systemd-timesyncd` ou un NTP interne.
* **S√©curit√©** : ouvrez 514/TCP/UDP **uniquement** depuis les sous-r√©seaux clients autoris√©s (nftables), chiffrez c√¥t√© VPN si n√©cessaire.

---

## üßπ Nettoyage int√©gral de l‚Äôatelier Partie I

### 1Ô∏è‚É£ Sur le **client (machine2)**

```bash
echo "=== Nettoyage machine2 (client) ==="

# 1. Sauvegarder la configuration actuelle avant modification
sudo cp /etc/rsyslog.conf /etc/rsyslog.conf.bak.part1

# 2. Supprimer ou commenter la r√®gle d‚Äôenvoi vers le serveur
sudo sed -i '/@10\.10\.10\.1:514/s/^/#/' /etc/rsyslog.conf
sudo sed -i '/@@10\.10\.10\.1:514/s/^/#/' /etc/rsyslog.conf

# 3. Red√©marrer rsyslog pour revenir au mode local uniquement
sudo systemctl restart rsyslog

# 4. V√©rifier que rsyslog √©coute uniquement en local
sudo ss -tulpn | grep rsyslog || echo "rsyslog client nettoy√©"
```

üß≠ **R√©sultat attendu :**

* Aucun envoi r√©seau vers 10.10.10.1.
* Les journaux sont √† nouveau √©crits localement dans `/var/log/syslog`.

---

### 2Ô∏è‚É£ Sur le **serveur (machine1)**

```bash
echo "=== Nettoyage machine1 (serveur) ==="

# 1. Sauvegarde des fichiers modifi√©s
sudo cp /etc/rsyslog.conf /etc/rsyslog.conf.bak.part1
sudo [ -f /etc/rsyslog.d/remote.conf ] && sudo cp /etc/rsyslog.d/remote.conf /etc/rsyslog.d/remote.conf.bak.part1

# 2. Supprimer la configuration sp√©cifique √† la r√©ception distante
sudo sed -i '/imudp/ s/^/#/' /etc/rsyslog.conf
sudo sed -i '/imtcp/ s/^/#/' /etc/rsyslog.conf
sudo sed -i '/input(type="imudp"/ s/^/#/' /etc/rsyslog.conf
sudo sed -i '/input(type="imtcp"/ s/^/#/' /etc/rsyslog.conf

# 3. Supprimer le fichier de routage par h√¥te (si pr√©sent)
sudo rm -f /etc/rsyslog.d/remote.conf

# 4. Supprimer les logs re√ßus et le dossier d√©di√©
sudo rm -rf /var/log/remote

# 5. Red√©marrer rsyslog
sudo systemctl restart rsyslog

# 6. V√©rification finale
sudo ss -tulpn | grep ':514' || echo "Ports 514 ferm√©s ‚Äî nettoyage termin√©"
```

üß≠ **R√©sultat attendu :**

* Le service `rsyslog` n‚Äô√©coute plus sur le r√©seau (`ss` ne montre plus de port 514 ouvert).
* Le r√©pertoire `/var/log/remote` est supprim√©.
* Les fichiers de configuration sont revenus √† leur √©tat d‚Äôorigine (sauvegardes conserv√©es).

---

### 3Ô∏è‚É£ V√©rification finale des deux machines

```bash
echo "=== V√©rification globale ==="
for h in 10.10.10.1 10.10.10.2; do
  echo "----- $h -----"
  ssh $h 'sudo systemctl status rsyslog --no-pager | grep Active'
done
```

**Attendu :**

* Les deux services `rsyslog` sont actifs (`active (running)`).
* Plus de communication r√©seau entre client et serveur.

---

### 4Ô∏è‚É£ (Optionnel) Purge des paquets et journaux pour repartir de z√©ro

```bash
sudo apt purge -y rsyslog
sudo rm -rf /var/log/*
sudo apt install -y rsyslog
sudo systemctl enable --now rsyslog
```

‚ö†Ô∏è √Ä utiliser **uniquement** si vous voulez repartir d‚Äôun environnement vierge avant un nouvel atelier.

---
