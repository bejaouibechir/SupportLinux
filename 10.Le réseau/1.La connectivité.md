# Niveau 2 – Connectivité et services essentiels (Debian / VirtualBox)

---

## 🔹 Notion principale 3 : Routage et passerelles

### 📝 Introduction

Dans Debian, le routage permet de définir comment les paquets quittent la machine pour atteindre d’autres réseaux.  
Par défaut, une machine a une **passerelle par défaut** (gateway) qui permet d’accéder à Internet.  
Nous allons voir comment lister, ajouter et supprimer des routes, en utilisant **`ip`** (déjà installé) et éventuellement **`route`** si vous installez le paquet `net-tools`.

---

### 📌 Démo 1 : Vérifier la table de routage

Lister les routes avec `ip` (par défaut disponible) :

```bash
ip route show
```

Installer `net-tools` si vous voulez aussi la commande `route` :

```bash
sudo apt update
sudo apt install net-tools -y
```

Puis :

```bash
sudo route -n
```

- `-n` : affiche les adresses IP au lieu de tenter de résoudre les noms (plus rapide).

👉 **Résultat attendu** :  
Vous devez voir une ligne contenant `default` ou `0.0.0.0` → c’est la passerelle par défaut, souvent `192.168.56.1` en mode Host-Only sur VirtualBox.

et obtenu

```nginx
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0        0 enp0s8
192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 enp0s
```

### Ligne `0.0.0.0 192.168.1.1 0.0.0.0`

- **Destination = 0.0.0.0**  
  → C’est la route **par défaut** (tout ce qui ne correspond pas à un réseau connu).

- **Gateway = 192.168.1.1**  
  → La passerelle par défaut. Tous les paquets destinés à Internet ou à d’autres réseaux passent par cette IP.

- **Genmask = 0.0.0.0**  
  → Masque associé à 0.0.0.0 → signifie "tous les réseaux".

- **Flags = UG**
  
  - **U** : route active (Up).
  
  - **G** : utilise une Gateway (passerelle).

- **Metric = 100**  
  → Priorité de la route (plus bas = plus prioritaire).

- **Iface = enp0s8**  
  → L’interface réseau utilisée est `enp0s8`.

👉 **En clair** : tout trafic qui n’est pas dans un réseau local connu est envoyé vers **192.168.1.1** via `enp0s8`.

### Ligne `192.168.1.0 0.0.0.0 255.255.255.0`

- **Destination = 192.168.1.0**  
  → Réseau local auquel vous êtes connecté.

- **Gateway = 0.0.0.0**  
  → Pas de passerelle → les machines de ce réseau sont joignables **directement**.

- **Genmask = 255.255.255.0**  
  → Masque /24 (réseau de 256 adresses : de 192.168.1.0 à 192.168.1.255).

- **Flags = U**
  
  - **U** : route active.

- **Iface = enp0s8**  
  → Communication directe via l’interface `enp0s8`.

👉 **En clair** : toutes les machines du réseau **192.168.1.0/24** (par exemple 192.168.1.20) sont joignables directement sans passer par la gateway.

---

### 📌 Démo 2 : Ajouter une route spécifique

Supposons que vous ayez ajouté une deuxième carte réseau (`enp0s8`) en mode Host-Only avec IP `192.168.100.10`.  
Vous voulez atteindre le réseau `10.10.10.0/24` via la passerelle `192.168.100.1` :

```bash
sudo ip route add 10.10.10.0/24 via 192.168.100.1 dev enp0s8
```

Vérifier :

```bash
ip route show
```

👉 **Astuce / Piège** :  
Si la passerelle `192.168.100.1` n’existe pas (pas d’autre VM ou pas de DHCP sur ce réseau), la commande échouera avec *“Nexthop has invalid gateway”*.  
⚠️ Solution : soit vous créez une deuxième VM sur le réseau `192.168.100.0/24` avec l’IP `192.168.100.1`, soit vous choisissez une passerelle valide existante (par ex. VirtualBox DHCP).

---

### 📌 Démo 3 : Changer la passerelle par défaut

Changer la gateway par défaut pour passer par `192.168.56.1` :

```bash
sudo ip route replace default via 192.168.56.1 dev enp0s3
```

Tester la connectivité :

```bash
ping -c 4 8.8.8.8
```

👉 **Troubleshooting** :

- Si `ping` marche sur `8.8.8.8` mais pas sur `google.com` → problème DNS.

- Vérifiez `/etc/resolv.conf`.

---

### 🔧 Commandes & options utiles – Routage Debian

- `ip route show` → afficher table de routage

- `ip route add <réseau>/<masque> via <passerelle> dev <iface>` → ajouter route

- `ip route del <réseau>/<masque>` → supprimer route

- `ip route replace default via <gateway>` → changer gateway par défaut

- `route -n` (après `net-tools`) → voir routes rapides

---

## 🔹 Notion principale 4 : Outils de diagnostic

### 📝 Introduction

Diagnostiquer la connectivité est crucial. Debian fournit plusieurs outils : `ping`, `traceroute`, `mtr`, `dig`, `nslookup`, et `ss`.

---

### 📌 Démo 1 : Vérifier la connectivité avec `ping`

Tester la connectivité avec la passerelle VirtualBox (`192.168.56.1`) :

```bash
ping -c 4 192.168.56.1
```

Options utiles :

- `-c <n>` → envoyer *n* paquets

- `-i <s>` → intervalle entre paquets

- `-s <taille>` → taille du paquet

```bash
# -c 4  : envoyer exactement 4 paquets ICMP
# -i 1  : attendre 1 seconde entre chaque envoi
# -s 128: taille de la charge utile ICMP (payload) = 128 octets
#         (Taille totale ≈ 128 + 8 (entête ICMP) + 20 (entête IP) = 156 octets)

ping -c 4 -i 1 -s 128 192.168.56.1
```

---

### 📌 Démo 2 : Détecter un problème de chemin avec `traceroute`

Installer l’outil :

```bash
sudo apt install traceroute -y
```

Vérifier la route par défaut (si vous voulez tester Internet)

```bash
ip route show default
```

#### Premier pas sur le réseau local

**Objectif :** comprendre la sortie de base avec la passerelle VirtualBox (`192.168.1.1`).

```bash
# Lancer un traceroute simple vers la passerelle Host-Only
# -n : pas de résolution DNS (plus rapide, plus lisible)
# -i enp0s9 : forcer l’interface host-only
sudo traceroute -n -i enp0s9 192.168.1.1
```

Tracer le chemin vers Google DNS :

```bash
traceroute 8.8.8.8
```

**Objectif :** accélérer, limiter, clarifier l’affichage.

```bash
# -n   : pas de DNS
# -q 1 : 1 seule sonde par hop (plus rapide)
# -w 2 : délai d'attente 2 s par sonde
# -m 5 : maximum 5 sauts (utile en labo)
sudo traceroute -n -q 1 -w 2 -m 5 -i enp0s9 192.168.56.1
```

**Objectif :** montrer les variantes **ICMP** et **TCP** (parfois mieux acceptées par des firewalls).

```bash
# Variante ICMP (nécessite les privilèges RAW) :
sudo traceroute -I -n -i enp0s9 192.168.56.1

# Variante TCP SYN vers un port "ouvert" courant (443) :
# Utile quand UDP/ICMP sont filtrés sur le chemin.
sudo traceroute -T -p 443 -n -i enp0s9 192.168.56.1
```

---

### 📌 Démo 3 : Traceroute continu avec `mtr`

Installer :

```bash
sudo apt install mtr -y
```

Lancer :

```bash
mtr google.com
```

👉 Avantage : `mtr` combine `ping` + `traceroute` en temps réel.

---

### 📌 Démo 4 : Résolution DNS avec `dig`

- **`dig`** (Domain Information Groper) interroge le **DNS**.

- Il sert à **diagnostiquer** les problèmes de résolution (latence, cache, records manquants, filtrage, DNSSEC, etc.)

- **vérifier** les enregistrements (A/AAAA, MX, NS, TXT…), et à **comprendre** comment un nom est résolu

Installer :

```bash
sudo apt install dnsutils -y
```

Tester :

```bash
dig google.com
; <<>> DiG 9.20.11-4-Debian <<>> google.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 49960
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;google.com.                    IN      A

;; ANSWER SECTION:
google.com.             43      IN      A       142.251.37.46

;; Query time: 48 msec
;; SERVER: 8.8.8.8#53(8.8.8.8) (UDP)
;; WHEN: Mon Sep 29 17:38:40 CEST 2025
;; MSG SIZE  rcvd: 55
```

Ces commandes n’interrompent pas la connexion et vous aident à explorer rapidement.

```bash
# 1) Réponse courte (pratique pour scripts)
dig +short google.com A      # IPv4
dig +short google.com AAAA   # IPv6

# 2) Interroger un serveur précis (ici Cloudflare)
dig @1.1.1.1 google.com A

# 3) Voir le TTL restant (sortie complète) et comparer chez plusieurs résolveurs
dig @8.8.8.8 google.com A
dig @1.1.1.1 google.com A

# 4) Remonter la chaîne d'autorité (root -> .com -> google.com)
dig +trace google.com

# 5) Demander les serveurs autoritatifs pour le domaine
dig google.com NS +nocomments +noquestion

# 6) Tester DNSSEC (si le résolveur valide, vous verrez le flag AD)
dig +dnssec google.com A
# Si le résolveur ne valide pas, pas de AD. Pour forcer la vérification côté client,
# interrogez un résolveur qui valide (ex: 1.1.1.1, 9.9.9.9) et observez le flag AD.

# 7) Forcer TCP (utile quand UDP est filtré ou qu’il y a troncature)
dig +tcp google.com A

# 8) Lookup inverse (rDNS) sur une IP
dig -x 142.251.37.46 +short
```

# Quand utiliser `dig` en pratique

- **Après un changement DNS** (A/AAAA, CNAME, MX…) : vérifier la valeur retournée, le TTL, et la propagation via `@` différents résolveurs.

- **Pannes applicatives** : confirmer que le **hostname** pointe vers la bonne IP et que la latence DNS n’est pas la cause.

- **Mail** : vérifier **MX** et **TXT/SPF**, **DKIM** (TXT sur `selector._domainkey.example.com`).

- **CDN / géo-routing** : comprendre pourquoi une IP diffère selon le lieu/résolveur.

- **Sécurité** : valider **DNSSEC** (`+dnssec` / flag **AD**), détecter du **NXDOMAIN**, des **CNAME** inattendus, etc.

---

### 📌 Démo 5 : Vérifier les sockets avec `ss`

Lister les services en écoute :

```bash
ss -tulnp
```

Options utiles :

- `-t` → TCP

- `-u` → UDP

- `-l` → listening

- `-n` → pas de résolution DNS

- `-p` → affiche le PID et nom du processus

**Exemple de sortie:**

```bash
ss -tulnp
Netid      State       Recv-Q      Send-Q           Local Address:Port            Peer Address:Port     Process
udp        UNCONN      0           0                      0.0.0.0:5353                 0.0.0.0:*
udp        UNCONN      0           0                      0.0.0.0:39213                0.0.0.0:*
udp        UNCONN      0           0                         [::]:5353                    [::]:*
udp        UNCONN      0           0                         [::]:45192                   [::]:*
tcp        LISTEN      0           128                  127.0.0.1:6011                 0.0.0.0:*
tcp        LISTEN      0           128                  127.0.0.1:6010                 0.0.0.0:*
tcp        LISTEN      0           511                    0.0.0.0:80                   0.0.0.0:*
tcp        LISTEN      0           128                    0.0.0.0:22                   0.0.0.0:*
tcp        LISTEN      0           100                    0.0.0.0:25                   0.0.0.0:*
tcp        LISTEN      0           80                192.168.1.16:3306                 0.0.0.0:*
tcp        LISTEN      0           4096                 127.0.0.1:631                  0.0.0.0:*
tcp        LISTEN      0           511                       [::]:80                      [::]:*
tcp        LISTEN      0           128                       [::]:22                      [::]:*
tcp        LISTEN      0           100                       [::]:25                      [::]:*
tcp        LISTEN      0           4096                     [::1]:631                     [::]:*
tcp        LISTEN      0           4096                         *:9090                       *:*
tcp        LISTEN      0           4096                         *:9100                       *:*
tcp        LISTEN      0           4096                         *:9104                       *:*
tcp        LISTEN      0           4096                         *:3000                       *:*
tcp        LISTEN      0           128                      [::1]:6011                    [::]:*
tcp        LISTEN      0           128                      [::1]:6010                    [::]:*
```

**State** : état (`LISTEN` pour TCP ; `UNCONN` pour UDP).

**Recv-Q** : file d’attente en réception.

**Send-Q** : file d’attente émission.

- **Local Address:Port** : IP/port **bindés** par le service.
  
  - `0.0.0.0` = toutes les IPv4, `[::]` = toutes les IPv6, `127.0.0.1` / `[::1]` = loopback.

- **Peer Address:Port** : paire distante (ici `*` = n’importe qui).

- **Process** : PID/nom (vide si la commande n’a pas tourné en root ou si masqué par la politique système).

---

## 🔹 Notion principale 5 : Service SSH

### 📝 Introduction

SSH est indispensable pour se connecter à distance et administrer un serveur. Sur Debian, le paquet est `openssh-server`.

---

### 📌 Démo 1 : Installation du serveur SSH

Mettre à jour et installer :

```bash
sudo apt update
sudo apt install openssh-server -y
```

Vérifier l’état :

```bash
systemctl status ssh
```

---

### 📌 Démo 2 : Connexion SSH

Depuis une autre machine du réseau Host-Only :

```bash
ssh user@192.168.56.101
```

Options utiles :

- `-p <port>` → utiliser un port différent

- `-i <clé>` → clé privée

---

### 

### ---

# ✅ Récapitulatif des commandes du Niveau 2

- **Routage**
  
  - `ip route show/add/del/replace`
  
  - `route -n` (si installé via `net-tools`)

- **Diagnostic**
  
  - `ping -c -i -s`
  
  - `traceroute -n -I`
  
  - `mtr <hôte>`
  
  - `dig +short +trace`
  
  - `ss -tulnp`

- **SSH**
  
  - `apt install openssh-server`
  
  - `systemctl status|restart ssh`
  
  - `ssh -p -i`
