

# 🧪 Exercice 7: Tutoriel complet — xinetd + HTTP « inetd-style » en Python (sans Flask)

## 🎯 Objectifs

1. Installer et activer `xinetd`.

2. Créer un **petit handler HTTP** en Python qui parle via `stdin/stdout` (style inetd).

3. Déclarer un service `flaskx` (port **5050/tcp**) et configurer `xinetd` pour le lancer **à la demande**.

4. Vérifier avec `curl`.

5. Désactiver proprement.

---

## 1) Installer/activer xinetd et outils de base

### 📝 Explication

On installe `xinetd`, `python3` (interpréteur) et `curl` (pour tester). On active le service.

```bash
sudo apt update
sudo apt install -y xinetd python3 curl
sudo systemctl enable --now xinetd
```

---

## 2) Créer le programme Python « inetd-style »

### 📝 Explication

Contrairement à Flask (qui ouvre lui-même un socket), un service inetd doit **lire la requête HTTP depuis l’entrée standard** et **écrire la réponse sur la sortie standard**.  
Ce script renvoie une réponse **HTTP/1.0** valide (évite l’erreur `curl: (1) Received HTTP/0.9 when not allowed`).

### 📄 Nom du script : `/usr/local/bin/inetd_http.py`

**Ce qu’il fait :** lit l’entrée, puis envoie une petite page texte.

```bash
sudo nano /usr/local/bin/inetd_http.py
```

```python
import sys

# Consommer la requête entrante (simple lecture)
try:
    sys.stdin.read(2048)
except Exception:
    pass

body = "Hello depuis Python (inetd-style) !\n"
resp = (
    "HTTP/1.0 200 OK\r\n"
    "Content-Type: text/plain; charset=utf-8\r\n"
    f"Content-Length: {len(body.encode('utf-8'))}\r\n"
    "Connection: close\r\n"
    "\r\n"
    f"{body}"
)

sys.stdout.write(resp)
sys.stdout.flush()
```

### 📝 Explication

On rend le script exécutable pour que `xinetd` puisse le lancer.

```bash
sudo chmod +x /usr/local/bin/inetd_http.py
```

---

## 3) Déclarer le service `flaskx` dans `/etc/services`

### 📝 Explication

On associe le nom du service à son port.

```bash
echo "flaskx    5050/tcp" | sudo tee -a /etc/services
```

Vérification :

```bash
grep '^flaskx' /etc/services
```

---

## 4) Configurer xinetd pour lancer le handler Python

### 📝 Explication

`xinetd` va écouter le **port 5050**. À chaque connexion, il **lance `python3 /usr/local/bin/inetd_http.py`** en connectant le socket réseau à `stdin/stdout` du processus.

### 📄 Fichier : `/etc/xinetd.d/flaskx`

**Ce qu’il fait :** définition du service, lancement « on demand », utilisateur non privilégié.

```bash
sudo nano /etc/xinetd.d/flaskx
```

```ini
service flaskx
{
    disable         = no
    socket_type     = stream
    protocol        = tcp
    port            = 5050
    wait            = no
    user            = nobody
    server          = /usr/bin/python3
    server_args     = /usr/local/bin/inetd_http.py
}
```

> Astuce sécu : `user = nobody` évite d’exécuter le script en root.  
> Si tu veux des logs détaillés, tu peux ajouter :  
> `log_on_success += PID HOST DURATION` et `log_on_failure += HOST ATTEMPT`.

---

## 5) Redémarrer xinetd et vérifier l’écoute

### 📝 Explication

On recharge la conf. Si tout est bon, le port **5050** est à l’écoute par `xinetd`.

```bash
sudo systemctl restart xinetd
sudo systemctl status xinetd --no-pager
sudo ss -tlnp | grep 5050
```

**Résultat attendu :**

```
LISTEN 0 5 *:5050 *:* users:(("xinetd",pid=...,fd=...))
```

---

## 6) Tester avec curl

### 📝 Explication

On envoie une requête HTTP et on vérifie la réponse. Le script renvoie **HTTP/1.0 200 OK**.

```bash
curl -v http://127.0.0.1:5050/
```

**Extrait attendu :**

```
> GET / HTTP/1.1
< HTTP/1.0 200 OK
< Content-Type: text/plain; charset=utf-8
< Content-Length: 35
Hello depuis Python (inetd-style) !
```

---

## 7) Désactiver proprement le service

### 📝 Explication

On bascule le service en `disable = yes` et on redémarre.

```bash
sudo sed -i 's/disable.*/disable = yes/' /etc/xinetd.d/flaskx
sudo systemctl restart xinetd
sudo ss -tlnp | grep 5050
```

**Résultat attendu :** plus d’écoute sur 5050.

---

## 🔧 Dépannage rapide

- **`curl: (1) Received HTTP/0.9 when not allowed`**  
  → Le script ne renvoie pas d’entête HTTP/1.0/1.1 valide. Utilise le handler ci-dessus (avec `HTTP/1.0 200 OK` + `Content-Length`).

- **Le port 5050 n’apparaît pas après restart**
  
  1. Relire le fichier `/etc/xinetd.d/flaskx` (erreur de syntaxe ?)
  
  2. Vérifier que `/etc/services` contient `flaskx 5050/tcp`
  
  3. Voir les logs :
     
     ```bash
     sudo tail -n 100 /var/log/syslog | grep -i xinetd
     ```

- **Permission denied**  
  → Vérifier exécutable :
  
  ```bash
  sudo chmod 755 /usr/local/bin/inetd_http.py
  sudo chown root:root /usr/local/bin/inetd_http.py
  ```

- **Écouter seulement en local** (optionnel)  
  → Dans `/etc/xinetd.d/flaskx`, ajoute `bind = 127.0.0.1` pour restreindre.

### 8) Nettoyage

```bash

```
