

# ðŸ§ª Exercice 7: Tutoriel complet â€” xinetd + HTTP Â« inetd-style Â» en Python (sans Flask)

## ðŸŽ¯ Objectifs

1. Installer et activer `xinetd`.

2. CrÃ©er un **petit handler HTTP** en Python qui parle via `stdin/stdout` (style inetd).

3. DÃ©clarer un service `flaskx` (port **5050/tcp**) et configurer `xinetd` pour le lancer **Ã  la demande**.

4. VÃ©rifier avec `curl`.

5. DÃ©sactiver proprement.

---

## 1) Installer/activer xinetd et outils de base

### ðŸ“ Explication

On installe `xinetd`, `python3` (interprÃ©teur) et `curl` (pour tester). On active le service.

```bash
sudo apt update
sudo apt install -y xinetd python3 curl
sudo systemctl enable --now xinetd
```

---

## 2) CrÃ©er le programme Python Â« inetd-style Â»

### ðŸ“ Explication

Contrairement Ã  Flask (qui ouvre lui-mÃªme un socket), un service inetd doit **lire la requÃªte HTTP depuis lâ€™entrÃ©e standard** et **Ã©crire la rÃ©ponse sur la sortie standard**.  
Ce script renvoie une rÃ©ponse **HTTP/1.0** valide (Ã©vite lâ€™erreur `curl: (1) Received HTTP/0.9 when not allowed`).

### ðŸ“„ Nom du script : `/usr/local/bin/inetd_http.py`

**Ce quâ€™il fait :** lit lâ€™entrÃ©e, puis envoie une petite page texte.

```bash
sudo nano /usr/local/bin/inetd_http.py
```

```python
import sys

# Consommer la requÃªte entrante (simple lecture)
try:
    sys.stdin.read(2048)
except Exception:
    pass

body = "Hello depuis Python (inetd-style) !\n"
resp = (
    "HTTP/1.0 200 OK\r\n"
    "Content-Type: text/plain; charset=utf-8\r\n"
    f"Content-Length: {len(body.encode('utf-8'))}\r\n"
    "Connection: close\r\n"
    "\r\n"
    f"{body}"
)

sys.stdout.write(resp)
sys.stdout.flush()
```

### ðŸ“ Explication

On rend le script exÃ©cutable pour que `xinetd` puisse le lancer.

```bash
sudo chmod +x /usr/local/bin/inetd_http.py
```

---

## 3) DÃ©clarer le service `flaskx` dans `/etc/services`

### ðŸ“ Explication

On associe le nom du service Ã  son port.

```bash
echo "flaskx    5050/tcp" | sudo tee -a /etc/services
```

VÃ©rification :

```bash
grep '^flaskx' /etc/services
```

---

## 4) Configurer xinetd pour lancer le handler Python

### ðŸ“ Explication

`xinetd` va Ã©couter le **port 5050**. Ã€ chaque connexion, il **lance `python3 /usr/local/bin/inetd_http.py`** en connectant le socket rÃ©seau Ã  `stdin/stdout` du processus.

### ðŸ“„ Fichier : `/etc/xinetd.d/flaskx`

**Ce quâ€™il fait :** dÃ©finition du service, lancement Â« on demand Â», utilisateur non privilÃ©giÃ©.

```bash
sudo nano /etc/xinetd.d/flaskx
```

```ini
service flaskx
{
    disable         = no
    socket_type     = stream
    protocol        = tcp
    port            = 5050
    wait            = no
    user            = nobody
    server          = /usr/bin/python3
    server_args     = /usr/local/bin/inetd_http.py
}
```

> Astuce sÃ©cu : `user = nobody` Ã©vite dâ€™exÃ©cuter le script en root.  
> Si tu veux des logs dÃ©taillÃ©s, tu peux ajouter :  
> `log_on_success += PID HOST DURATION` et `log_on_failure += HOST ATTEMPT`.

---

## 5) RedÃ©marrer xinetd et vÃ©rifier lâ€™Ã©coute

### ðŸ“ Explication

On recharge la conf. Si tout est bon, le port **5050** est Ã  lâ€™Ã©coute par `xinetd`.

```bash
sudo systemctl restart xinetd
sudo systemctl status xinetd --no-pager
sudo ss -tlnp | grep 5050
```

**RÃ©sultat attendu :**

```
LISTEN 0 5 *:5050 *:* users:(("xinetd",pid=...,fd=...))
```

---

## 6) Tester avec curl

### ðŸ“ Explication

On envoie une requÃªte HTTP et on vÃ©rifie la rÃ©ponse. Le script renvoie **HTTP/1.0 200 OK**.

```bash
curl -v http://127.0.0.1:5050/
```

**Extrait attendu :**

```
> GET / HTTP/1.1
< HTTP/1.0 200 OK
< Content-Type: text/plain; charset=utf-8
< Content-Length: 35
Hello depuis Python (inetd-style) !
```

---

## 7) DÃ©sactiver proprement le service

### ðŸ“ Explication

On bascule le service en `disable = yes` et on redÃ©marre.

```bash
sudo sed -i 's/disable.*/disable = yes/' /etc/xinetd.d/flaskx
sudo systemctl restart xinetd
sudo ss -tlnp | grep 5050
```

**RÃ©sultat attendu :** plus dâ€™Ã©coute sur 5050.

---

## ðŸ”§ DÃ©pannage rapide

- **`curl: (1) Received HTTP/0.9 when not allowed`**  
  â†’ Le script ne renvoie pas dâ€™entÃªte HTTP/1.0/1.1 valide. Utilise le handler ci-dessus (avec `HTTP/1.0 200 OK` + `Content-Length`).

- **Le port 5050 nâ€™apparaÃ®t pas aprÃ¨s restart**
  
  1. Relire le fichier `/etc/xinetd.d/flaskx` (erreur de syntaxe ?)
  
  2. VÃ©rifier que `/etc/services` contient `flaskx 5050/tcp`
  
  3. Voir les logs :
     
     ```bash
     sudo tail -n 100 /var/log/syslog | grep -i xinetd
     ```

- **Permission denied**  
  â†’ VÃ©rifier exÃ©cutable :
  
  ```bash
  sudo chmod 755 /usr/local/bin/inetd_http.py
  sudo chown root:root /usr/local/bin/inetd_http.py
  ```

- **Ã‰couter seulement en local** (optionnel)  
  â†’ Dans `/etc/xinetd.d/flaskx`, ajoute `bind = 127.0.0.1` pour restreindre.

### 8) Nettoyage

```bash

```
