# üß± Atelier : DMZ avec service Flask interne et honeypot Flask

## 1Ô∏è‚É£ Contexte & Objectif

L‚Äôobjectif de cet atelier est de simuler un r√©seau DMZ complet :

* un **pare-feu Linux** g√©rant trois zones r√©seau : **WAN**, **DMZ** et **LAN** ;
* un **service Flask r√©el** h√©berg√© dans le **LAN** (accessible uniquement depuis le LAN) ;
* un **honeypot Flask factice** h√©berg√© dans la **DMZ**, expos√© pour attirer les requ√™tes suspectes.

Le tout permettra de tester la s√©paration des flux, le NAT et les r√®gles de filtrage iptables.

---

## 2Ô∏è‚É£ Pr√©paration de l‚Äôenvironnement

### Mat√©riel virtuel recommand√© (VirtualBox)

| Machine      | R√¥le                            | Interfaces                                       | Adresses                  |
| ------------ | ------------------------------- | ------------------------------------------------ | ------------------------- |
| **machine1** | Pare-feu + DMZ                  | `enp0s3` NAT (WAN) / `enp0s8` DMZ / `enp0s9` LAN | 10.10.10.1 / 192.168.50.1 |
| **machine2** | Client LAN + Service Flask r√©el | `enp0s3` LAN                                     | 192.168.50.2              |

---

### Installation des d√©pendances

#### Sur **machine1 (pare-feu + DMZ)** :

```bash
sudo apt update
sudo apt install -y python3 python3-pip iptables-persistent curl
```

#### Sur **machine2 (client LAN)** :

```bash
sudo apt update
sudo apt install -y python3 python3-pip curl
```

---

## 3Ô∏è‚É£ Configuration r√©seau

### Sur **machine1** :

```bash
# Interface DMZ
sudo ip addr add 10.10.10.1/24 dev enp0s8
sudo ip link set enp0s8 up

# Interface LAN
sudo ip addr add 192.168.50.1/24 dev enp0s9
sudo ip link set enp0s9 up
```

### Sur **machine2** :

```bash
sudo ip addr add 192.168.50.2/24 dev enp0s3
sudo ip link set enp0s3 up
sudo ip route add default via 192.168.50.1
```

**V√©rification :**

```bash
ping -c 2 192.168.50.1
```

Doit r√©pondre.

---

## 4Ô∏è‚É£ Activer le routage IP sur le pare-feu

### Sur **machine1** :

```bash
echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward
sudo bash -c 'echo "net.ipv4.ip_forward=1" > /etc/sysctl.d/99-ipforward.conf'
sudo sysctl --system
```

**V√©rifier :**

```bash
sysctl net.ipv4.ip_forward
```

R√©sultat attendu : `net.ipv4.ip_forward = 1`

---

## 5Ô∏è‚É£ D√©ployer le honeypot Flask dans la DMZ

### Sur **machine1** :

Cr√©er le dossier de service :

```bash
sudo mkdir -p /opt/honeypot
```

Cr√©er le script :

```bash
sudo nano /opt/honeypot/app.py
```

Contenu :

```python
#!/usr/bin/env python3
from flask import Flask, request
app = Flask(__name__)

@app.route('/')
def index():
    with open("/var/log/honeypot_access.log", "a") as f:
        f.write(f"{request.remote_addr} - {request.method} {request.path}\n")
    return "<h1>Service Web</h1><p>Bienvenue dans la DMZ.</p>", 200

if __name__ == '__main__':
    app.run(host='10.10.10.1', port=8080)
```

Appliquer les droits :

```bash
sudo chmod +x /opt/honeypot/app.py
sudo touch /var/log/honeypot_access.log
sudo chmod 666 /var/log/honeypot_access.log
```

Cr√©er le service systemd :

```bash
sudo nano /etc/systemd/system/honeypot.service
```

Contenu :

```ini
[Unit]
Description=Honeypot Flask Service (DMZ)
After=network.target

[Service]
ExecStart=/usr/bin/python3 /opt/honeypot/app.py
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

D√©marrer et activer :

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now honeypot.service
sudo systemctl status honeypot.service --no-pager
```

Test local :

```bash
curl http://10.10.10.1:8080
```

---

## 6Ô∏è‚É£ D√©ployer le service Flask interne (r√©el)

### Sur **machine2** :

Cr√©er le dossier :

```bash
sudo mkdir -p /opt/internal_service
```

Cr√©er le fichier :

```bash
sudo nano /opt/internal_service/app.py
```

Contenu :

```python
#!/usr/bin/env python3
from flask import Flask
app = Flask(__name__)

@app.route('/')
def home():
    return "<h1>Service interne</h1><p>Acc√®s r√©serv√© au LAN.</p>", 200

if __name__ == '__main__':
    app.run(host='192.168.50.2', port=5000)
```

Appliquer les droits :

```bash
sudo chmod +x /opt/internal_service/app.py
```

Cr√©er le service systemd :

```bash
sudo nano /etc/systemd/system/internal.service
```

Contenu :

```ini
[Unit]
Description=Service Flask interne (LAN)
After=network.target

[Service]
ExecStart=/usr/bin/python3 /opt/internal_service/app.py
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

Activer et d√©marrer :

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now internal.service
sudo systemctl status internal.service --no-pager
```

Test :

```bash
curl http://192.168.50.2:5000
```

---

## 7Ô∏è‚É£ Configurer le pare-feu (iptables)

### Sur **machine1** :

Politique restrictive :

```bash
sudo iptables -P INPUT DROP
sudo iptables -P FORWARD DROP
sudo iptables -P OUTPUT ACCEPT
sudo iptables -A INPUT -i lo -j ACCEPT
sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
```

Autoriser SSH depuis LAN :

```bash
sudo iptables -A INPUT -i enp0s9 -p tcp --dport 22 -j ACCEPT
```

Autoriser HTTP/8080 vers la DMZ depuis WAN et LAN :

```bash
sudo iptables -A FORWARD -i enp0s3 -o enp0s8 -p tcp --dport 8080 -j ACCEPT
sudo iptables -A FORWARD -i enp0s9 -o enp0s8 -p tcp --dport 8080 -j ACCEPT
```

Interdire WAN ‚Üí LAN :

```bash
sudo iptables -A FORWARD -i enp0s3 -o enp0s9 -j DROP
```

Autoriser retour connexions :

```bash
sudo iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
```

NAT sortant :

```bash
sudo iptables -t nat -A POSTROUTING -s 192.168.50.0/24 -o enp0s3 -j MASQUERADE
```

Sauvegarder :

```bash
sudo netfilter-persistent save
```

---

## 8Ô∏è‚É£ V√©rifications

Depuis **machine2** :

```bash
# Acc√®s au service interne
curl http://192.168.50.2:5000

# Acc√®s au honeypot DMZ
curl http://10.10.10.1:8080

# Test d‚Äôacc√®s Internet via NAT
curl -I http://example.com
```

Depuis une **machine externe (WAN)** :

```bash
curl http://<IP_publique_machine1>:8080
```

R√©sultats attendus :

* Le honeypot DMZ r√©pond √† toutes les requ√™tes.
* Le service interne ne r√©pond qu‚Äôau LAN.
* Le log `/var/log/honeypot_access.log` s‚Äôenrichit √† chaque requ√™te.

---

## 9Ô∏è‚É£ Nettoyage / Rollback

### Sur **machine1** :

```bash
sudo systemctl disable --now honeypot.service
sudo rm -f /etc/systemd/system/honeypot.service
sudo rm -rf /opt/honeypot /var/log/honeypot_access.log

sudo iptables -F
sudo iptables -t nat -F
sudo iptables -X
sudo iptables -P INPUT ACCEPT
sudo iptables -P FORWARD ACCEPT
sudo netfilter-persistent save
```

### Sur **machine2** :

```bash
sudo systemctl disable --now internal.service
sudo rm -f /etc/systemd/system/internal.service
sudo rm -rf /opt/internal_service
sudo ip addr flush dev enp0s3
```

---

## üîç 10Ô∏è‚É£ Astuces & Pi√®ges

* Le honeypot doit √™tre **isol√©** : ne pas lier de base de donn√©es ni de fichiers sensibles.
* Utiliser `ss -tuln` pour surveiller les ports ouverts.
* Toujours valider la pr√©sence des logs (`tail -f /var/log/honeypot_access.log`).
* En production, placer le honeypot dans une **DMZ isol√©e**, non connect√©e au LAN.

---

# Test de la DMZ

## Contexte & objectif

Valider que la DMZ fonctionne comme pr√©vu :

1. le **honeypot** (DMZ) est accessible depuis WAN et LAN ;
2. le **service interne** (LAN) est accessible **seulement** depuis le LAN ;
3. le **NAT** permet au LAN d‚Äôacc√©der √† Internet ;
4. les r√®gles iptables bloquent les flux interdits (WAN‚ÜíLAN) et autorisent les flux attendus ;
5. les logs du honeypot enregistrent les requ√™tes.

---

## Pr√©paration rapide (o√π ex√©cuter)

* **machine1** : pare-feu + DMZ (ex√©cuter ici les commandes marqu√©es `machine1:`)
* **machine2** : client LAN + service interne (ex√©cuter ici les commandes marqu√©es `machine2:`)
* **machine externe / h√¥te de test WAN** : pour tester acc√®s depuis Internet (ou utiliser VirtualBox port-forward).

---

## 1) V√©rifications d‚Äô√©tat de base (interfaces, routage, forwarding)

machine1:

```bash
# V√©rifier adresses et interfaces
ip -4 addr show enp0s3 enp0s8 enp0s9

# V√©rifier l'√©tat du routage IP
sysctl net.ipv4.ip_forward

# V√©rifier √©coute services (honeypot)
ss -tlnp | grep -E '8080|http'
```

Attendu :

* `enp0s8` a 10.10.10.1/24, `enp0s9` a 192.168.50.1/24.
* `net.ipv4.ip_forward = 1`.
* Processus Python/Flask √©coute sur 10.10.10.1:8080.

machine2:

```bash
ip -4 addr show enp0s3
ip route show
ss -tlnp | grep 5000
```

Attendu :

* `enp0s3` = 192.168.50.2/24, route par d√©faut via 192.168.50.1.
* Service interne √©coute sur 192.168.50.2:5000.

---

## 2) Tests fonctionnels simples (o√π : machine2 et machine1)

### 2.1 Acc√®s service interne (depuis LAN)

machine2:

```bash
# Tester service interne
curl -sS -D - http://192.168.50.2:5000 | head -n 10
```

Attendu : r√©ponse HTTP 200 et contenu HTML du service interne.

### 2.2 Acc√®s honeypot depuis LAN

machine2:

```bash
curl -sS -D - http://10.10.10.1:8080 | head -n 10
```

Attendu : r√©ponse HTTP 200 et contenu du honeypot. V√©rifier log sur machine1.

machine1:

```bash
# V√©rifier que le honeypot a logg√© la requ√™te
sudo tail -n 20 /var/log/honeypot_access.log
```

Attendu : ligne avec l'adresse de machine2.

### 2.3 Acc√®s honeypot depuis WAN (machine externe)

sur machine externe (ou h√¥te qui peut atteindre l'IP publique / port-forward) :

```bash
curl -sS -D - "http://<IP_publique_machine1>:8080" | head -n 10
```

Attendu : r√©ponse HTTP 200 (si NAT/port-forward configur√©).

---

## 3) Tests d‚Äôisolation (n√©gatifs) ‚Äî s‚Äôassurer que WAN ne touche pas le LAN

### 3.1 Depuis WAN tenter d‚Äôatteindre le service interne (doit √©chouer)

machine externe:

```bash
curl -sS -I --connect-timeout 5 http://192.168.50.2:5000 || echo "echec attendu"
```

Attendu : √©chec (timeout ou connection refused).

### 3.2 Depuis machine1 (pare-feu) v√©rifier que la r√®gle WAN‚ÜíLAN existe

machine1:

```bash
sudo iptables -L FORWARD -n --line-numbers
```

Attendu : r√®gle explicite DROP pour `-i enp0s3 -o enp0s9` ou comportement bloquant par politique.

---

## 4) Test NAT Internet pour le LAN

machine2:

```bash
# V√©rifier r√©solution et acc√®s HTTP - simple test
curl -I https://example.com
```

Attendu : 200/301/302 ou en-t√™tes HTTP, indiquant que la connexion sortante via MASQUERADE fonctionne.

Si √©chec :

* sur machine1 v√©rifier rule nat :

```bash
sudo iptables -t nat -L POSTROUTING -n -v
```

* v√©rifier connectivity from machine1 to Internet:

```bash
curl -I https://example.com
```

---

## 5) Tests de conformit√© des r√®gles iptables (compteurs)

machine1:

```bash
# Observer compteurs pour r√®gles importantes (FORWARD et NAT)
sudo iptables -L FORWARD -n -v --line-numbers
sudo iptables -t nat -L POSTROUTING -n -v
```

Attendu : compteurs augmentent quand on effectue les tests (FORWARD pour HTTP vers DMZ, nat POSTROUTING pour les connexions LAN‚ÜíWAN).

---

## 6) Tests de s√©curit√© / simulation d‚Äôattaque (honeypot observateur)

### 6.1 Requ√™te "suspecte" vers honeypot (tester logging)

machine externe:

```bash
curl -sS -A "sqlmap/1.0" -X GET "http://<IP_publique_machine1>:8080/?id=1' OR '1'='1" -o /dev/null -w "%{http_code}\n"
```

machine1:

```bash
sudo tail -n 50 /var/log/honeypot_access.log
```

Attendu : la requ√™te appara√Æt dans le log honeypot. Ceci montre que le honeypot capture des tentatives.

### 6.2 Scan de ports depuis WAN (simuler reconnaissance)

machine externe:

```bash
# Exemple si nmap disponible
nmap -Pn -p 1-2000 <IP_publique_machine1>
```

Attendu : voir 8080 ouvert (honeypot), ports LAN ferm√©s depuis WAN.

‚ö†Ô∏è Faire les scans uniquement sur vos propres environnements.

---

## 7) Capture de paquets pour diagnostic (tcpdump)

machine1 (ex√©cuter en root et arr√™ter apr√®s capture) :

```bash
# Capturer HTTP vers DMZ pendant 30s (√©crire pcap pour analyse)
sudo timeout 30 tcpdump -i enp0s8 tcp port 8080 -w /tmp/honeypot_http.pcap
# Voir r√©sum√©
sudo tcpdump -r /tmp/honeypot_http.pcap -n -tttt | head -n 40
```

Attendu : paquets montrant connexions source‚Üí10.10.10.1:8080.

---

## 8) V√©rifications systemd et processus

machine1:

```bash
sudo systemctl status honeypot.service --no-pager
ps aux | grep -E 'honeypot|python' | grep -v grep
```

machine2:

```bash
sudo systemctl status internal.service --no-pager
ps aux | grep -E 'internal_service|python' | grep -v grep
```

Attendu : services actifs (active (running)).

---

## 9) Tests de r√©silience (sc√©narios de panne et restauration)

### Simuler perte de service honeypot et v√©rifier alerte

machine1:

```bash
# arr√™ter honeypot
sudo systemctl stop honeypot.service

# v√©rifier que port 8080 n'est plus √† l'√©coute
ss -tlnp | grep 8080 || echo "honeypot stopped OK"

# red√©marrer
sudo systemctl start honeypot.service
```

### Simuler coupure nat pour LAN

machine1:

```bash
# retirer rule nat temporairement (notez la sauvegarde avant)
sudo iptables -t nat -D POSTROUTING -s 192.168.50.0/24 -o enp0s3 -j MASQUERADE

# v√©rifier que machine2 ne peut plus atteindre internet
# machine2: curl -I https://example.com

# restaurer la r√®gle (r√©-ex√©cuter la commande MASQUERADE vue dans l'atelier)
sudo iptables -t nat -A POSTROUTING -s 192.168.50.0/24 -o enp0s3 -j MASQUERADE
```

Attendu : apr√®s suppression du MASQUERADE, machine2 perd l‚Äôacc√®s Internet ; restauration r√©tablit l‚Äôacc√®s.

---

## 10) Collecte d‚Äôevidence (logs & sorties) ‚Äî utile pour le cours

Sur machine1 rassembler :

```bash
# iptables rules
sudo iptables -L -n -v > /tmp/iptables_forward.txt
sudo iptables -t nat -L -n -v > /tmp/iptables_nat.txt

# services status
sudo systemctl status honeypot.service --no-pager > /tmp/honeypot_status.txt

# honeypot logs
sudo tail -n 200 /var/log/honeypot_access.log > /tmp/honeypot_access_excerpt.txt
```

Transf√©rer ces fichiers pour analyse ou inclusion dans le rapport.

---

## 11) Nettoyage rapide apr√®s tests (o√π ex√©cuter)

machine1:

```bash
# remettre politiques permissives si vous terminez
sudo iptables -F
sudo iptables -t nat -F
sudo iptables -P INPUT ACCEPT
sudo iptables -P FORWARD ACCEPT
sudo netfilter-persistent save

# arr√™ter honeypot et supprimer fichiers si souhait√©
sudo systemctl disable --now honeypot.service
sudo rm -rf /opt/honeypot /var/log/honeypot_access.log
```

machine2:

```bash
sudo systemctl disable --now internal.service
sudo rm -rf /opt/internal_service
sudo ip addr flush dev enp0s3
```

---

## Tips & pi√®ges rapides

* Toujours tester **localement** avant d‚Äôexposer au WAN.
* Attention aux droits des logs (ne jamais laisser fichiers de log world-writable en production).
* Ne jamais publier un honeypot connect√© √† des syst√®mes sensibles ; isolez-le.
* Utiliser `conntrack -L` (si install√©) pour observer l‚Äô√©tat des connexions.
* Pour debugging r√©seau, `tcpdump` + `ss` + `iptables -v -L` sont vos alli√©s.
