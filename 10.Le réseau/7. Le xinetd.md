Parfait ğŸ‘Œ On enchaÃ®ne avec **lâ€™Exercice 7 â€“ inetd / xinetd**, comme proposÃ© dans le document.  
Ces dÃ©mons sont utilisÃ©s pour lancer des services *Ã  la demande* au lieu de les laisser tourner en continu, ce qui illustre bien la philosophie Unix de lâ€™efficacitÃ©.

---

# ğŸ§ª Exercice 7 : Services Ã  la demande avec inetd  xinetd

## PrÃ©sentation

`xinetd` (*Extended Internet Service Daemon*) est un **super-serveur** sous Linux/Unix.  
PlutÃ´t que de laisser tourner plusieurs dÃ©mons en continu (FTP, Telnet, echo, etc.), il sâ€™occupe de :

- **Ã©couter les ports** Ã  la place de ces services,

- **lancer le service demandÃ© uniquement quand une connexion arrive**,

- **arrÃªter le service** une fois la session terminÃ©e.

ğŸ‘‰ On lâ€™appelle donc un **dÃ©mon dâ€™attente** ou **gestionnaire de services Ã  la demande**.

---

## Ã€ quoi sert  xinetd ?

1. **Optimisation des ressources**
   
   - Pas besoin de garder des dizaines de dÃ©mons en mÃ©moire.
   
   - Le service dÃ©marre seulement quand il est sollicitÃ©.

2. **SÃ©curitÃ©**
   
   - `xinetd` peut limiter les accÃ¨s (par IP, par heure, par nombre de connexions).
   
   - Il centralise les logs â†’ on voit qui se connecte et sur quel service.

3. **Administration simplifiÃ©e**
   
   - Les services sont dÃ©clarÃ©s dans des fichiers `/etc/xinetd.d/<service>`.
   
   - Un seul dÃ©mon (`xinetd`) suffit Ã  superviser et contrÃ´ler plusieurs services.

4. **FlexibilitÃ©**
   
   - Permet de lancer aussi bien des services internes (comme `echo`, `time`, `daytime`) que des programmes externes (scripts maison, petits serveurs).

## Objectifs

1. Installer et configurer `xinetd` (plus moderne quâ€™`inetd`).

2. Publier un petit service rÃ©seau (ex : serveur Ã©cho).

3. Tester la connexion depuis la machine cliente.

4. ContrÃ´ler et dÃ©sactiver proprement le service.

---

## Ã‰tapes pratiques

### 1. Installer `xinetd`

Sur **Machine2** (serveur) :

```bash
sudo apt update
sudo apt install xinetd -y
```

---

### 2. CrÃ©er un service simple (echo)

Sous Debian, certains services de test sont dÃ©jÃ  fournis.  
CrÃ©ez un fichier `/etc/xinetd.d/echo` :

```ini
service echo
{
    disable     = no
    type        = INTERNAL
    id          = echo-stream
    socket_type = stream
    protocol    = tcp
    user        = root
    wait        = no
}
```

Explications :

- `service echo` : nom du service.

- `type INTERNAL` : service fourni directement par `xinetd`.

- `protocol tcp` : Ã©coute en TCP.

- `wait no` : accepte plusieurs connexions en parallÃ¨le.

---

### 3. RedÃ©marrer `xinetd`

```bash
sudo systemctl restart xinetd
```

VÃ©rifier quâ€™il Ã©coute :

```bash
sudo ss -tlnp | grep 7
```

ğŸ‘‰ Vous devriez voir `*:7` â†’ port du service echo.

---

### 4. Tester depuis Machine1

```bash
telnet 10.10.10.2 7
```

Tapez du texte, il doit vous Ãªtre renvoyÃ© tel quel par le serveur â†’ câ€™est le principe du service **echo**.

---

### 5. DÃ©sactiver le service

Pour dÃ©sactiver, Ã©ditez `/etc/xinetd.d/echo` et mettez :

```ini
disable = yes
```

Puis redÃ©marrez :

```bash
sudo systemctl restart xinetd
```

Tester Ã  nouveau depuis Machine1 â†’ connexion refusÃ©e.

---

# RÃ©sultat attendu

- `xinetd` est installÃ© sur Machine2.

- Un service **echo** est activÃ© Ã  la demande.

- Machine1 se connecte et reÃ§oit les donnÃ©es renvoyÃ©es.

- AprÃ¨s dÃ©sactivation, le service nâ€™est plus disponible.

Exactement ğŸ‘Œ vous avez raison : lâ€™echo est trop acadÃ©mique, Ã§a illustre bien inetd/xinetd mais ce nâ€™est pas trÃ¨s **pratique**.  
Je vous propose donc une **variante plus rÃ©aliste** â†’ un petit service personnalisÃ© dÃ©clenchÃ© par `xinetd`.

---

# Exercice 7 (version pratique) : Service *date/uptime* via xinetd

## Objectifs

1. CrÃ©er un **service rÃ©seau personnalisÃ©** lancÃ© Ã  la demande.

2. Utiliser `xinetd` pour nâ€™Ã©couter que lorsquâ€™un client se connecte.

3. Tester la rÃ©ponse (utile comme mini-outil de monitoring).

---

## Ã‰tapes pratiques

### 1. PrÃ©parer le script serveur

Sur **Machine2**, crÃ©ez un script `/usr/local/bin/show_status.sh` :

```bash
#!/bin/bash
# Petit service dÃ©clenchÃ© par xinetd
echo "=== Service Info $(hostname) ==="
echo "Date  : $(date)"
echo "Uptime: $(uptime -p)"
```

Rendez-le exÃ©cutable :

```bash
sudo chmod +x /usr/local/bin/show_status.sh
```

---

### 2. DÃ©clarer un service TCP

Ajoutez une entrÃ©e dans `/etc/services` (si elle nâ€™existe pas dÃ©jÃ ) :

```ini
status      5000/tcp
```

ğŸ‘‰ Ici, notre service "status" Ã©coutera sur le port **5000**.

---

### 3. Configurer xinetd

CrÃ©ez `/etc/xinetd.d/status` :

```ini
service status
{
    disable         = no
    socket_type     = stream
    protocol        = tcp
    port            = 5000
    wait            = no
    user            = root
    server          = /usr/local/bin/show_status.sh
}
```

---

### 4. RedÃ©marrer `xinetd`

```bash
sudo systemctl restart xinetd
```

VÃ©rifiez quâ€™il Ã©coute :

```bash
sudo ss -tlnp | grep 5000
```

ğŸ‘‰ Vous devez voir `*:5000`.

---

### 5. Tester depuis Machine1

```bash
telnet 10.10.10.2 5000
```

RÃ©sultat attendu :

```
=== Service Info debianM2 ===
Date  : Mon Sep 30 19:45:10 CET 2025
Uptime: up 2 hours, 15 minutes
```

---

### 6. (Bonus) Tester avec `nc`

```bash
nc 10.10.10.2 5000
```

---

### 7. DÃ©sactivation

Si vous voulez dÃ©sactiver ce service :

```bash
sudo systemctl stop xinetd
```

ou remettez `disable = yes` dans `/etc/xinetd.d/status`.

---

# âœ… RÃ©sultat attendu

- Vous avez un **service personnalisÃ© "status"** accessible sur le port 5000.

- Ã€ chaque connexion, `xinetd` lance le script â†’ renvoie la date et lâ€™uptime.

- Le service nâ€™occupe pas de ressources quand il nâ€™est pas utilisÃ©.


