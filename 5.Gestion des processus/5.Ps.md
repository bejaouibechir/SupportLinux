> Astuce de labo : crée `~/lab-ps` et lance les scripts depuis là.  
> `mkdir -p ~/lab-ps && cd ~/lab-ps`

---

# OPTION `ps -e` ou `ps -A` — Tous les processus

## 1) Script

**Titre** : `sleeper.sh`  
**Intro** : lance un processus qui dort 300 s → visible dans la liste complète.

```bash
#!/usr/bin/env bash
# sleeper.sh : dort 300 secondes
sleep 300
```

### Préparation

```bash
chmod +x sleeper.sh
./sleeper.sh &
echo $! > sleeper.pid
```

## 2) Scénarios `ps`

- **Scénario A** : afficher tous les processus
  
  ```bash
  ps -e | grep sleeper
  ```
  
  **À observer** : la ligne `sleep 300` apparaît.

- **Scénario B** : variante
  
  ```bash
  ps -A | grep python
  ```
  
  **À observer** : tu vois aussi les scripts Python si d’autres charges tournent.

## 3) Conseils / Astuces / Pièges

- **Expérience** : relance `sleep` sans `&` (bloquant) → dans un autre terminal, `ps -e | grep sleep` → tu confirmes que `ps` liste aussi le process actif.

- **Piège** : `ps` affiche **un instantané** → pas de rafraîchissement comme `top`.

---

# OPTION `ps -f` / `ps -ef` — Format détaillé / standard

## 1) Script

**Titre** : `cpu_stress.py`  
**Intro** : calcule en boucle 45 s → parfait pour afficher UID, PPID, CMD.

```python
# cpu_stress.py
import time, math
end = time.time() + 45
while time.time() < end:
    _ = math.sqrt(1234.567)
```

### Préparation

```bash
python3 cpu_stress.py &
echo $! > cpu.pid
```

## 2) Scénarios `ps`

- **Scénario A** : affichage détaillé (UID, PID, PPID, CMD…)
  
  ```bash
  ps -f | grep cpu_stress
  ```

- **Scénario B** : tous les processus avec détails
  
  ```bash
  ps -ef | grep python
  ```

## 3) Conseils / Astuces / Pièges

- **Expérience** : note la colonne **PPID** (parent). Tue le parent → observe que l’enfant devient orphelin (`PPID=1`).

- **Piège** : beaucoup de débutants croient que `ps -ef` est interactif → mais c’est **un seul snapshot**.

---

# OPTION `ps -u utilisateur` — Processus d’un utilisateur

## 1) Script

**Titre** : `cpu_stress_labuser.py`  
**Intro** : même script que pour top/htop, lancé sous `labuser`.

```python
# cpu_stress_labuser.py
import time, math
end = time.time() + 60
while time.time() < end:
    _ = math.sqrt(98765.4321)
    time.sleep(0.001)
```

### Préparation

```bash
sudo adduser --disabled-password --gecos "" labuser
sudo -u labuser python3 cpu_stress_labuser.py &
```

## 2) Scénarios `ps`

```bash
ps -u labuser
```

**À observer** : liste restreinte aux processus de `labuser`.

## 3) Conseils / Astuces / Pièges

- **Expérience** : compare `ps -u root` vs `ps -u labuser`.

- **Piège** : certains systèmes requièrent UID plutôt que login → teste `ps -u $(id -u labuser)`.

---

# OPTION `ps -l` — Format long

## 1) Script

**Titre** : `mem_stress.py`  
**Intro** : alloue ~300 MB pendant 45 s → visible avec colonnes supplémentaires (NI, PRI…).

```python
# mem_stress.py
import time
buf = bytearray(300*1024*1024)
time.sleep(45)
```

### Préparation

```bash
python3 mem_stress.py &
```

## 2) Scénarios `ps`

```bash
ps -l | grep python
```

**À observer** : colonnes PRI (priorité), NI (nice), SZ (taille mémoire).

## 3) Conseils / Astuces / Pièges

- **Expérience** : change le nice avec `renice -n 10 -p <PID>` puis refais `ps -l`. La colonne NI change.

- **Piège** : certains champs diffèrent selon BSD vs SysV → compare `ps -l` et `ps -ef`.

---

# OPTION `ps -p <PID>` / `--pid <PID>` — Un processus précis

## 1) Script

On réutilise `sleeper.sh`.

## 2) Scénarios `ps`

```bash
ps -p $(cat sleeper.pid)
ps --pid $(cat sleeper.pid)
```

**À observer** : uniquement la ligne correspondant au PID.

## 3) Conseils / Astuces / Pièges

- **Expérience** : tue le process puis relance `ps -p` → rien n’est affiché.

- **Piège** : `ps -p` ne suit pas les respawn → refais après un redémarrage du service.

---

# OPTION `ps a` — Processus liés à un terminal

## 1) Script

**Titre** : `tty_loop.sh`  
**Intro** : boucle qui tourne et affiche toutes les 5 s → lié au terminal courant.

```bash
#!/usr/bin/env bash
while true; do echo "boucle sur $(tty)"; sleep 5; done
```

### Préparation

```bash
chmod +x tty_loop.sh
./tty_loop.sh &
```

## 2) Scénarios `ps`

```bash
ps a | grep tty_loop
```

**À observer** : colonne TTY non vide.

## 3) Conseils / Astuces / Pièges

- **Expérience** : lance `./tty_loop.sh` via `nohup` → dans `ps a`, le TTY est absent.

- **Piège** : `ps a` ne montre pas les daemons sans terminal.

---

# OPTION `ps u` — Format utilisateur (%CPU, %MEM)

## 1) Script

On réutilise `cpu_stress.py` et `mem_stress.py`.

## 2) Scénarios `ps`

```bash
ps u | grep python
```

**À observer** : colonnes `%CPU`, `%MEM`.

## 3) Conseils / Astuces / Pièges

- **Expérience** : lance deux scripts en parallèle, compare `%CPU` vs `%MEM`.

- **Piège** : la somme `%CPU` peut dépasser 100% (multi-cœurs).

---

# OPTION `ps x` — Inclure processus sans terminal

## 1) Script

On réutilise `sleeper.sh` lancé via `nohup`.

```bash
nohup ./sleeper.sh &
```

## 2) Scénarios `ps`

```bash
ps x | grep sleeper
```

**À observer** : colonne TTY = `?` (pas de terminal).

## 3) Conseils / Astuces / Pièges

- **Expérience** : compare `ps a` vs `ps x`.

- **Piège** : beaucoup de services système apparaissent ici → sortie très longue.

---

# OPTION `ps --forest` — Vue arborescente

## 1) Script

On réutilise `tree_parent.sh`.

```bash
#!/usr/bin/env bash
for i in 1 2 3; do sleep 120 & done
wait
```

### Préparation

```bash
chmod +x tree_parent.sh
./tree_parent.sh &
```

## 2) Scénarios `ps`

```bash
ps --forest | grep -A4 tree_parent
```

**À observer** : indentation du parent et des enfants.

## 3) Conseils / Astuces / Pièges

- **Expérience** : tue un enfant → observe que le parent reste avec moins de branches.

- **Piège** : sur certaines distros, `--forest` peut être dans le paquet `procps`.

---

# OPTION `ps --sort=-%mem` et `ps --sort=-%cpu`

## 1) Script

Réutilise `cpu_stress.py` et `mem_stress2.py`.

## 2) Scénarios `ps`

```bash
ps -eo pid,comm,%cpu,%mem --sort=-%mem | head
ps -eo pid,comm,%cpu,%mem --sort=-%cpu | head
```

**À observer** : classement par mémoire vs CPU.

## 3) Conseils / Astuces / Pièges

- **Expérience** : lance `cpu_stress.py` + `mem_stress2.py` → observe qui est premier selon le tri.

- **Piège** : `ps` doit être appelé avec `-eo` pour afficher les colonnes voulues, sinon pas de `%MEM`.

---

# OPTION `ps aux` — Résumé global

## 1) Script

Relance n’importe quel script pour qu’il apparaisse.

## 2) Scénarios `ps`

```bash
ps aux | grep python
```

**À observer** : colonnes USER, PID, %CPU, %MEM, STAT, START, TIME, COMMAND.

## 3) Conseils / Astuces / Pièges

- **Expérience** : compare `ps aux` et `ps -ef`. Note la différence de colonnes (BSD vs SysV).

- **Piège** : la syntaxe `ps aux` sans tiret est BSD-style ; `ps -ef` est SysV-style.

---

# Nettoyage

```bash
pkill -f cpu_stress_labuser.py 2>/dev/null || true
pkill -f cpu_stress.py 2>/dev/null || true
pkill -f mem_stress.py 2>/dev/null || true
pkill -f mem_stress2.py 2>/dev/null || true
pkill -f tty_loop.sh 2>/dev/null || true
pkill -f sleeper.sh 2>/dev/null || true
pkill -f tree_parent.sh 2>/dev/null || true
[ -f sleeper.pid ] && kill "$(cat sleeper.pid)" 2>/dev/null || true
rm -f *.pid nohup.out
sudo deluser --remove-home labuser 2>/dev/null || true
```
