# OPTION `-u utilisateur` — Filtrer par utilisateur

## 1) Script

### Titre

`cpu_stress_labuser.py`

### Introduction

Crée une **charge CPU légère (~60 s)** lancée **sous l’utilisateur `labuser`** pour illustrer le filtrage par utilisateur.

### Script Python : `cpu_stress_labuser.py`

```python
# cpu_stress_labuser.py
# Charge CPU légère (~60s) avec micro-sommeil pour éviter 100% constant
import time, math
end = time.time() + 60
while time.time() < end:
    _ = math.sqrt(12345.6789)
    time.sleep(0.001)
```

### Préparation

```bash
sudo adduser --disabled-password --gecos "" labuser
sudo -u labuser python3 cpu_stress_labuser.py &
echo $! > labuser_cpu.pid
```

## 2) Scénarios `top` (option `-u`)

- **Scénario A : voir uniquement les processus de labuser**
  
  ```bash
  top -u labuser
  ```
  
  **À observer** : uniquement les PIDs de `labuser` (y compris celui lancé ci-dessus).

- **Scénario B : comparer avant/après le lancement**
  
  ```bash
  pkill -u labuser -f cpu_stress_labuser.py 2>/dev/null || true
  top -u labuser   # devrait afficher (presque) rien
  # Dans un autre terminal, relance le script sous labuser puis reviens sur top
  ```

## 3) Conseils / Astuces / Pièges — Expériences

- **Expérience “compte applicatif”** : crée un second user `appuser` et lance le même script avec `-u appuser`.  
  Compare `top -u labuser` vs `top -u appuser` pour isoler un fautif lors d’un incident multi-comptes.
  
  ```bash
  sudo adduser --disabled-password --gecos "" appuser
  sudo -u appuser python3 cpu_stress_labuser.py &
  top -u appuser    # doit montrer le PID lancé sous appuser
  ```

- **Piège testable** : typo utilisateur. Lance `top -u labusr` (faux nom) → rien n’apparaît. Corrige et constate la différence.

---

# OPTION `-n nombre` — Nombre d’itérations (mode interactif)

# OPTION `-b` + `-n 1` — Snapshot non interactif (export)

> On réutilise des scripts CPU/MEM pour rendre les captures parlantes.

## 1) Script

### Titre

`cpu_stress.py`

### Introduction

Simule une **charge CPU modérée (~45 s)** pour que le process **remonte** quand on trie par CPU ou qu’on prend un snapshot.

### Script Python : `cpu_stress.py`

```python
# cpu_stress.py
# Charge CPU modérée (~45s)
import time, math
end = time.time() + 45
while time.time() < end:
    _ = math.sin(1234.567) ** 2
```

### (Optionnel) Script mémoire pour contraste

#### Titre

`mem_stress.py`

#### Introduction

Alloue **~300 MB** pendant **~45 s** pour être visible dans **VIRT/RES/%MEM**.

#### Script Python : `mem_stress.py`

```python
# mem_stress.py
# Alloue ~300MB puis attend ~45s
import time
buf = bytearray(300 * 1024 * 1024)
time.sleep(45)
```

### Préparation

```bash
python3 cpu_stress.py &   echo $! > cpu.pid
python3 mem_stress.py &   echo $! > mem.pid
```

## 2) Scénarios `top`

- **Scénario A (interactif, sorties limitées)** : 5 rafraîchissements puis sortie.
  
  ```bash
  top -n 5
  ```
  
  **À observer** : top s’actualise 5 fois (intervalle par défaut ~3s) puis quitte.  
  Utile pour **un coup d’œil rapide** sans rester en interactif.

- **Scénario B (export batch)** : snapshot horodaté (non interactif).
  
  ```bash
  top -b -n 1 > top_snapshot.txt
  sed -n '1,60p' top_snapshot.txt
  ```
  
  **À observer** : un état des lieux (entête + liste) au moment où la charge tournait.  
  Refais un second snapshot 5–10 s plus tard et compare.

## 3) Conseils / Astuces / Pièges — Expériences

- **Expérience “ticket d’incident”** : lance 3 snapshots espacés :
  
  ```bash
  for i in 1 2 3; do date >> capture.txt; top -b -n 1 >> capture.txt; sleep 5; done
  ```
  
  **À observer** : l’évolution CPU/MEM d’un même PID entre les captures.

- **Piège testable** : `top -b` est **non interactif** → les **raccourcis clavier ne marchent pas**. Tente `M`/`P` : aucun effet.

---

# OPTION `-p <PID>` — Surveiller un processus précis

## 1) Script

### Titre

`sleeper.sh`

### Introduction

Processus inoffensif qui **dort 300 s** → parfait pour cibler un PID unique et tester le kill contrôlé.

### Script Bash : `sleeper.sh`

```bash
#!/usr/bin/env bash
# Dort 300 secondes
sleep 300
```

### Préparation

```bash
chmod +x sleeper.sh
./sleeper.sh &
echo $! > sleeper.pid
```

## 2) Scénarios `top`

- **Scénario A : surveiller un seul PID**
  
  ```bash
  top -p "$(cat sleeper.pid)"
  ```
  
  **À observer** : l’écran ne montre **que** ce processus.

- **Scénario B : kill depuis top (voir section raccourci `k` plus bas)**  
  Dans `top -p …`, tape `k`, propose le PID, signal `15` (TERM).  
  **À observer** : le process disparaît (ou passe “defunct” un court instant si parent lent).

## 3) Conseils / Astuces / Pièges — Expériences

- **Expérience “redémarrage”** : tue le sleeper (`kill $(cat sleeper.pid)`) puis relance-le (PID change).  
  Relance `top -p <NOUVEAU PID>` et constate que **`-p` ne suit pas automatiquement** le nouveau PID.

- **Expérience “process group”** : lance deux sleepers, surveille-en un seul.  
  **À observer** : `-p` reste focalisé, même si un autre process du même user consomme à côté.

---

# OPTION `-o <colonne>` — Tri initial par colonne (ex. `%MEM`)

## 1) Script

### Titre

`mem_stress2.py`

### Introduction

Alloue **~600 MB** pendant **~60 s**, pour “dominer” la vue triée par **mémoire**.

### Script Python : `mem_stress2.py`

```python
# mem_stress2.py
# Alloue ~600MB pendant ~60s
import time
buf = bytearray(600 * 1024 * 1024)
time.sleep(60)
```

### Préparation

```bash
python3 mem_stress2.py &
echo $! > mem2.pid
```

## 2) Scénarios `top`

- **Scénario A : tri initial par %MEM**
  
  ```bash
  top -o %MEM
  ```
  
  **À observer** : le processus `mem_stress2.py` apparaît en haut.

- **Scénario B : comparer %MEM vs RES (en live)**  
  Lance aussi `mid_mem.py` (400 MB, ci-dessous) puis :
  
  - `top -o %MEM` (tri initial sur %MEM),
  
  - appuie sur **`Shift+>`** jusqu’à trier par **RES** (ou touche **`M`** pour raccourci mém).  
    **À observer** : classement parfois similaire mais **pas identique** (selon RAM machine).

### (Script complémentaire) `mid_mem.py`

```python
# mid_mem.py
# Alloue ~400MB pendant ~40s
import time
buf = bytearray(400 * 1024 * 1024)
time.sleep(40)
```

```bash
python3 mid_mem.py &  echo $! > mid_mem.pid
```

## 3) Conseils / Astuces / Pièges — Expériences

- **Expérience “% relatif vs absolu”** : sur une machine avec beaucoup de RAM, `%MEM` peut sembler “petit” alors que **RES (MB)** est élevé.  
  Compare les deux tris et note l’écart.

- **Piège testable** : certains champs ne sont pas triables dans toutes les versions de `top`.  
  Déplace-toi avec **`Shift+>`/`Shift+<`** et vérifie le champ actif (en-tête de tri).

---

# OPTION `-n 1 -b > top.txt` — Export “état des lieux” + I/O

## 1) Script

### Titre

`io_writer.sh`

### Introduction

Génère **une activité disque** (écrit ~1 GiB) pour corréler un snapshot `top` avec des outils d’I/O.

### Script Bash : `io_writer.sh`

```bash
#!/usr/bin/env bash
# Génère de l'I/O disque (1 GiB) puis attend
set -euo pipefail
dd if=/dev/zero of=bigfile.dat bs=4M count=256 status=progress
sleep 10
```

### Préparation

```bash
chmod +x io_writer.sh
./io_writer.sh &
echo $! > io.pid
```

## 2) Scénarios `top`

- **Scénario A : snapshot pendant l’I/O**
  
  ```bash
  top -b -n 1 > top_io.txt
  sed -n '1,80p' top_io.txt
  ```
  
  **À observer** : charge CPU faible à modérée sur `dd`, petites variations de `%CPU`.

- **Scénario B : série de snapshots**
  
  ```bash
  for i in 1 2 3; do echo "SNAP $i $(date)"; top -b -n 1 | head -n 35; sleep 3; done
  ```
  
  **À observer** : micro-variations CPU/temps utilisateur/sys pendant l’écriture.

## 3) Conseils / Astuces / Pièges — Expériences

- **Expérience “corrélation I/O”** : dans un 2ᵉ terminal, lance :
  
  ```bash
  iostat -x 1 5
  ```
  
  Compare avec `top_io.txt` → on voit que top **ne montre pas** le débit disque par PID (complète avec `pidstat -d 1` si disponible).

- **Piège testable** : si tu lances `top -b -n 1` **après** la fin de `dd`, le snapshot ne reflète plus l’activité → refais l’expérience en timing serré.

---

# RACCourcis CLAVIER — Démos ciblées (pendant `top`)

> Lance d’abord quelques charges pour rendre les vues parlantes :

```bash
python3 short_cpu.py &   echo $! > short_cpu.pid
python3 mem_stress2.py & echo $! > mem2.pid
./sleeper.sh &          echo $! > sleeper2.pid
```

## 1) `P` — Trier par CPU

- **Action** : lance `top`, tape **`P`**.  
  **À observer** : `short_cpu.py` remonte en tête (tant qu’il tourne).

### Script “court CPU”

**Titre** : `short_cpu.py`  
**Intro** : petite charge CPU **~30 s** pour tri rapide.

```python
# short_cpu.py
import time, math
end = time.time() + 30
while time.time() < end:
    _ = math.sqrt(987654.321)
```

## 2) `M` — Trier par mémoire

- **Action** : dans `top`, tape **`M`**.  
  **À observer** : `mem_stress2.py` (600 MB) tout en haut.

## 3) `1` — Afficher CPU par cœur

- **Action** : tape **`1`**.  
  **À observer** : une ligne par CPU logique. Si ta charge est mono-thread, **un seul cœur** grimpe.

**Expérience** : lance **deux** `short_cpu.py` en parallèle et compare la répartition.

## 4) `n` — Limiter le nombre de lignes affichées

- **Action** : tape **`n`**, saisis `5`.  
  **À observer** : vue resserrée (pratique pour screenshots).

**Expérience** : passe de `n=5` à `n=20` et constate la visibilité des “queues de classement”.

## 5) `d` — Intervalle de rafraîchissement

- **Action** : tape **`d`** → mets `0.5`.  
  **Expérience** : remets ensuite `3` pour réduire la charge de top lui-même.  
  **À observer** : réactivité vs coût d’échantillonnage.

## 6) `c` — Chemin complet de la commande (cmdline)

- **Action** : tape **`c`** pour basculer cmdline ↔ nom court.  
  **Expérience** : lance un script avec argument :
  
  ```bash
  python3 short_cpu.py --env=dev &  # l’argument est ignoré par le script mais visible dans cmdline
  ```
  
  **À observer** : la **ligne de commande complète** aide à différencier des instances.

## 7) `z` — Couleurs

- **Action** : tape **`z`**.  
  **À observer** : en-têtes et barres colorées (plus lisible).  
  **Piège testable** : sur TTY sans support couleur, l’effet est minime → essaie dans un terminal graphique.

## 8) `Shift+>` / `Shift+<` — Changer la colonne de tri

- **Action** : appuie plusieurs fois sur **`Shift+>`** pour déplacer le tri vers **RES**, **TIME+**, etc.  
  **Expérience** : compare “tri par %MEM” vs “tri par RES” vs “tri par TIME+” pendant que `short_cpu.py` et `mem_stress2.py` tournent.

## 9) `k` — Tuer un processus

- **Action** : tape **`k`**, entre le PID de `sleeper2.pid`, puis **signal 15** (TERM).
  
  ```bash
  cat sleeper2.pid  # pour vérifier le PID à saisir
  ```
  
  **À observer** : disparition de la ligne dans `top`.

**Expériences** :

- **TERM → INT → KILL** : si TERM ne marche pas, réessaie `2` (INT), puis en dernier recours `9` (KILL).

- **Zombie** : crée un “zombie” (plus avancé, nécessite un parent qui ne `wait()` pas) → observe la colonne `S` à `Z` et note que `k` n’y change rien (c’est le parent qui doit récupérer le zombie).

## 10) `Shift+W` — Sauvegarder la config

- **Action** : règle affichage (tri, n, couleurs), tape **`Shift+W`**.  
  **À observer** : fichier `~/.toprc` créé.  
  **Expérience** : ferme/re-ouvre `top` → l’agencement est conservé.

## 11) `h` / `q` — Aide / Quitter

- **Action** : **`h`** (pense-bête), **`q`** (sortie).  
  **Expérience** : mémorise le mapping des touches utiles et vérifie vite un doute pendant une astreinte.

---

# Nettoyage (après tes tests)

```bash
cd ~/lab-top
pkill -f cpu_stress_labuser.py 2>/dev/null || true
pkill -f cpu_stress.py 2>/dev/null || true
pkill -f short_cpu.py 2>/dev/null || true
pkill -f mem_stress.py 2>/dev/null || true
pkill -f mem_stress2.py 2>/dev/null || true
pkill -f io_writer.sh 2>/dev/null || true
pkill -f sleeper.sh 2>/dev/null || true
[ -f labuser_cpu.pid ] && kill "$(cat labuser_cpu.pid)" 2>/dev/null || true
[ -f cpu.pid ] && kill "$(cat cpu.pid)" 2>/dev/null || true
[ -f mem.pid ] && kill "$(cat mem.pid)" 2>/dev/null || true
[ -f mem2.pid ] && kill "$(cat mem2.pid)" 2>/dev/null || true
[ -f sleeper.pid ] && kill "$(cat sleeper.pid)" 2>/dev/null || true
[ -f sleeper2.pid ] && kill "$(cat sleeper2.pid)" 2>/dev/null || true
[ -f io.pid ] && kill "$(cat io.pid)" 2>/dev/null || true
rm -f *.pid bigfile.dat top_snapshot.txt top_io.txt capture.txt
sudo deluser --remove-home labuser 2>/dev/null || true
```
