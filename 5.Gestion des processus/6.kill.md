

# 1) `kill <PID>` — Arrêter un processus

## Script

**Titre** : `sleeper.sh`  
**Intro** : processus inoffensif qui dort 300 s → idéal pour tester `kill`.

```bash
#!/usr/bin/env bash
# sleeper.sh : dort 300 secondes
sleep 300
```

### Préparation

```bash
chmod +x sleeper.sh
./sleeper.sh &
echo $! > sleeper.pid
```

## Scénarios

- **Scénario A** : arrêt normal
  
  ```bash
  kill $(cat sleeper.pid)
  ```
  
  **À observer** : le processus disparaît (`ps -p $(cat sleeper.pid)` ne renvoie rien).

## Expériences & Pièges

- **Expérience** : relance `sleeper.sh` et dans un autre terminal lance :
  
  ```bash
  watch -n1 "ps -p $(cat sleeper.pid)"
  ```
  
  Puis `kill <PID>` → observe la ligne disparaître en direct.

- **Piège** : si le processus ignore SIGTERM (rare), il reste → tu devras forcer.

---

# 2) `kill -9 <PID>` — Forcer l’arrêt

## Script

On réutilise `cpu_stress.py`.

```python
# cpu_stress.py : charge CPU 45s
import time, math
end = time.time() + 45
while time.time() < end:
    _ = math.sqrt(1234.567)
```

### Préparation

```bash
python3 cpu_stress.py &
echo $! > cpu.pid
```

## Scénarios

- **Scénario A** : arrêt brutal
  
  ```bash
  kill -9 $(cat cpu.pid)
  ```
  
  **À observer** : processus stoppé immédiatement.

## Expériences & Pièges

- **Expérience** : note que `kill -9` empêche le process de nettoyer (pas de `finally` en Python). Teste en modifiant le script pour écrire dans un fichier → le fichier reste corrompu.

- **Piège** : sur un système supervisé (systemd, Kubernetes…), le service est redémarré automatiquement même après `-9`.

---

# 3) `kill -s SIGKILL <PID>` et `kill -n 9 <PID>`

## Script

On réutilise `sleeper.sh`.

## Scénarios

- **Scénario A** : signal par nom
  
  ```bash
  kill -s SIGKILL $(cat sleeper.pid)
  ```

- **Scénario B** : signal par numéro
  
  ```bash
  kill -n 9 $(cat sleeper.pid)
  ```

**À observer** : dans les deux cas, effet identique à `kill -9`.

## Expériences & Pièges

- **Expérience** : remplace SIGKILL par `SIGHUP` → observe que le process est aussi tué (sauf s’il le gère).

- **Piège** : certains signaux ne sont pas “catchables” (`SIGKILL`, `SIGSTOP`). Teste avec un script Python qui tente de gérer SIGKILL → impossible.

---

# 4) `pkill <nom>` — Tuer par nom

## Script

**Titre** : `mem_stress.py`  
**Intro** : alloue 300 MB → repérable par nom `python3`.

```python
# mem_stress.py
import time
buf = bytearray(300*1024*1024)
time.sleep(60)
```

### Préparation

```bash
python3 mem_stress.py &
```

## Scénarios

- **Scénario A** : tuer par nom
  
  ```bash
  pkill -f mem_stress.py
  ```
  
  **À observer** : le process disparaît sans besoin de PID.

## Expériences & Pièges

- **Expérience** : lance deux scripts Python (`cpu_stress.py` + `mem_stress.py`), puis `pkill -f python3` → les deux tombent.

- **Piège** : attention au motif trop large (ex. `pkill python` peut tuer ton IDE Python !).

---

# 5) `pkill -u utilisateur` — Tuer par utilisateur

## Script

On réutilise `cpu_stress_labuser.py` sous `labuser`.

```python
# cpu_stress_labuser.py
import time, math
end = time.time() + 60
while time.time() < end:
    _ = math.sqrt(98765.4321)
    time.sleep(0.001)
```

### Préparation

```bash
sudo -u labuser python3 cpu_stress_labuser.py &
```

## Scénarios

- **Scénario A** : tuer tous les process de labuser
  
  ```bash
  pkill -u labuser
  ```
  
  **À observer** : tous ses scripts tombent.

## Expériences & Pièges

- **Expérience** : relance 2 scripts sous `labuser` et 1 sous `root`. Lance `pkill -u labuser` → seuls ceux de `labuser` meurent.

- **Piège** : dangereux en prod → peut tuer aussi des démons applicatifs si lancés avec cet utilisateur.

---

# Signaux courants

- **SIGTERM (15)** : par défaut, arrêt propre.  
  **Expérience** : script Python avec `try/finally` écrit “propre” dans un fichier. Tuer avec `kill <PID>` → observe le message “propre” écrit.

- **SIGKILL (9)** : arrêt forcé, sans nettoyage.  
  **Expérience** : même script, mais tuer avec `kill -9` → aucun message “propre”, fichier corrompu.

---

# Nettoyage

```bash
pkill -f cpu_stress.py 2>/dev/null || true
pkill -f mem_stress.py 2>/dev/null || true
pkill -f cpu_stress_labuser.py 2>/dev/null || true
pkill -f sleeper.sh 2>/dev/null || true
rm -f *.pid
sudo deluser --remove-home labuser 2>/dev/null || true
```


