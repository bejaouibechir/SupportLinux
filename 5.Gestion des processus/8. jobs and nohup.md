

# 1) Lancer un job en arriÃ¨re-plan avec `&`

## Script

**Titre** : `sleeper.sh`  
**Intro** : un process qui dort 300 s â†’ parfait pour manipuler en jobs.

```bash
#!/usr/bin/env bash
# sleeper.sh : dort 300 secondes
sleep 300
```

### PrÃ©paration

```bash
chmod +x sleeper.sh
./sleeper.sh &
```

## ScÃ©narios

- **ScÃ©nario A : lister les jobs**
  
  ```bash
  jobs -l
  ```
  
  **Ã€ observer** : ton job apparaÃ®t avec un **numÃ©ro [%1]** et son PID.

- **ScÃ©nario B : envoyer 2 scripts**
  
  ```bash
  ./sleeper.sh &
  ./sleeper.sh &
  jobs -l
  ```
  
  **Ã€ observer** : plusieurs jobs numÃ©rotÃ©s `%1`, `%2`.

## ExpÃ©riences & PiÃ¨ges

- **ExpÃ©rience** : ferme le terminal â†’ tous les jobs meurent (limite quâ€™on va dÃ©passer avec `nohup`).

- **PiÃ¨ge** : un job lancÃ© sans `&` bloque ton shell â†’ tu dois utiliser `Ctrl+Z` pour lâ€™arrÃªter et le mettre en attente.

---

# 2) `fg` â€” Ramener un job au premier plan

## ScÃ©narios

- **ScÃ©nario A : dernier job**
  
  ```bash
  fg
  ```
  
  **Ã€ observer** : le dernier job repasse en avant-plan (ton shell est bloquÃ© dessus).

- **ScÃ©nario B : job spÃ©cifique**
  
  ```bash
  fg %1
  ```
  
  **Ã€ observer** : le job numÃ©ro 1 revient en avant-plan.

## ExpÃ©riences & PiÃ¨ges

- **ExpÃ©rience** : lance 2 jobs, puis fais `fg %-` â†’ ramÃ¨ne lâ€™avant-dernier.

- **PiÃ¨ge** : si tu fermes le terminal, **tous les jobs avant-plan ou arriÃ¨re-plan meurent**.

---

# 3) `bg` â€” Relancer en arriÃ¨re-plan

## ScÃ©narios

- **ScÃ©nario A : Ctrl+Z puis bg**
  
  ```bash
  ./sleeper.sh
  # appuie sur Ctrl+Z â†’ process suspendu
  bg
  ```
  
  **Ã€ observer** : le job passe en arriÃ¨re-plan (Running).

- **ScÃ©nario B : cible un job**
  
  ```bash
  bg %1
  ```
  
  **Ã€ observer** : uniquement ce job repart en arriÃ¨re-plan.

## ExpÃ©riences & PiÃ¨ges

- **ExpÃ©rience** : lance un script Python qui affiche toutes les 2 s :
  
  ```python
  # loop_print.py
  import time
  i=0
  while True:
      print("tick", i)
      i+=1
      time.sleep(2)
  ```
  
  ExÃ©cute-le, `Ctrl+Z`, puis `bg`. Observe que les messages continuent Ã  dÃ©filer mÃªme en arriÃ¨re-plan.

- **PiÃ¨ge** : si tu fermes le terminal, les jobs `bg` meurent aussi.

---

# 4) Raccourcis clavier

- **Ctrl+C** : tue le job au 1er plan.  
  **ExpÃ©rience** : lance `./sleeper.sh`, puis `Ctrl+C` â†’ observe quâ€™il sâ€™arrÃªte immÃ©diatement (`jobs` ne montre plus rien).

- **Ctrl+Z** : met en pause.  
  **ExpÃ©rience** : lance `python3 loop_print.py`, puis `Ctrl+Z`. `jobs` affiche `[Stopped]`.

- **&** : lance directement en arriÃ¨re-plan.  
  **ExpÃ©rience** : `./sleeper.sh &` â†’ observe immÃ©diatement `[1] PID`.

---

# 5) Limites des jobs

**ExpÃ©rience** :

1. Lance `./sleeper.sh &`.

2. Tape `jobs -l` â†’ le job est lÃ .

3. Ferme ton terminal â†’ relance un autre terminal et vÃ©rifie avec `ps -ef | grep sleeper`.

ðŸ‘‰ Le processus nâ€™existe plus â†’ preuve que les **jobs dÃ©pendent du terminal**.

---

# 6) `nohup` â€” DÃ©passer les limites des jobs

## Script

On rÃ©utilise `sleeper.sh`.

## ScÃ©narios

- **ScÃ©nario A : lancer avec nohup**
  
  ```bash
  nohup ./sleeper.sh &
  ```
  
  **Ã€ observer** : sortie redirigÃ©e vers `nohup.out`.

- **ScÃ©nario B : fermer le terminal**
  
  - Ferme ton terminal.
  
  - Rouvre-en un autre et tape :
    
    ```bash
    ps -ef | grep sleeper
    ```
    
    **Ã€ observer** : le process est encore vivant malgrÃ© la fermeture â†’ `nohup` lâ€™a dÃ©tachÃ© du terminal.

## ExpÃ©riences & PiÃ¨ges

- **ExpÃ©rience** : lance un script qui Ã©crit en boucle dans un fichier :
  
  ```python
  # writer.py
  import time
  f = open("log.txt", "a")
  i=0
  while True:
      f.write(f"ligne {i}\n")
      f.flush()
      time.sleep(2)
      i+=1
  ```
  
  Lance-le avec `nohup python3 writer.py &`, ferme le terminal, rouvre et observe `tail -f log.txt` â†’ il continue Ã  tourner.

- **PiÃ¨ge** : sans redirection explicite, `nohup` envoie tout vers `nohup.out` â†’ teste un script bavard, observe que le fichier gonfle.

---

# Nettoyage

```bash
pkill -f sleeper.sh 2>/dev/null || true
pkill -f loop_print.py 2>/dev/null || true
pkill -f writer.py 2>/dev/null || true
rm -f nohup.out log.txt
```


