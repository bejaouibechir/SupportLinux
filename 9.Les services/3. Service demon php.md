# Service Deamon php

-

# 1) Préparation (paquets, utilisateur, dossiers)

```bash
sudo apt update
sudo apt install -y php-cli

# Compte de service non-login
sudo useradd --system --home /opt/phpdemo --shell /usr/sbin/nologin phpdemo

# Arborescence appli
sudo mkdir -p /opt/phpdemo/public
sudo chown -R phpdemo:phpdemo /opt/phpdemo
```

---

# 2) Application PHP (ultra-minimale)

**Fichier à créer :** `/opt/phpdemo/public/index.php`

```php
<?php
// /opt/phpdemo/public/index.php
// Mini serveur PHP: retourne un texte simple.
// Le serveur sera lancé au premier plan par "php -S".
// Le fork (daemonisation) est géré par start-stop-daemon côté systemd.

header('Content-Type: text/plain; charset=UTF-8');
echo "Hello from PHP built-in server (forking via start-stop-daemon)!\n";?>
```

```bash
sudo chown -R phpdemo:phpdemo /opt/phpdemo
```

> Test manuel (facultatif) :
> 
> ```bash
> sudo -u phpdemo php -S 0.0.0.0:8080 -t /opt/phpdemo/public
> # Ctrl+C pour arrêter
> ```

---

# 3) Unité systemd **Type=forking**

**Fichier à créer :** `/etc/systemd/system/phpdemo.service`

```ini
# /etc/systemd/system/phpdemo.service
[Unit]
Description=PHP demo (forking via start-stop-daemon)
After=network.target

[Service]
Type=forking
User=phpdemo
Group=phpdemo
WorkingDirectory=/opt/phpdemo
RuntimeDirectory=phpdemo
PIDFile=/run/phpdemo/phpdemo.pid

ExecStart=/usr/sbin/start-stop-daemon \
  --start \
  --background \
  --make-pidfile \
  --pidfile /run/phpdemo/phpdemo.pid \
  --exec /usr/bin/php -- -S 0.0.0.0:8080 -t /opt/phpdemo/public

ExecStop=/usr/sbin/start-stop-daemon --stop --pidfile /run/phpdemo/phpdemo.pid --retry 5
Restart=on-failure
RestartSec=2

[Install]
WantedBy=multi-user.target
```

### Informations (hors bloc service)

- **Type=forking** : systemd s’attend à un fork ; `start-stop-daemon` crée le **PIDFile**.

- **RuntimeDirectory=phpdemo** → crée `/run/phpdemo/` avec les bons droits.

- **PIDFile=** `/run/phpdemo/phpdemo.pid` : suivi fiable du processus.

- **ExecStart** : lance `php -S 0.0.0.0:8080 -t /opt/phpdemo/public` en arrière-plan via `start-stop-daemon`.

- **ExecStop** : arrêt propre par PID + `--retry 5`.

- Si `command -v start-stop-daemon` renvoie `/sbin/start-stop-daemon`, ajustez le chemin dans `ExecStart`/`ExecStop`.

---

# 4) Activer, démarrer, vérifier

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now phpdemo
sudo systemctl status phpdemo
```

Tests rapides :

```bash
# Depuis la machine
curl -s http://127.0.0.1:8080

# Vérifier l’écoute
sudo ss -ltnp | grep :8080

# Voir le PID pris depuis le PIDFile
systemctl status phpdemo | sed -n '1,20p'

# Logs
journalctl -u phpdemo -b -e
```

---

# 5) Nettoyage (rollback complet)

```bash
sudo systemctl disable --now phpdemo
sudo rm -f /etc/systemd/system/phpdemo.service
sudo systemctl daemon-reload
sudo rm -rf /opt/phpdemo
sudo userdel phpdemo
# Optionnel si installé uniquement pour le test :
# sudo apt purge -y php-cli && sudo apt autoremove -y
```

---

## Variantes utiles

- **Changer le port** : remplacez `0.0.0.0:8080` par `0.0.0.0:5000` (ou autre) dans `ExecStart`, puis `daemon-reload` + `restart`.

- **Répertoires publics multiples** : gardez `-t /opt/phpdemo/public` et servez d’autres routes via PHP si nécessaire.

---

Parfait — voici la **démo PHP (Type=forking)** mise à jour en réintégrant **Composer** et la génération des fichiers/dossiers (**composer.json, composer.lock, vendor/**).  
Respect de vos préférences : pas de split/tee, chaque fichier est nommé, scripts commentés, et **les infos explicatives sont hors du bloc systemd**.

---

# 1) Préparation (paquets, utilisateur, Composer)

```bash
# Paquets de base
sudo apt update
sudo apt install -y php-cli php-mbstring unzip

# Compte de service non-login
sudo useradd --system --home /opt/phpdemo --shell /usr/sbin/nologin phpdemo

# Arborescence applicative
sudo mkdir -p /opt/phpdemo/public
sudo chown -R phpdemo:phpdemo /opt/phpdemo

# Installer Composer (méthode officielle rapide)
php -r "copy('https://getcomposer.org/installer','composer-setup.php');"
php composer-setup.php --install-dir=/usr/local/bin --filename=composer
rm -f composer-setup.php---
```

# 2) Initialiser le projet & installer les dépendances

```bash
# Initialiser le projet Composer (génère composer.json)
sudo -u phpdemo bash -lc 'cd /opt/phpdemo && composer init -n'

# Installer les dépendances (génère composer.lock + vendor/)
sudo -u phpdemo bash -lc \
'cd /opt/phpdemo && composer require monolog/monolog:^3 vlucas/phpdotenv:^5 nikic/fast-route:^1'
```

**Arborescence attendue:**

```bash
/opt/phpdemo
├── public/
│   └── index.php
├── router.php
├── .env
├── composer.json
├── composer.lock
└── vendor/
    └── autoload.php
/etc/systemd/system/phpdemo.service
/etc/phpdemo.env            # (optionnel)
/run/phpdemo/
├── phpdemo.pid
└── app.log
```



Vérification rapide :

```bash
ls -1 /opt/phpdemo | grep -E "composer|vendor" && ls -1 /opt/phpdemo/vendor | head
# Attendu : composer.json, composer.lock, vendor/, vendor/autoload.php (dans vendor/)
```

---

# 3) Fichiers de configuration & application

### Créer le fichier **/opt/phpdemo/.env**

```dotenv
# /opt/phpdemo/.env
APP_ENV=production
PORT=8080
# LOGFILE sous /run/phpdemo (créé automatiquement au démarrage par RuntimeDirectory)
LOGFILE=/run/phpdemo/app.log
```

### Créer le fichier **/opt/phpdemo/public/index.php**

```php
<?php
// /opt/phpdemo/public/index.php
// Front controller : autoload Composer, config .env, logger Monolog, router FastRoute.

declare(strict_types=1);

require __DIR__ . '/../vendor/autoload.php';

use Dotenv\Dotenv;
use Monolog\Handler\StreamHandler;
use Monolog\Level;
use Monolog\Logger;
use FastRoute\Dispatcher;

// 1) Charger .env (safeLoad = optionnel)
$dotenv = Dotenv::createImmutable(dirname(__DIR__));
$dotenv->safeLoad();

$env     = $_ENV['APP_ENV'] ?? 'production';
$port    = (int)($_ENV['PORT'] ?? 8080);
$logfile = $_ENV['LOGFILE'] ?? '/run/phpdemo/app.log';

// 2) Logger
$logger = new Logger('phpdemo');
$logger->pushHandler(new StreamHandler($logfile, Level::Info));
$logger->info('App boot', ['env' => $env, 'port' => $port]);

// 3) Router
$dispatcher = FastRoute\simpleDispatcher(function(FastRoute\RouteCollector $r) {
    $r->addRoute('GET', '/',       'home');
    $r->addRoute('GET', '/health', 'health');
    $r->addRoute('GET', '/time',   'time');
    $r->addRoute('POST','/echo',   'echo');
});

// 4) Récup méthode + URI
$httpMethod = $_SERVER['REQUEST_METHOD'] ?? 'GET';
$uri = $_SERVER['REQUEST_URI'] ?? '/';
if (($pos = strpos($uri, '?')) !== false) { $uri = substr($uri, 0, $pos); }
$uri = rawurldecode($uri);

// 5) Dispatch
header('Content-Type: application/json; charset=UTF-8');
$routeInfo = $dispatcher->dispatch($httpMethod, $uri);

switch ($routeInfo[0]) {
    case Dispatcher::NOT_FOUND:
        http_response_code(404);
        echo json_encode(['status' => 'error', 'message' => 'Not Found']);
        $logger->warning('404 Not Found', ['uri' => $uri]);
        break;

    case Dispatcher::METHOD_NOT_ALLOWED:
        http_response_code(405);
        echo json_encode(['status' => 'error', 'message' => 'Method Not Allowed']);
        $logger->warning('405 Method Not Allowed', ['uri' => $uri]);
        break;

    case Dispatcher::FOUND:
        $handler = $routeInfo[1];
        $logger->info('Route matched', ['uri' => $uri, 'handler' => $handler]);

        if ($handler === 'home')   { echo json_encode(['message' => 'Hello from PHP + FastRoute + Monolog']); break; }
        if ($handler === 'health') { echo json_encode(['status'  => 'OK']); break; }
        if ($handler === 'time')   { echo json_encode(['now'     => date('c')]); break; }
        if ($handler === 'echo')   { $input = file_get_contents('php://input'); echo json_encode(['you_posted' => json_decode($input, true)]); break; }

        http_response_code(500);
        echo json_encode(['status' => 'error', 'message' => 'Unhandled route']);
        $logger->error('Unhandled route', ['handler' => $handler]);
        break;
}
```

### Créer le fichier **/opt/phpdemo/router.php**

```php
<?php
// /opt/phpdemo/router.php
// Routeur pour le serveur intégré (-S) : fichiers statiques si présents, sinon index.php.

$path = parse_url($_SERVER['REQUEST_URI'] ?? '/', PHP_URL_PATH);
$file = __DIR__ . '/public' . $path;

if ($path !== '/' && is_file($file)) {
    return false; // laisser PHP servir le statique
}

require __DIR__ . '/public/index.php';
```

Appliquer les droits :

```bash
sudo chown -R phpdemo:phpdemo /opt/phpdemo
```

---

# 4) Unité systemd **Type=forking**

**Fichier à créer :** `/etc/systemd/system/phpdemo.service`

```ini
# /etc/systemd/system/phpdemo.service
[Unit]
Description=PHP demo (Composer + FastRoute + Dotenv + Monolog, forking)
After=network-online.target
Wants=network-online.target

[Service]
Type=forking
User=phpdemo
Group=phpdemo
WorkingDirectory=/opt/phpdemo
RuntimeDirectory=phpdemo
RuntimeDirectoryMode=0755
PIDFile=/run/phpdemo/phpdemo.pid

EnvironmentFile=-/etc/phpdemo.env
Environment="PATH=/usr/local/bin:/usr/bin:/bin"

ExecStart=/usr/sbin/start-stop-daemon \
  --start \
  --background \
  --make-pidfile \
  --pidfile /run/phpdemo/phpdemo.pid \
  --exec /usr/bin/php -- -S 0.0.0.0:${PORT:-8080} /opt/phpdemo/router.php

ExecStop=/usr/sbin/start-stop-daemon --stop --pidfile /run/phpdemo/phpdemo.pid --retry 5
Restart=on-failure
RestartSec=2

StandardOutput=journal
StandardError=journal
SyslogIdentifier=phpdemo
LogRateLimitIntervalSec=30s
LogRateLimitBurst=200

NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=full
ProtectHome=read-only

MemoryMax=300M
CPUQuota=50%
TasksMax=150

[Install]
WantedBy=multi-user.target
```

### Infos (hors bloc systemd)

- **Dépendances réseau** : `After/Wants=network-online.target`.

- **RuntimeDirectory** : `/run/phpdemo` (PID + log via `.env`).

- **EnvironmentFile** (optionnel) : `/etc/phpdemo.env` pour overrides (`PORT`, `LOGFILE`).

- **Journal** : `StandardOutput/StandardError=journal`, `SyslogIdentifier=phpdemo`.

---

# 5) Activer, démarrer, tester

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now phpdemo
sudo systemctl status phpdemo
```

Tests :

```bash
curl -s http://127.0.0.1:8080/
curl -s http://127.0.0.1:8080/health
curl -s http://127.0.0.1:8080/time
curl -s -X POST http://127.0.0.1:8080/echo -H 'Content-Type: application/json' -d '{"msg":"hello"}'

sudo ss -ltnp | grep :8080
journalctl -u phpdemo -b -e
```

---

# 6) Overrides à chaud (optionnel)

**Fichier à créer :** `/etc/phpdemo.env`

```dotenv
PORT=9090
LOGFILE=/run/phpdemo/app.log
```

```bash
sudo systemctl restart phpdemo
curl -s http://127.0.0.1:9090/health
```

# 7) Nettoyage (rollback complet)

```bash
sudo systemctl disable --now phpdemo
sudo rm -f /etc/systemd/system/phpdemo.service
sudo systemctl daemon-reload
sudo rm -rf /opt/phpdemo
sudo rm -f /etc/phpdemo.env
sudo userdel phpdemo
# Optionnel : supprimer Composer/dépendances si installés uniquement pour la démo
# sudo rm -f /usr/local/bin/composer
```

---

# 8) Activer, démarrer, vérifier

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now phpdemo
sudo systemctl status phpdemo
```

Tests rapides :

```bash
curl -s http://127.0.0.1:8080/
curl -s http://127.0.0.1:8080/health
curl -s http://127.0.0.1:8080/time
curl -s -X POST http://127.0.0.1:8080/echo -H 'Content-Type: application/json' -d '{"msg":"hello"}'

# Port + PID + logs
sudo ss -ltnp | grep :8080
journalctl -u phpdemo -b -e
```

---

# 9) Overrides à chaud (optionnel)

**Fichier à créer :** `/etc/phpdemo.env` (permet d’éviter de modifier `.env` dans /opt)

```dotenv
PORT=9090
LOGFILE=/run/phpdemo/app.log
```

```bash
sudo systemctl restart phpdemo
curl -s http://127.0.0.1:9090/health
```

---

# 10) Nettoyage (rollback)

```bash
sudo systemctl disable --now phpdemo
sudo rm -f /etc/systemd/system/phpdemo.service
sudo systemctl daemon-reload
sudo rm -rf /opt/phpdemo
sudo rm -f /etc/phpdemo.env
sudo userdel phpdemo
# Optionnel : supprimer Composer / dépendances si installé uniquement pour le test
# sudo rm -f /usr/local/bin/composer
```

---

## Remarques pratiques

- En **prod**, évitez le serveur intégré PHP ; remplacez-le par **php-fpm + nginx**. Le schéma *Type=forking + PIDFile* reste valable pour un *launcher* custom si vous en avez besoin pour la démo.

- Le **logger** Monolog écrit dans `/run/phpdemo/app.log`. Assurez-vous que `RuntimeDirectory` est bien créé au démarrage (c’est le cas ici).
