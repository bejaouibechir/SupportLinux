# # Service Notify

# Objectif

- Monter un **service `systemd` Type=notify** propre.

- Signaler lâ€™Ã©tat **READY** quand lâ€™appli est rÃ©ellement prÃªte.

- (Optionnel) DÃ©montrer un **mail** de confirmation (Postfix ou similaire doit Ãªtre installÃ©).

- Inclure **cleanup**.

---

## 1) PrÃ©paration

```bash
sudo apt update
sudo apt install -y python3 python3-flask curl
# utilisateur de service minimal
sudo useradd --system --home /opt/notifydemo --shell /usr/sbin/nologin notifydemo
sudo mkdir -p /opt/notifydemo
sudo chown -R notifydemo:notifydemo /opt/notifydemo
```

---

## 2) Application Flask (avec /health) â€” **/opt/notifydemo/app.py**

```python
# /opt/notifydemo/app.py
# Appli Flask minimale avec un endpoint de santÃ©.
# Elle tourne au premier plan ; câ€™est le wrapper qui gÃ©rera le "notify READY".
from flask import Flask

app = Flask(__name__)

@app.get("/")
def index():
    return "Hello from Type=notify demo!\n"

@app.get("/health")
def health():
    # Renvoie 200 si l'appli est up
    return "OK\n", 200

if __name__ == "__main__":
    # Ã‰coute sur toutes les interfaces, port configurable via PORT (dÃ©faut 5001)
    import os
    port = int(os.environ.get("PORT", "5001"))
    app.run(host="0.0.0.0", port=port)
```

```bash
sudo chown notifydemo:notifydemo /opt/notifydemo/app.py
```

---

## 3) Wrapper Bash qui fait le **notify** â€” **/opt/notifydemo/run.sh**

Le script **/opt/notifydemo/run.sh** sert de **wrapper** entre systemd et lâ€™application Flask, il notifie le systemd que le service est en cour Ã  prÃ©sent

```bash
#!/bin/bash
# /opt/notifydemo/run.sh
# RÃ´le :
# 1) lancer Flask en arriÃ¨re-plan
# 2) boucler jusqu'Ã  ce que /health rÃ©ponde 200
# 3) envoyer READY=1 Ã  systemd (systemd-notify)
# 4) (optionnel) envoyer un mail local via Postfix (sendmail) pour confirmer
# 5) attendre le process Flask (propager son arrÃªt Ã  systemd)

set -euo pipefail

APP_PORT="${PORT:-5001}"

# 1) DÃ©marre Flask en arriÃ¨re-plan
/usr/bin/python3 /opt/notifydemo/app.py &
APP_PID=$!

# 2) Attends que l'appli rÃ©ponde sur /health (max ~30s)
for i in {1..30}; do
  if curl -fsS "http://127.0.0.1:${APP_PORT}/health" >/dev/null; then
    # 3) Signale "READY" Ã  systemd, avec un petit statut lisible
    /usr/bin/systemd-notify --ready --status="notifydemo ready on :${APP_PORT}"
    # 4) (optionnel) Mail local via Postfix s'il y a /usr/sbin/sendmail
    if command -v /usr/sbin/sendmail >/dev/null 2>&1; then
      printf "Subject: notifydemo ready\nTo: root\n\nService notifydemo READY on port %s\n" "$APP_PORT" | /usr/sbin/sendmail -t || true
    fi
    break
  fi
  sleep 1
done

# Si Flask est mort pendant lâ€™attente, Ã©choue le service
if ! kill -0 "$APP_PID" 2>/dev/null; then
  exit 1
fi

# (BONUS Watchdog : si WatchdogSec est activÃ©, systemd set WATCHDOG_USEC.
# On ferait ici un ping pÃ©riodique : /usr/bin/systemd-notify WATCHDOG=1
# Exemple (commentÃ© par dÃ©faut) :
# if [[ -n "${WATCHDOG_USEC:-}" ]]; then
#   while kill -0 "$APP_PID" 2>/dev/null; do
#     /usr/bin/systemd-notify WATCHDOG=1
#     sleep 2
#   done
# fi

# 5) Attend Flask (quand Flask s'arrÃªte, ce script s'arrÃªte â†’ systemd le voit)
wait "$APP_PID"
```

```bash
sudo chown notifydemo:notifydemo /opt/notifydemo/run.sh
sudo chmod +x /opt/notifydemo/run.sh
```

---

## 4) Service `systemd` Type=notify â€” **/etc/systemd/system/notifydemo.service**

Le service **/etc/systemd/system/notifydemo.service** est dÃ©fini avec `Type=notify`.  
Cela signifie que **systemd ne considÃ¨re pas le service comme â€œprÃªtâ€ tant quâ€™il nâ€™a pas reÃ§u un message explicite READY=1**.

```ini
[Unit]
Description=Notify demo (Flask) - Type=notify
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
# Le wrapper (processus principal) envoie READY=1.
# NotifyAccess=all autorise tout process du cgroup (wrapper ou enfants) Ã  notifier si besoin.
NotifyAccess=all

User=notifydemo
Group=notifydemo
WorkingDirectory=/opt/notifydemo
Environment=PORT=5001

# Lance le wrapper (qui dÃ©marre Flask, vÃ©rifie /health, puis notifie READY)
ExecStart=/opt/notifydemo/run.sh

Restart=on-failure
RestartSec=2

# (BONUS, dÃ©sactivÃ© par dÃ©faut) : activer le watchdog et dÃ©commenter la boucle WATCHDOG=1 dans run.sh
# WatchdogSec=10s

[Install]
WantedBy=multi-user.target
```

---

## 5) DÃ©marrage & vÃ©rifications

Voici le mÃ©canisme :

1. **systemd dÃ©marre le service** â†’ il exÃ©cute `ExecStart=/opt/notifydemo/run.sh`.

2. **Le script run.sh** lance Flask en arriÃ¨re-plan puis vÃ©rifie la santÃ© (`/health`).

3. **Quand Flask rÃ©pond correctement**, le script appelle :
   
   ```bash
   /usr/bin/systemd-notify --ready --status="notifydemo ready on :5001"
   ```

4. - `--ready` â†’ envoie le signal `READY=1` Ã  systemd.
   
   - `--status="..."` â†’ met Ã  jour la ligne *StatusText* visible dans `systemctl status`.

5. **systemd reÃ§oit le message via socket interne (`NOTIFY_SOCKET`)** â†’ il bascule lâ€™Ã©tat du service de *starting* â†’ *active (running)*.

ğŸ‘‰ RÃ©sultat : lâ€™unitÃ© nâ€™est dÃ©clarÃ©e active par systemd **que lorsque lâ€™application a confirmÃ© elle-mÃªme quâ€™elle est prÃªte**, et non juste parce que le processus a Ã©tÃ© lancÃ©.

**Redemarrage de systemd:**

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now notifydemo
sudo systemctl status notifydemo
```

**Tests rapides :**

```bash
# Doit rÃ©pondre OK
curl -s http://127.0.0.1:5001/health

# Page d'accueil
curl -s http://127.0.0.1:5001/

# Voir le "Status: notifydemo ready on :5001" et l'Ã©tat READY
systemctl show -p ActiveState,SubState,StatusText notifydemo

# Logs (inclut les sorties et les notifications)
journalctl -u notifydemo -b -e
```

**Mail local (optionnel)** : si Postfix expose `/usr/sbin/sendmail`, tu peux vÃ©rifier la rÃ©ception (boÃ®te locale `root`) :

```bash
sudo tail -n +1 /var/mail/root 2>/dev/null | tail -n 50
# (ou 'mail' si mailutils est installÃ©)
```

---

## 6) Nettoyage (rollback)

```bash
sudo systemctl disable --now notifydemo
sudo rm -f /etc/systemd/system/notifydemo.service
sudo systemctl daemon-reload
sudo rm -rf /opt/notifydemo
sudo userdel notifydemo 2>/dev/null || true
# (garde Flask/curl si tu les utilises ailleurs)
```

---

### En rÃ©sumÃ©:

- `Type=notify` : le service nâ€™est â€œREADYâ€ quâ€™aprÃ¨s un **sd_notify(READY=1)** (ici via `systemd-notify --ready`).

- Le wrapper permet de **dÃ©corrÃ©ler â€œprocess lancÃ©â€ et â€œservice prÃªtâ€** (vÃ©rif rÃ©elle via `/health`).

- IntÃ©gration simple dâ€™une action post-prÃªt (ex : **mail** via Postfix).

- *Bonus* possible : **Watchdog** (envoi pÃ©riodique `WATCHDOG=1`).
