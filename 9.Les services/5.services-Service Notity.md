# # Service Notify

# Objectif

- Monter un **service `systemd` Type=notify** propre.

- Signaler l’état **READY** quand l’appli est réellement prête.

- (Optionnel) Démontrer un **mail** de confirmation (Postfix ou similaire doit être installé).

- Inclure **cleanup**.

---

## 1) Préparation

```bash
sudo apt update
sudo apt install -y python3 python3-flask curl
# utilisateur de service minimal
sudo useradd --system --home /opt/notifydemo --shell /usr/sbin/nologin notifydemo
sudo mkdir -p /opt/notifydemo
sudo chown -R notifydemo:notifydemo /opt/notifydemo
```

---

## 2) Application Flask (avec /health) — **/opt/notifydemo/app.py**

```python
# /opt/notifydemo/app.py
# Appli Flask minimale avec un endpoint de santé.
# Elle tourne au premier plan ; c’est le wrapper qui gérera le "notify READY".
from flask import Flask

app = Flask(__name__)

@app.get("/")
def index():
    return "Hello from Type=notify demo!\n"

@app.get("/health")
def health():
    # Renvoie 200 si l'appli est up
    return "OK\n", 200

if __name__ == "__main__":
    # Écoute sur toutes les interfaces, port configurable via PORT (défaut 5001)
    import os
    port = int(os.environ.get("PORT", "5001"))
    app.run(host="0.0.0.0", port=port)
```

```bash
sudo chown notifydemo:notifydemo /opt/notifydemo/app.py
```

---

## 3) Wrapper Bash qui fait le **notify** — **/opt/notifydemo/run.sh**

Le script **/opt/notifydemo/run.sh** sert de **wrapper** entre systemd et l’application Flask, il notifie le systemd que le service est en cour à présent

```bash
#!/bin/bash
# /opt/notifydemo/run.sh
# Rôle :
# 1) lancer Flask en arrière-plan
# 2) boucler jusqu'à ce que /health réponde 200
# 3) envoyer READY=1 à systemd (systemd-notify)
# 4) (optionnel) envoyer un mail local via Postfix (sendmail) pour confirmer
# 5) attendre le process Flask (propager son arrêt à systemd)

set -euo pipefail

APP_PORT="${PORT:-5001}"

# 1) Démarre Flask en arrière-plan
/usr/bin/python3 /opt/notifydemo/app.py &
APP_PID=$!

# 2) Attends que l'appli réponde sur /health (max ~30s)
for i in {1..30}; do
  if curl -fsS "http://127.0.0.1:${APP_PORT}/health" >/dev/null; then
    # 3) Signale "READY" à systemd, avec un petit statut lisible
    /usr/bin/systemd-notify --ready --status="notifydemo ready on :${APP_PORT}"
    # 4) (optionnel) Mail local via Postfix s'il y a /usr/sbin/sendmail
    if command -v /usr/sbin/sendmail >/dev/null 2>&1; then
      printf "Subject: notifydemo ready\nTo: root\n\nService notifydemo READY on port %s\n" "$APP_PORT" | /usr/sbin/sendmail -t || true
    fi
    break
  fi
  sleep 1
done

# Si Flask est mort pendant l’attente, échoue le service
if ! kill -0 "$APP_PID" 2>/dev/null; then
  exit 1
fi

# (BONUS Watchdog : si WatchdogSec est activé, systemd set WATCHDOG_USEC.
# On ferait ici un ping périodique : /usr/bin/systemd-notify WATCHDOG=1
# Exemple (commenté par défaut) :
# if [[ -n "${WATCHDOG_USEC:-}" ]]; then
#   while kill -0 "$APP_PID" 2>/dev/null; do
#     /usr/bin/systemd-notify WATCHDOG=1
#     sleep 2
#   done
# fi

# 5) Attend Flask (quand Flask s'arrête, ce script s'arrête → systemd le voit)
wait "$APP_PID"
```

```bash
sudo chown notifydemo:notifydemo /opt/notifydemo/run.sh
sudo chmod +x /opt/notifydemo/run.sh
```

---

## 4) Service `systemd` Type=notify — **/etc/systemd/system/notifydemo.service**

Le service **/etc/systemd/system/notifydemo.service** est défini avec `Type=notify`.  
Cela signifie que **systemd ne considère pas le service comme “prêt” tant qu’il n’a pas reçu un message explicite READY=1**.

```ini
[Unit]
Description=Notify demo (Flask) - Type=notify
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
# Le wrapper (processus principal) envoie READY=1.
# NotifyAccess=all autorise tout process du cgroup (wrapper ou enfants) à notifier si besoin.
NotifyAccess=all

User=notifydemo
Group=notifydemo
WorkingDirectory=/opt/notifydemo
Environment=PORT=5001

# Lance le wrapper (qui démarre Flask, vérifie /health, puis notifie READY)
ExecStart=/opt/notifydemo/run.sh

Restart=on-failure
RestartSec=2

# (BONUS, désactivé par défaut) : activer le watchdog et décommenter la boucle WATCHDOG=1 dans run.sh
# WatchdogSec=10s

[Install]
WantedBy=multi-user.target
```

---

## 5) Démarrage & vérifications

Voici le mécanisme :

1. **systemd démarre le service** → il exécute `ExecStart=/opt/notifydemo/run.sh`.

2. **Le script run.sh** lance Flask en arrière-plan puis vérifie la santé (`/health`).

3. **Quand Flask répond correctement**, le script appelle :
   
   ```bash
   /usr/bin/systemd-notify --ready --status="notifydemo ready on :5001"
   ```

4. - `--ready` → envoie le signal `READY=1` à systemd.
   
   - `--status="..."` → met à jour la ligne *StatusText* visible dans `systemctl status`.

5. **systemd reçoit le message via socket interne (`NOTIFY_SOCKET`)** → il bascule l’état du service de *starting* → *active (running)*.

👉 Résultat : l’unité n’est déclarée active par systemd **que lorsque l’application a confirmé elle-même qu’elle est prête**, et non juste parce que le processus a été lancé.

**Redemarrage de systemd:**

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now notifydemo
sudo systemctl status notifydemo
```

**Tests rapides :**

```bash
# Doit répondre OK
curl -s http://127.0.0.1:5001/health

# Page d'accueil
curl -s http://127.0.0.1:5001/

# Voir le "Status: notifydemo ready on :5001" et l'état READY
systemctl show -p ActiveState,SubState,StatusText notifydemo

# Logs (inclut les sorties et les notifications)
journalctl -u notifydemo -b -e
```

**Mail local (optionnel)** : si Postfix expose `/usr/sbin/sendmail`, tu peux vérifier la réception (boîte locale `root`) :

```bash
sudo tail -n +1 /var/mail/root 2>/dev/null | tail -n 50
# (ou 'mail' si mailutils est installé)
```

---

## 6) Nettoyage (rollback)

```bash
sudo systemctl disable --now notifydemo
sudo rm -f /etc/systemd/system/notifydemo.service
sudo systemctl daemon-reload
sudo rm -rf /opt/notifydemo
sudo userdel notifydemo 2>/dev/null || true
# (garde Flask/curl si tu les utilises ailleurs)
```

---

### En résumé:

- `Type=notify` : le service n’est “READY” qu’après un **sd_notify(READY=1)** (ici via `systemd-notify --ready`).

- Le wrapper permet de **décorréler “process lancé” et “service prêt”** (vérif réelle via `/health`).

- Intégration simple d’une action post-prêt (ex : **mail** via Postfix).

- *Bonus* possible : **Watchdog** (envoi périodique `WATCHDOG=1`).
