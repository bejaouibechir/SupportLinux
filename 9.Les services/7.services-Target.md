# Atelier : `custom.target` qui lance 2 services forking (parallèle puis séquentiel)

## Ce qu’on va faire

- Deux micro-services **Python** (boucles infinies) qui écrivent l’heure de démarrage dans `/var/tmp/*.log`.

- Deux unités **Type=forking** basées sur `start-stop-daemon` (c’est lui qui fait le fork et crée le PID).

- Un **target** qui lance les deux services :
  
  - **Scénario 1 (parallèle)** : démarrage simultané (tolérant aux échecs).
  
  - **Scénario 2 (séquentiel)** : `otherapp` démarre **après** `myapp` et **échoue** si `myapp` n’est pas OK.

> Testé sur Debian/Ubuntu. On utilise un **seul** compte système `appsrv` pour simplifier.

---

## 0) Préparation

```bash
sudo apt update
sudo apt install -y python3

# compte de service non-login
sudo useradd --system --home /opt/apps --shell /usr/sbin/nologin appsrv

# arborescence
sudo mkdir -p /opt/apps/myapp /opt/apps/otherapp
sudo chown -R appsrv:appsrv /opt/apps
```

---

## 1) Les deux mini-apps Python (avant-plan)

**/opt/apps/myapp/app.py**

```python
# Boucle simple : log du démarrage puis "tourne"
import time
from datetime import datetime

LOG = "/var/tmp/myapp.log"

def main():
    with open(LOG, "a", encoding="utf-8") as f:
        f.write(f"[myapp] started at {datetime.now()}\n")
    while True:
        time.sleep(10)

if __name__ == "__main__":
    main()
```

**/opt/apps/otherapp/app.py**

```python
import time
from datetime import datetime

LOG = "/var/tmp/otherapp.log"

def main():
    with open(LOG, "a", encoding="utf-8") as f:
        f.write(f"[otherapp] started at {datetime.now()}\n")
    while True:
        time.sleep(10)

if __name__ == "__main__":
    main()
```

```bash
sudo chown -R appsrv:appsrv /opt/apps
```

> On logge dans **/var/tmp** (pas /var/log) pour éviter les problèmes de permissions.

---

## 2) Services **Type=forking** (simples, une seule ligne ExecStart)

> ⚠️ Vérifie le chemin de `start-stop-daemon` :  
> `command -v start-stop-daemon` → généralement `/usr/sbin/start-stop-daemon`.  
> Adapte **/usr/sbin** ci-dessous si besoin.

**/etc/systemd/system/myapp.service**

```ini
[Unit]
Description=MyApp demo (forking)
After=network.target

[Service]
Type=forking
User=appsrv
Group=appsrv
WorkingDirectory=/opt/apps/myapp
RuntimeDirectory=myapp
PIDFile=/run/myapp/myapp.pid
ExecStart=/usr/sbin/start-stop-daemon --start --background --make-pidfile --pidfile /run/myapp/myapp.pid --exec /usr/bin/python3 -- /opt/apps/myapp/app.py
ExecStop=/usr/sbin/start-stop-daemon --stop --pidfile /run/myapp/myapp.pid --retry 5
Restart=on-failure
RestartSec=2

[Install]
WantedBy=multi-user.target
```

**/etc/systemd/system/otherapp.service**

```ini
[Unit]
Description=OtherApp demo (forking)
After=network.target

[Service]
Type=forking
User=appsrv
Group=appsrv
WorkingDirectory=/opt/apps/otherapp
RuntimeDirectory=otherapp
PIDFile=/run/otherapp/otherapp.pid
ExecStart=/usr/sbin/start-stop-daemon --start --background --make-pidfile --pidfile /run/otherapp/otherapp.pid --exec /usr/bin/python3 -- /opt/apps/otherapp/app.py
ExecStop=/usr/sbin/start-stop-daemon --stop --pidfile /run/otherapp/otherapp.pid --retry 5
Restart=on-failure
RestartSec=2

[Install]
WantedBy=multi-user.target
```

---

## 3) Target personnalisé

### 3.1 Scénario 1 — **Parallèle** (tolérant)

**/etc/systemd/system/custom.target**

```ini
[Unit]
Description=Custom Target (parallel start of myapp & otherapp)
Wants=myapp.service otherapp.service
After=network.target
AllowIsolate=yes

[Install]
WantedBy=multi-user.target
```

- `Wants=` démarre les services quand on lance le target, **sans** échouer le target si un service plante.

- `AllowIsolate=yes` permet de faire `systemctl isolate custom.target` (utile pour la démo, non obligatoire).

### 3.2 Scénario 2 — **Séquentiel** (strict)

Ici on **laisse le même `custom.target`**, mais **on modifie `otherapp.service`** pour qu’il dépende de `myapp` :

Ajoute/ajuste **[Unit]** de **otherapp.service** :

```ini
[Unit]
Description=OtherApp demo (forking) - starts after myapp
After=myapp.service
Requires=myapp.service
```

- `After=myapp.service` → ordre : otherapp démarre après myapp.

- `Requires=myapp.service` → si myapp ne démarre pas, otherapp **échoue**.

---

## 4) Démarrage & vérifications

```bash
sudo systemctl daemon-reload

# D'abord, teste chaque service seul pour éviter les "dependency failed"
sudo systemctl start myapp
sudo systemctl status myapp

sudo systemctl start otherapp
sudo systemctl status otherapp

# Arrête-les (on va tester via le target)
sudo systemctl stop otherapp myapp

# ---- Scénario 1 : parallèle
sudo systemctl start custom.target
sudo systemctl status custom.target
systemctl status myapp otherapp | sed -n '1,80p'

# Logs des démarrages (horodatage)
cat /var/tmp/myapp.log
cat /var/tmp/otherapp.log
```

Tu devrais voir des timestamps très proches (démarrage parallèle).

**Passer au Scénario 2 :**

```bash
# Édite otherapp.service comme indiqué (After+Requires), puis :
sudo systemctl daemon-reload
sudo systemctl stop custom.target myapp otherapp
sudo truncate -s0 /var/tmp/myapp.log /var/tmp/otherapp.log  # on remet les logs à zéro

sudo systemctl start custom.target

# Vérif : myapp doit démarrer avant otherapp
cat /var/tmp/myapp.log
cat /var/tmp/otherapp.log
```

---

## 5) Erreurs courantes & corrections rapides

- **custom.target → “Dependency failed”**  
  → Un des services référencés n’existe pas **ou** échoue au démarrage (chemin binaire, User inexistant, PIDFile non créé).
  
  - Vérifie la présence : `systemctl cat myapp` / `systemctl cat otherapp`
  
  - Lance chaque service **individuellement** d’abord : `systemctl start myapp` puis `otherapp` pour voir l’erreur réelle.
  
  - Regarde les logs précis : `journalctl -xeu myapp` / `journalctl -xeu otherapp`.

- **status=217/USER**  
  → L’utilisateur de l’unité n’existe pas. Ici on a créé `appsrv`.  
  `id appsrv` doit répondre; sinon `sudo useradd --system ...`.

- **Le service ne “fork” pas**  
  → Assure `Type=forking` + `start-stop-daemon --background --make-pidfile --pidfile ...`.

- **PIDFile introuvable**  
  → Le chemin du `PIDFile` doit être **dans `RuntimeDirectory=`** (ici `/run/<name>/...`).  
  **Une seule ligne** `ExecStart` (pas de `\` ni de commentaires sur la ligne).

---

## 6) Activer au boot (optionnel)

```bash
# pour que le target (et donc les services) partent au boot
sudo systemctl enable custom.target
# ou activer les services individuellement :
sudo systemctl enable myapp otherapp
```

---

## 7) Nettoyage (rollback complet)

```bash
# stop + disable
sudo systemctl disable --now custom.target myapp otherapp

# retirer units
sudo rm -f /etc/systemd/system/custom.target
sudo rm -f /etc/systemd/system/myapp.service
sudo rm -f /etc/systemd/system/otherapp.service
sudo systemctl daemon-reload

# retirer apps
sudo rm -rf /opt/apps

# retirer logs
sudo rm -f /var/tmp/myapp.log /var/tmp/otherapp.log

# retirer l’utilisateur
sudo userdel appsrv 2>/dev/null || true
```

---

### Résumé

- **Scénario 1 (parallèle)** : `custom.target` avec `Wants=...` (tolérant).

- **Scénario 2 (séquentiel)** : même target, mais `otherapp.service` a `After+Requires` sur `myapp`.

- Services **forking** propres via `start-stop-daemon`, PID géré dans `/run/<name>/...`, scripts simples, et logs chrono dans `/var/tmp/*.log`.

Si tu veux la variante **Flask** (ports 5001/5002) à la place des boucles, je te la fournis en 2 fichiers et ça s’intègre **sans changer** la logique des unités/target.
