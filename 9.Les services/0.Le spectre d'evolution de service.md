# Spectre d'evolution de service

### Contexte:

Nous allons suivre une suite de versionning de service commençant d'une forme basique pour y aller vers des formes plus sophistiquées

### 1. Mise à jour du système et installation de Python 3

Cette commande met à jour les paquets et installe Python 3, nécessaire pour exécuter le script.

```bash
sudo apt update && sudo apt install -y python3
```

---

### 2. Création d’un utilisateur système

On crée un utilisateur dédié `iterdemo`, sans shell interactif, avec son répertoire d’application sous `/opt/iterdemo`.  
Le `|| true` permet d’éviter une erreur si l’utilisateur existe déjà.

```bash
sudo useradd --system --home /opt/iterdemo --shell /usr/sbin/nologin iterdemo || true
```

---

### 3. Création du dossier de l’application

On prépare le dossier `/opt/iterdemo` qui va contenir le script Python.

```bash
sudo mkdir -p /opt/iterdemo
```

---

### 4. Fichier `app.py`

C’est le cœur du programme. Ce script écrit des logs à intervalle régulier (par défaut toutes les 5 secondes) dans un fichier.  
Il gère proprement l’arrêt via les signaux `SIGTERM` et `SIGINT`.

Créer le fichier `/opt/iterdemo/app.py` :

```python
from datetime import datetime
import os, time, signal

# Fichier de log configurable par variable d’environnement
LOG = os.getenv("LOGFILE", "/var/tmp/iterdemo.log")

# Intervalle entre deux écritures (par défaut 5 secondes)
INTERVAL = float(os.getenv("INTERVAL", "5"))

_running = True

# Gestion de l’arrêt du processus avec SIGTERM ou Ctrl+C
def _stop(*_): 
    global _running
    _running = False

signal.signal(signal.SIGTERM, _stop)
signal.signal(signal.SIGINT, _stop)

# Écriture des événements dans le fichier de log
with open(LOG, "a", encoding="utf-8") as f:
    f.write(f"[start] {datetime.now()}\n")
    f.flush()
    while _running:
        f.write(f"[tick]  {datetime.now()}\n")
        f.flush()
        time.sleep(INTERVAL)
```

---

### 5. Attribution des permissions

On donne la propriété du dossier `/opt/iterdemo` à l’utilisateur système `iterdemo`.

```bash
sudo chown -R iterdemo:iterdemo /opt/iterdemo
```



# ÉTAPE 0 — MVP minimal

## Pourquoi

Avoir un service qui démarre et tourne. Base de comparaison pour toutes les évolutions.

## Focus attributs

* **Type=simple** : l’app reste au premier plan ; systemd suit ce PID.
* **ExecStart=** : commande de démarrage.
* **WantedBy=** : assure le démarrage au boot si `enable`.

## Fichier `/etc/systemd/system/iterdemo.service`

```ini
[Unit]
Description=Iterdemo MVP (minimal)

[Service]
Type=simple
ExecStart=/usr/bin/python3 /opt/iterdemo/app.py

[Install]
WantedBy=multi-user.target
```

## Scénario (marche / casse / répare)

* **Marche** : service démarre et écrit des `[tick]`.
* **Casse** : mets un mauvais chemin d’interpréteur (`/usr/bin/pythonX`) → échec **203/EXEC**.
* **Répare** : reviens à `/usr/bin/python3`.

## Commandes & observations

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now iterdemo.service
systemctl status iterdemo.service
tail -n 5 /var/tmp/iterdemo.log
```

Tu dois voir `active (running)` et des `[tick]`.

---

# ÉTAPE 1 — Identité & répertoire de travail

## Pourquoi

Faire tourner sous **compte dédié** pour contrôler l’accès au code. On démontre ici l’impact des droits sur l'excution du service

## Focus attributs

* **User= / Group=** : Le nom de l'utilisateur
* **WorkingDirectory=** : Le nom du répertoire du travail

## Fichier `/etc/systemd/system/iterdemo.service`

```ini
[Unit]
Description=Faire tourner sous user iterdemo pour contrôler l’accès au code

[Service]
Type=simple
User=iterdemo
Group=iterdemo
WorkingDirectory=/opt/iterdemo
ExecStart=/usr/bin/python3 /opt/iterdemo/app.py

[Install]
WantedBy=multi-user.target
```

## Scénario (marche / casse / répare)

1. **Marche** :

```bash
sudo chmod 750 /opt/iterdemo
sudo chown -R iterdemo:iterdemo /opt/iterdemo
sudo systemctl daemon-reload && sudo systemctl restart iterdemo
```

→ OK, l’utilisateur **iterdemo** lit le code, les ticks continuent.

2. **Casse** (change d’utilisateur) :

```bash
sudo sed -i 's/^User=.*/User=nobody/' /etc/systemd/system/iterdemo.service
sudo systemctl daemon-reload && sudo systemctl restart iterdemo
```

→ échec **(permission denied / 203-EXEC)** car `nobody` ne peut pas entrer dans `/opt/iterdemo` (750) il n'a pas les permissions.

3. **Répare** :

```bash
sudo sed -i 's/^User=.*/User=iterdemo/' /etc/systemd/system/iterdemo.service
sudo systemctl daemon-reload && sudo systemctl restart iterdemo
```

→ `active (running)` à nouveau.

---

# ÉTAPE 2 — Résilience (relance & délais)

## Pourquoi

La résilience assure de ne pas rester en panne après un crash et arrêter le service proprement.

## Fichier

```ini
[Unit]
Description=Iterdemo + restart policy

[Service]
Type=simple
User=iterdemo
Group=iterdemo
WorkingDirectory=/opt/iterdemo
ExecStart=/usr/bin/python3 /opt/iterdemo/app.py
Restart=always
RestartSec=2
TimeoutStopSec=5
KillSignal=SIGINT

[Install]
WantedBy=multi-user.target
```

# 

## Scénario

* **Marche** : kill le process → il repart.

```bash
pid=$(systemctl show -p MainPID --value iterdemo); sudo kill -9 "$pid"; sleep 2; systemctl status iterdemo
```

* **Casse** : mets `KillSignal=SIGKILL` + `TimeoutStopSec=1` → arrêt brutal ; répare en remettant `SIGINT/5s`.

---

# ÉTAPE 3 — Configuration externe

## Pourquoi

Changer le comportement **sans modifier le code**.

## Focus attributs

* **EnvironmentFile=** (avec `-` pour rendre optionnel)
* **Environment=PATH=** minimal

## Fichiers

`/etc/default/iterdemo` :

```bash
printf "LOGFILE=/var/tmp/iterdemo.log\nINTERVAL=2\n" | sudo tee /etc/default/iterdemo >/dev/null
```

`/etc/systemd/system/iterdemo.service` :

```ini
[Unit]
Description=Iterdemo + environment file

[Service]
Type=simple
User=iterdemo
Group=iterdemo
WorkingDirectory=/opt/iterdemo
EnvironmentFile=-/etc/default/iterdemo
Environment=PATH=/usr/bin:/bin
ExecStart=/usr/bin/python3 /opt/iterdemo/app.py
Restart=always
RestartSec=2
TimeoutStopSec=5
KillSignal=SIGINT

[Install]
WantedBy=multi-user.target
```

## Scénario

* **Marche** : INTERVAL=2 → ticks plus fréquents.
* **Casse** : mets `INTERVAL=abc` → crash (ValueError) → observe les redémarrages.
* **Répare** : remets `INTERVAL=2`.

---

# ÉTAPE 4 — Ordonnancement réseau (quand c’est pertinent)

## Pourquoi

Certaines applis doivent attendre que “le réseau logique” soit prêt (DHCP, routes).
On illustre l’ordre de démarrage, pas une dépendance stricte.

## Focus attributs

* **After=network-online.target**, **Wants=network-online.target**

## Fichier

```ini
[Unit]
Description=Iterdemo + ordering (network-online)
Wants=network-online.target
After=network-online.target

[Service]
Type=simple
User=iterdemo
Group=iterdemo
WorkingDirectory=/opt/iterdemo
EnvironmentFile=-/etc/default/iterdemo
Environment=PATH=/usr/bin:/bin
ExecStart=/usr/bin/python3 /opt/iterdemo/app.py
Restart=always
RestartSec=2
TimeoutStopSec=5
KillSignal=SIGINT

[Install]
WantedBy=multi-user.target
```

## Scénario

* **Démonstration simple** (sans toucher aux interfaces) :
  ajoute un pré-check réseau rapide (puis retire-le après test) :
  
  ```bash
  sudo sed -i 's#^ExecStart=.*#ExecStart=/bin/sh -c "/usr/bin/curl -sSf https://example.com >/dev/null && exec /usr/bin/python3 /opt/iterdemo/app.py"#' /etc/systemd/system/iterdemo.service
  sudo systemctl daemon-reload && sudo systemctl restart iterdemo
  ```
  
  * **Casse** : coupe temporairement l’accès (pare-feu, câble, hotspot off) → `curl` échoue → service en échec.
  * **Répare** : accès rétabli → `restart` → OK.
  * **Reviens** ensuite à l’ExecStart original (retire la partie `curl … &&`).

> Note : `After=` règle l’**ordre** ; pour échouer si le réseau n’est pas prêt, on met un **pré-check** (ici `curl`) ou `Requires=network-online.target` selon l’environnement.

---

# ÉTAPE 5 — Répertoire runtime géré par systemd

## Pourquoi

Créer automatiquement un espace d’écriture volatil (propriétaire, droits cohérents).

## Focus attributs

* **RuntimeDirectory=**, **RuntimeDirectoryMode=** (+ LOGFILE sous /run/iterdemo)

## Fichiers

`/etc/default/iterdemo` :

```bash
printf "LOGFILE=/run/iterdemo/service.log\nINTERVAL=2\n" | sudo tee /etc/default/iterdemo >/dev/null
```

Service :

```ini
[Unit]
Description=Iterdemo + RuntimeDirectory managed
Wants=network-online.target
After=network-online.target

[Service]
Type=simple
User=iterdemo
Group=iterdemo
WorkingDirectory=/opt/iterdemo
EnvironmentFile=-/etc/default/iterdemo
Environment=PATH=/usr/bin:/bin
RuntimeDirectory=iterdemo
RuntimeDirectoryMode=0755
ExecStart=/usr/bin/python3 /opt/iterdemo/app.py
Restart=always
RestartSec=2
TimeoutStopSec=5
KillSignal=SIGINT

[Install]
WantedBy=multi-user.target
```

## Scénario

* **Marche** : `/run/iterdemo` créé par systemd, log écrit dedans.
* **Casse** : mets `LOGFILE=/run/iterdemo/service.log` **sans** `RuntimeDirectory=iterdemo` → `No such file or directory`.
* **Répare** : remets `RuntimeDirectory=iterdemo`.

---

# ÉTAPE 6 — Quotas & limites

## Pourquoi

Empêcher une app défaillante de consommer toutes les ressources.

## Focus attributs

* **MemoryMax=**, **CPUQuota=**, **TasksMax=**

## Fichier

```ini
[Unit]
Description=Iterdemo + resource limits
Wants=network-online.target
After=network-online.target

[Service]
Type=simple
User=iterdemo
Group=iterdemo
WorkingDirectory=/opt/iterdemo
EnvironmentFile=-/etc/default/iterdemo
Environment=PATH=/usr/bin:/bin
RuntimeDirectory=iterdemo
RuntimeDirectoryMode=0755
ExecStart=/usr/bin/python3 /opt/iterdemo/app.py
Restart=always
RestartSec=2
TimeoutStopSec=5
KillSignal=SIGINT
MemoryMax=100M
CPUQuota=50%
TasksMax=50

[Install]
WantedBy=multi-user.target
```

## Scénario

* **Marche** : service OK avec limites larges.
* **Casse douce** : passe `CPUQuota=1%` → les `[tick]` paraîtront plus espacés si ta charge CPU est déjà non nulle.
* **Répare** : reviens à `CPUQuota=50%` (ou supprime la directive).

---

# ÉTAPE 7 — Durcissement (sandboxing “safe”)

## Pourquoi

Réduire la surface d’attaque sans casser le fonctionnement.

## Focus attributs

* **NoNewPrivileges=**, **PrivateTmp=**, **ProtectSystem=full**, **ProtectHome=read-only**
* **RestrictAddressFamilies=AF\_UNIX** (bloque IP ; garde **AF\_UNIX** pour le local)
* **MemoryDenyWriteExecute=true**

## Fichier

```ini
[Unit]
Description=Iterdemo + basic sandbox
Wants=network-online.target
After=network-online.target
StartLimitIntervalSec=60s
StartLimitBurst=5

[Service]
Type=simple
User=iterdemo
Group=iterdemo
WorkingDirectory=/opt/iterdemo
EnvironmentFile=-/etc/default/iterdemo
Environment=PATH=/usr/bin:/bin
RuntimeDirectory=iterdemo
RuntimeDirectoryMode=0755
ExecStart=/usr/bin/python3 /opt/iterdemo/app.py
Restart=always
RestartSec=2
TimeoutStopSec=5
KillSignal=SIGINT
MemoryMax=100M
CPUQuota=50%
TasksMax=50
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=full
ProtectHome=read-only
RestrictAddressFamilies=AF_UNIX
MemoryDenyWriteExecute=true

[Install]
WantedBy=multi-user.target
```

## Scénario

* **Marche** : notre app n’ouvre pas de sockets IP → pas d’impact.
* **Casse volontaire** (si tu ajoutes du réseau plus tard) : avec `RestrictAddressFamilies=AF_UNIX`, tout trafic IP échoue → retire-la ou ajoute `AF_INET AF_INET6`.
* **Répare** : adapte la liste ou commente la directive.

---

# ÉTAPE 8 — Journalisation & limites de logs

## Pourquoi

Tracer proprement et éviter de saturer le journal en cas de rafale.

## Focus attributs

* **StandardOutput=journal**, **StandardError=journal**
* **SyslogIdentifier=**, **LogRateLimitIntervalSec=**, **LogRateLimitBurst=**

## Fichier

```ini
[Unit]
Description=Iterdemo + logging & rate limits
Wants=network-online.target
After=network-online.target
StartLimitIntervalSec=60s
StartLimitBurst=5

[Service]
Type=simple
User=iterdemo
Group=iterdemo
WorkingDirectory=/opt/iterdemo
EnvironmentFile=-/etc/default/iterdemo
Environment=PATH=/usr/bin:/bin
RuntimeDirectory=iterdemo
RuntimeDirectoryMode=0755
ExecStart=/usr/bin/python3 /opt/iterdemo/app.py
Restart=always
RestartSec=2
TimeoutStopSec=5
KillSignal=SIGINT
MemoryMax=100M
CPUQuota=50%
TasksMax=50
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=full
ProtectHome=read-only
RestrictAddressFamilies=AF_UNIX
MemoryDenyWriteExecute=true
StandardOutput=journal
StandardError=journal
SyslogIdentifier=iterdemo
LogRateLimitIntervalSec=30s
LogRateLimitBurst=200

[Install]
WantedBy=multi-user.target
```

## Scénario

* **Marche** : observe les messages via :
  
  ```bash
  journalctl -u iterdemo.service -n 30 --no-pager
  ```

* **Casse douce** : mets `INTERVAL=0.05` dans `/etc/default/iterdemo` → rafale de logs → le rate limit s’applique (tu verras des lignes “rate-limited”).

* **Répare** : remets `INTERVAL=2` ou ajuste les limites.

---

## Commandes génériques entre les étapes

```bash
sudo systemctl daemon-reload
sudo systemctl restart iterdemo.service
systemctl status iterdemo.service
journalctl -u iterdemo.service -b -e
```

## Nettoyage (quand tu auras terminé)

```bash
sudo systemctl disable --now iterdemo.service
sudo rm -f /etc/systemd/system/iterdemo.service
sudo systemctl daemon-reload
sudo rm -rf /opt/iterdemo
sudo rm -f /var/tmp/iterdemo.log /run/iterdemo/service.log
sudo rm -f /etc/default/iterdemo
sudo userdel iterdemo 2>/dev/null || true
```

---

Si tu valides, on peut **jouer l’étape 1 en conditions réelles** (avec le test utilisateur qui casse, puis répare), puis enchaîner. Tu veux que je te donne un **tableau récap** “attribut → effet concret → commande de test” à la fin ?
